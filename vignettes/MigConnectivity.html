<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="author" content="Jeffrey A. Hostetler, Michael T. Hallworth" />

<meta name="date" content="2017-10-02" />

<title>MigConnectivity package</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<link href="data:text/css,body%20%7B%0A%20%20background%2Dcolor%3A%20%23fff%3B%0A%20%20margin%3A%201em%20auto%3B%0A%20%20max%2Dwidth%3A%20700px%3B%0A%20%20overflow%3A%20visible%3B%0A%20%20padding%2Dleft%3A%202em%3B%0A%20%20padding%2Dright%3A%202em%3B%0A%20%20font%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0A%20%20font%2Dsize%3A%2014px%3B%0A%20%20line%2Dheight%3A%201%2E35%3B%0A%7D%0A%0A%23header%20%7B%0A%20%20text%2Dalign%3A%20center%3B%0A%7D%0A%0A%23TOC%20%7B%0A%20%20clear%3A%20both%3B%0A%20%20margin%3A%200%200%2010px%2010px%3B%0A%20%20padding%3A%204px%3B%0A%20%20width%3A%20400px%3B%0A%20%20border%3A%201px%20solid%20%23CCCCCC%3B%0A%20%20border%2Dradius%3A%205px%3B%0A%0A%20%20background%2Dcolor%3A%20%23f6f6f6%3B%0A%20%20font%2Dsize%3A%2013px%3B%0A%20%20line%2Dheight%3A%201%2E3%3B%0A%7D%0A%20%20%23TOC%20%2Etoctitle%20%7B%0A%20%20%20%20font%2Dweight%3A%20bold%3B%0A%20%20%20%20font%2Dsize%3A%2015px%3B%0A%20%20%20%20margin%2Dleft%3A%205px%3B%0A%20%20%7D%0A%0A%20%20%23TOC%20ul%20%7B%0A%20%20%20%20padding%2Dleft%3A%2040px%3B%0A%20%20%20%20margin%2Dleft%3A%20%2D1%2E5em%3B%0A%20%20%20%20margin%2Dtop%3A%205px%3B%0A%20%20%20%20margin%2Dbottom%3A%205px%3B%0A%20%20%7D%0A%20%20%23TOC%20ul%20ul%20%7B%0A%20%20%20%20margin%2Dleft%3A%20%2D2em%3B%0A%20%20%7D%0A%20%20%23TOC%20li%20%7B%0A%20%20%20%20line%2Dheight%3A%2016px%3B%0A%20%20%7D%0A%0Atable%20%7B%0A%20%20margin%3A%201em%20auto%3B%0A%20%20border%2Dwidth%3A%201px%3B%0A%20%20border%2Dcolor%3A%20%23DDDDDD%3B%0A%20%20border%2Dstyle%3A%20outset%3B%0A%20%20border%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0A%20%20border%2Dwidth%3A%202px%3B%0A%20%20padding%3A%205px%3B%0A%20%20border%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0A%20%20border%2Dwidth%3A%201px%3B%0A%20%20border%2Dstyle%3A%20inset%3B%0A%20%20line%2Dheight%3A%2018px%3B%0A%20%20padding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0A%20%20border%2Dleft%2Dstyle%3A%20none%3B%0A%20%20border%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0A%20%20background%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0A%0Ap%20%7B%0A%20%20margin%3A%200%2E5em%200%3B%0A%7D%0A%0Ablockquote%20%7B%0A%20%20background%2Dcolor%3A%20%23f6f6f6%3B%0A%20%20padding%3A%200%2E25em%200%2E75em%3B%0A%7D%0A%0Ahr%20%7B%0A%20%20border%2Dstyle%3A%20solid%3B%0A%20%20border%3A%20none%3B%0A%20%20border%2Dtop%3A%201px%20solid%20%23777%3B%0A%20%20margin%3A%2028px%200%3B%0A%7D%0A%0Adl%20%7B%0A%20%20margin%2Dleft%3A%200%3B%0A%7D%0A%20%20dl%20dd%20%7B%0A%20%20%20%20margin%2Dbottom%3A%2013px%3B%0A%20%20%20%20margin%2Dleft%3A%2013px%3B%0A%20%20%7D%0A%20%20dl%20dt%20%7B%0A%20%20%20%20font%2Dweight%3A%20bold%3B%0A%20%20%7D%0A%0Aul%20%7B%0A%20%20margin%2Dtop%3A%200%3B%0A%7D%0A%20%20ul%20li%20%7B%0A%20%20%20%20list%2Dstyle%3A%20circle%20outside%3B%0A%20%20%7D%0A%20%20ul%20ul%20%7B%0A%20%20%20%20margin%2Dbottom%3A%200%3B%0A%20%20%7D%0A%0Apre%2C%20code%20%7B%0A%20%20background%2Dcolor%3A%20%23f7f7f7%3B%0A%20%20border%2Dradius%3A%203px%3B%0A%20%20color%3A%20%23333%3B%0A%7D%0Apre%20%7B%0A%20%20white%2Dspace%3A%20pre%2Dwrap%3B%20%20%20%20%2F%2A%20Wrap%20long%20lines%20%2A%2F%0A%20%20border%2Dradius%3A%203px%3B%0A%20%20margin%3A%205px%200px%2010px%200px%3B%0A%20%20padding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0A%20%20background%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0A%0Acode%20%7B%0A%20%20font%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0A%20%20font%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0A%20%20padding%3A%202px%200px%3B%0A%7D%0A%0Adiv%2Efigure%20%7B%0A%20%20text%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0A%20%20background%2Dcolor%3A%20%23FFFFFF%3B%0A%20%20padding%3A%202px%3B%0A%20%20border%3A%201px%20solid%20%23DDDDDD%3B%0A%20%20border%2Dradius%3A%203px%3B%0A%20%20border%3A%201px%20solid%20%23CCCCCC%3B%0A%20%20margin%3A%200%205px%3B%0A%7D%0A%0Ah1%20%7B%0A%20%20margin%2Dtop%3A%200%3B%0A%20%20font%2Dsize%3A%2035px%3B%0A%20%20line%2Dheight%3A%2040px%3B%0A%7D%0A%0Ah2%20%7B%0A%20%20border%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0A%20%20padding%2Dtop%3A%2010px%3B%0A%20%20padding%2Dbottom%3A%202px%3B%0A%20%20font%2Dsize%3A%20145%25%3B%0A%7D%0A%0Ah3%20%7B%0A%20%20border%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0A%20%20padding%2Dtop%3A%2010px%3B%0A%20%20font%2Dsize%3A%20120%25%3B%0A%7D%0A%0Ah4%20%7B%0A%20%20border%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0A%20%20margin%2Dleft%3A%208px%3B%0A%20%20font%2Dsize%3A%20105%25%3B%0A%7D%0A%0Ah5%2C%20h6%20%7B%0A%20%20border%2Dbottom%3A%201px%20solid%20%23ccc%3B%0A%20%20font%2Dsize%3A%20105%25%3B%0A%7D%0A%0Aa%20%7B%0A%20%20color%3A%20%230033dd%3B%0A%20%20text%2Ddecoration%3A%20none%3B%0A%7D%0A%20%20a%3Ahover%20%7B%0A%20%20%20%20color%3A%20%236666ff%3B%20%7D%0A%20%20a%3Avisited%20%7B%0A%20%20%20%20color%3A%20%23800080%3B%20%7D%0A%20%20a%3Avisited%3Ahover%20%7B%0A%20%20%20%20color%3A%20%23BB00BB%3B%20%7D%0A%20%20a%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0A%20%20%20%20text%2Ddecoration%3A%20underline%3B%20%7D%0A%20%20a%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0A%20%20%20%20text%2Ddecoration%3A%20underline%3B%20%7D%0A%0A%2F%2A%20Class%20described%20in%20https%3A%2F%2Fbenjeffrey%2Ecom%2Fposts%2Fpandoc%2Dsyntax%2Dhighlighting%2Dcss%0A%20%20%20Colours%20from%20https%3A%2F%2Fgist%2Egithub%2Ecom%2Frobsimmons%2F1172277%20%2A%2F%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%2F%2A%20Keyword%20%2A%2F%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%2F%2A%20DataType%20%2A%2F%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%2F%2A%20DecVal%20%28decimal%20values%29%20%2A%2F%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%2F%2A%20BaseN%20%2A%2F%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%2F%2A%20Float%20%2A%2F%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%2F%2A%20Char%20%2A%2F%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%2F%2A%20String%20%2A%2F%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%2F%2A%20Comment%20%2A%2F%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%2F%2A%20OtherToken%20%2A%2F%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%2F%2A%20AlertToken%20%2A%2F%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%2F%2A%20Function%20calls%20%2A%2F%20%0Acode%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%2F%2A%20ErrorTok%20%2A%2F%0A%0A" rel="stylesheet" type="text/css" />

</head>

<body>



<div id="header">
<h1 class="title">‘MigConnectivity’ package</h1>
<h4 class="author"><em>Jeffrey A. Hostetler, Michael T. Hallworth</em></h4>
<h4 class="date"><em>2017-10-02</em></h4>
</div>


<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>Technological advancements have spurred rapid growth in the study of migratory connectivity, the spatial and temporal linkage of migratory populations throughout the annual cycle. However, the lack of a quantitative definition for the strength of migratory connectivity (MC) has limited our ability to draw inferences across species, studies, and data types about the seasonal co-occurrence of populations. MC is a standardized metric to quantify migratory connectivity between two phases of the annual cycle. It is independent of data type and accounts for the relative abundance of populations distributed across a seasonal range. Negative values of MC indicate that individuals close to each other in one season are further apart in the other season. If MC = 0, no relationship exists between distances in one season and another; if MC = 1, the relative distances between individuals in one season are the same in the other, although the scale can differ.</p>
<p>Three data inputs are needed to calculate MC, and one is optional:</p>
<ol style="list-style-type: decimal">
<li><p>The probabilities of movement between regions (i.e., transition probabilities);</p></li>
<li><p>Distances between regions within the two distinct seasonal ranges (e.g., a matrix of distances between all regions within the breeding range and a matrix of distances between all regions within the non-breeding range);</p></li>
<li><p>Relative abundance among regions within the seasonal range from which the transition probabilities originate (e.g., relative abundance among breeding regions);</p></li>
<li><p>(Optional) Total sample size of animals used to estimate the transition probabilities.</p></li>
</ol>
<p>MC takes the distances between the regions within the seasonal range from which the transition probabilities originate (e.g. breeding) and the distances between the regions within the other seasonal range (e.g. non-breeding) and approximates the correlation between individuals at those distances. Earlier methods (Mantel correlation; rM) used the correlation between two distance matrices of individual animals captured during the breeding phase and recaptured during the non-breeding phase as a measure of the strength of migratory connectivity. Our method builds on this method with a distance-based correlation coefficient approximation, but is not specific to a data type and uses transition probabilities from discreet regions, as opposed to distance matrices between individuals. Further, we include relative abundance within one seasonal range to account for uneven sampling among regions.</p>
<p>Cohen, E. B., J.A. Hostetler, M.T. Hallworth, C.S. Rushing, T.S. Sillett, P.P. Marra. In press. Quantifying the strength of migratory connectivity. Methods in Ecology and Evolution.</p>
<div id="overview-of-functions" class="section level3">
<h3>Overview of Functions</h3>
<ol style="list-style-type: decimal">
<li><p><code>calcMC</code> calculates the strength of migratory connectivity (MC) with the transitional probabilities between regions, distances between regions within the two seasonal ranges, relative abundance among regions within the seasonal range from which the transition probabilities originate, and (optionally) the total sample size of the transitional probability data.</p></li>
<li><p><code>estMC</code> estimates the strength of migratory connectivity (MC) with estimates of uncertainty. MC estimated either with transition probability estimates or individual assignments to regions from tracking data. Uses re-sampling to measure MC uncertainty from RMark transition probability matrix estimates and/or JAGS relative abundance MCMC samples OR geolocator and/or GPS data.</p></li>
<li><p><code>simMove</code> Simulates annual movement of animals between regions across seasons for years and months with individual variability and strength of migratory connectivity (MC). Incorporates movement among regions within a season and movement among regions between seasons. Between seasons, animals either return to the same region each year or return to a different region in the subsequent year (dispersal). Between year dispersal rates occur during the first year (natal) or any subsequent year (breeding or non-breeding). Simulation does not incorporate births or deaths.</p></li>
</ol>
</div>
</div>
<div id="getting-started" class="section level2">
<h2>Getting Started</h2>
<div id="installing-migconnectivity-from-github" class="section level3">
<h3>Installing ‘MigConnectivity’ from GitHub</h3>
<p>In order to install the vignette along with the package use the following code with <code>build_vignettes = TRUE</code>. <strong>Note</strong> it takes quite a bit longer to download the package when <code>build_vignettes = TRUE</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">install.packages</span>(<span class="st">'devtools'</span>)

devtools::<span class="kw">install_github</span>(<span class="st">&quot;SMBC-NZP/MigConnectivity&quot;</span>, <span class="dt">build_vignettes =</span> <span class="ot">TRUE</span>)

<span class="kw">library</span>(MigConnectivity)</code></pre>
</div>
<div id="functions" class="section level3">
<h3>Functions</h3>
<p><code>calcMC</code> Calculate strength of migratory connectivity (MC)<br /><code>estMC</code> Estimate the strength of migratory connectivity (MC) while incorporating sampling uncertainty<br /><code>simMove</code> Simulates annual and seasonal movement of animals between regions</p>
</div>
</div>
<div id="examples" class="section level2">
<h2>Examples</h2>
<div id="utility-functions-for-use-in-vignette" class="section level3">
<h3>Utility functions for use in vignette</h3>
<p><code>mlogitMat</code>: Calculates probability matrix based on exponential decline with distance</p>
<pre class="sourceCode r"><code class="sourceCode r">mlogitMat &lt;-<span class="st"> </span>function(slope, dist) {
       preMat &lt;-<span class="st"> </span><span class="kw">exp</span>(-slope/<span class="kw">mean</span>(dist)*dist)
       <span class="kw">diag</span>(preMat) &lt;-<span class="st"> </span><span class="dv">0</span>
       nr &lt;-<span class="st"> </span><span class="kw">nrow</span>(dist)
       nc &lt;-<span class="st"> </span><span class="kw">ncol</span>(dist)
       outMat &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>, nr, nc)
  for (b in <span class="dv">1</span>:nr) {
      outMat[b,] &lt;-<span class="st"> </span>preMat[b,]/(<span class="dv">1</span>+<span class="kw">sum</span>(preMat[b, ]))
      outMat[b,b] &lt;-<span class="st"> </span><span class="dv">1</span> -<span class="st"> </span><span class="kw">sum</span>(outMat[b, ])
  }
  <span class="kw">return</span>(outMat)
}</code></pre>
<p><code>mlogitMC</code>: Crude optimization function for developing migratory connectivity pattern based on migratory connectivity strength. Uses same argument (origin.abund) for relative or absolute abundance.</p>
<pre class="sourceCode r"><code class="sourceCode r">mlogitMC &lt;-<span class="st"> </span>function(slope, 
                     MC.in, 
                     origin.dist,
                     target.dist,
                     origin.abund,
                     sample.size) {
  
    nBreeding &lt;-<span class="st"> </span><span class="kw">nrow</span>(origin.dist)
    nWintering &lt;-<span class="st"> </span><span class="kw">nrow</span>(target.dist)
    psi &lt;-<span class="st"> </span><span class="kw">mlogitMat</span>(slope, origin.dist)
    
  if (<span class="kw">any</span>(psi&lt;<span class="dv">0</span>))
    
    <span class="kw">return</span>(<span class="dv">5</span>*slope^<span class="dv">2</span>)
    
  MC &lt;-<span class="st"> </span><span class="kw">calcMC</span>(origin.dist, 
               target.dist, 
               <span class="dt">originRelAbund =</span> origin.abund,
               psi, 
               <span class="dt">sampleSize =</span> sample.size)
  
  <span class="kw">return</span>((MC.in -<span class="st"> </span>MC)^<span class="dv">2</span>)
}</code></pre>
<p><code>calcStrengthInd</code>: rM function for individuals</p>
<pre class="sourceCode r"><code class="sourceCode r">calcStrengthInd &lt;-<span class="st"> </span>function(originDist, 
                            targetDist, 
                            locations, 
                            <span class="dt">resamp=</span><span class="dv">1000</span>, 
                            <span class="dt">verbose =</span> <span class="dv">0</span>) {
nInd &lt;-<span class="st"> </span><span class="kw">dim</span>(locations)[<span class="dv">1</span>]
originDist2 &lt;-<span class="st"> </span>targetDist2 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>, nInd, nInd)
for (i in <span class="dv">1</span>:(nInd<span class="dv">-1</span>)) {
 for (j in (i<span class="dv">+1</span>):nInd) {
      originDist2[i,j] &lt;-<span class="st"> </span>originDist[locations[i,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>], locations[j,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>]]
      targetDist2[i,j] &lt;-<span class="st"> </span>targetDist[locations[i,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">1</span>], locations[j,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">1</span>]]
      originDist2[j,i] &lt;-<span class="st"> </span>originDist[locations[i,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>], locations[j,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>]]
      targetDist2[j,i] &lt;-<span class="st"> </span>targetDist[locations[i,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">1</span>], locations[j,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">1</span>]]
    }
  }
<span class="kw">return</span>(ncf::<span class="kw">mantel.test</span>(originDist2, targetDist2, <span class="dt">resamp=</span>resamp, <span class="dt">quiet =</span> !verbose))
} </code></pre>
<p><code>calcPsiMC</code>: Simple approach to estimate psi matrix (transition probabilities) and MC from simulated or real data (does not incorporate sampling uncertainty)</p>
<pre class="sourceCode r"><code class="sourceCode r">calcPsiMC &lt;-<span class="st"> </span>function(originDist, 
                      targetDist, 
                      originRelAbund, 
                      locations, 
                      <span class="dt">years =</span> <span class="dv">1</span>, 
                      <span class="dt">months =</span> <span class="dv">1</span>, 
                      <span class="dt">verbose=</span>F) {
  
  nOrigin &lt;-<span class="st"> </span><span class="kw">nrow</span>(originDist)
  nTarget &lt;-<span class="st"> </span><span class="kw">nrow</span>(targetDist)
  psiMat &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>, nOrigin, nTarget)
  nInd &lt;-<span class="st"> </span><span class="kw">dim</span>(locations)[<span class="dv">1</span>]
  nYears &lt;-<span class="st"> </span><span class="kw">dim</span>(locations)[<span class="dv">3</span>]
  nMonths &lt;-<span class="st"> </span><span class="kw">dim</span>(locations)[<span class="dv">4</span>]
for (i in <span class="dv">1</span>:nInd) {
  if (i %%<span class="st"> </span><span class="dv">1000</span> ==<span class="st"> </span><span class="dv">0</span> &amp;&amp;<span class="st"> </span>verbose) <span class="co">#</span>
      <span class="kw">cat</span>(<span class="st">&quot;Individual&quot;</span>, i, <span class="st">&quot;of&quot;</span>, nInd, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
    originMat &lt;-<span class="st"> </span>locations[i, <span class="dv">1</span>, years, months]
    targetMat &lt;-<span class="st"> </span>locations[i, <span class="dv">2</span>, years, months]
    bIndices &lt;-<span class="st"> </span><span class="kw">which</span>(!<span class="kw">is.na</span>(originMat))
    wIndices &lt;-<span class="st"> </span><span class="kw">which</span>(!<span class="kw">is.na</span>(targetMat))
  if (<span class="kw">length</span>(bIndices) &amp;&amp;<span class="st"> </span><span class="kw">length</span>(wIndices))
    for (bi in bIndices)
      for (wi in wIndices)
       psiMat[originMat[bi], targetMat[wi]] &lt;-<span class="st"> </span>psiMat[originMat[bi], 
                                                      targetMat[wi]] +<span class="st"> </span><span class="dv">1</span>
  }
  psiMat &lt;-<span class="st"> </span><span class="kw">apply</span>(psiMat, <span class="dv">2</span>, <span class="st">&quot;/&quot;</span>, <span class="kw">rowSums</span>(psiMat))
  MC &lt;-<span class="st"> </span><span class="kw">calcMC</span>(originDist, targetDist, <span class="dt">psi =</span> psiMat,
               <span class="dt">originRelAbund =</span> originRelAbund, <span class="dt">sampleSize =</span> nInd)
  <span class="kw">return</span>(<span class="kw">list</span>(<span class="dt">psi=</span>psiMat, <span class="dt">MC=</span>MC))
}</code></pre>
<p><code>changeLocations</code>: transfers the simulated bird locations from the true populations to the researcher defined regions</p>
<pre class="sourceCode r"><code class="sourceCode r">changeLocations &lt;-<span class="st"> </span>function(animalLoc, 
                            breedingSiteTrans, 
                            winteringSiteTrans) {
  animalLoc[,<span class="dv">1</span>,,] &lt;-<span class="st"> </span>breedingSiteTrans[animalLoc[,<span class="dv">1</span>,,]]
  animalLoc[,<span class="dv">2</span>,,] &lt;-<span class="st"> </span>winteringSiteTrans[animalLoc[,<span class="dv">2</span>,,]]
  <span class="kw">return</span>(animalLoc)
}</code></pre>
<p><code>simLocationError</code>: Simulates location error with defined bias and variance / covariance matrix</p>
<pre class="sourceCode r"><code class="sourceCode r">simLocationError &lt;-<span class="st"> </span>function(targetPoints, 
                             targetSites, 
                                         geoBias, 
                                         geoVCov, 
                             projection, 
                                         <span class="dt">verbose =</span> <span class="dv">0</span>, 
                                         <span class="dt">nSim =</span> <span class="dv">1000</span>) {

nAnimals &lt;-<span class="st"> </span><span class="kw">length</span>(targetPoints)
geoBias2 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rep</span>(geoBias, nSim), <span class="dt">nrow=</span>nSim, <span class="dt">byrow=</span>T)
target.sample &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, nAnimals)
target.point.sample &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, nAnimals, <span class="dv">2</span>)

for(i in <span class="dv">1</span>:nAnimals){
  if (verbose &gt;<span class="st"> </span><span class="dv">0</span>)
    <span class="kw">cat</span>(<span class="st">'Animal'</span>, i, <span class="st">'of'</span>, nAnimals)
  draws &lt;-<span class="st"> </span><span class="dv">0</span>
  while (<span class="kw">is.na</span>(target.sample[i])) {
    draws &lt;-<span class="st"> </span>draws +<span class="st"> </span><span class="dv">1</span>
    <span class="co"># Sample random point for each bird </span>
    <span class="co"># from parametric distribution of NB error</span>
    point.sample &lt;-<span class="st"> </span>sp::<span class="kw">SpatialPoints</span>(
                  MASS::<span class="kw">mvrnorm</span>(<span class="dt">n=</span>nSim, 
                  <span class="dt">mu=</span><span class="kw">cbind</span>(targetPoints@coords[i,<span class="dv">1</span>],targetPoints@coords[i,<span class="dv">2</span>]),
                  <span class="dt">Sigma=</span>geoVCov)+
<span class="st">                  </span>geoBias2,
                  sp::<span class="kw">CRS</span>(projection))
      
    <span class="co"># filtered to stay in NB areas (land)</span>
    target.sample0 &lt;-<span class="st"> </span>sp::<span class="kw">over</span>(point.sample, targetSites)
    target.sample[i]&lt;-target.sample0[!<span class="kw">is.na</span>(target.sample0)][<span class="dv">1</span>]
  }
    
  target.point.sample[i, ]&lt;-point.sample[!<span class="kw">is.na</span>(target.sample0)][<span class="dv">1</span>]@coords
  if (verbose &gt;<span class="st"> </span><span class="dv">0</span>)
    <span class="kw">cat</span>(<span class="st">' '</span>, draws, <span class="st">'draws</span><span class="ch">\n</span><span class="st">'</span>)
}
  <span class="kw">return</span>(<span class="kw">list</span>(<span class="dt">targetSample =</span> target.sample, 
              <span class="dt">targetPointSample =</span> target.point.sample))
}</code></pre>
<p><code>toPoly</code>: Helper function to convert a string of XY coordinates of centroids to polygons</p>
<pre class="sourceCode r"><code class="sourceCode r">toPoly &lt;-<span class="st"> </span>function(siteCentroids,
                   <span class="dt">projection.in =</span> <span class="st">&quot;+proj=longlat </span>
<span class="st">                                    +datum=WGS84 </span>
<span class="st">                                    +no_defs </span>
<span class="st">                                    +ellps=WGS84 </span>
<span class="st">                                    +towgs84=0,0,0&quot;</span>,
                   <span class="dt">projection.out =</span> <span class="ot">NA</span>,
                   <span class="dt">resolution =</span> <span class="ot">NA</span>,
                   <span class="dt">order.by.input =</span> <span class="ot">TRUE</span>)
{
<span class="co"># This automatically sets the resolution so that all polygons touch and</span>
<span class="co"># cover the entire surface. Alternatively the user can supply the </span>
<span class="co"># resolution of the raster cells in the units of the input projection </span>
<span class="co">#(projection.in) </span>
  
  if(<span class="kw">is.na</span>(resolution)){
     long &lt;-<span class="st"> </span><span class="kw">unique</span>(siteCentroids[,<span class="dv">1</span>])
     lat &lt;-<span class="st"> </span><span class="kw">unique</span>(siteCentroids[,<span class="dv">2</span>])
     long.res &lt;-<span class="st"> </span>long[<span class="dv">2</span>]-long[<span class="dv">1</span>]
     lat.res &lt;-<span class="st"> </span>lat[<span class="dv">2</span>]-lat[<span class="dv">1</span>]
     resolution &lt;-<span class="st"> </span><span class="kw">c</span>(long.res,long.res)
  }
  rast &lt;-<span class="st"> </span><span class="kw">suppressWarnings</span>(
          raster::<span class="kw">rasterFromXYZ</span>(<span class="kw">cbind</span>(<span class="kw">cbind</span>(siteCentroids),
                                (<span class="dv">1</span>:<span class="kw">nrow</span>(siteCentroids))),
                                 <span class="dt">res =</span> resolution,
                                  <span class="dt">crs =</span> projection.in))
  
  polys &lt;-<span class="st"> </span>raster::<span class="kw">rasterToPolygons</span>(rast)
  
  <span class="co"># Give unique names to polygons #</span>
  
  polys &lt;-<span class="st"> </span>sp::<span class="kw">SpatialPolygons</span>(polys@polygons)
  raster::<span class="kw">crs</span>(polys)&lt;-projection.in
  
  <span class="co"># Reorders the polygons to match that of the input #</span>
  centers &lt;-<span class="st"> </span>sp::<span class="kw">SpatialPoints</span>(siteCentroids, sp::<span class="kw">CRS</span>(projection.in))
  
  if(order.by.input){
  orders &lt;-<span class="st"> </span>sp::<span class="kw">over</span>(centers,polys)
  polys &lt;-<span class="st"> </span>polys[orders] 
  }
  sp::<span class="kw">spChFIDs</span>(polys,<span class="kw">as.character</span>(<span class="dv">1</span>:<span class="kw">length</span>(polys)))
  
  if(!<span class="kw">is.na</span>(projection.out)){
    polys &lt;-<span class="st"> </span>sp::<span class="kw">spTransform</span>(polys,sp::<span class="kw">CRS</span>(projection.out))
  }
  
  <span class="kw">return</span>(polys)
}</code></pre>
</div>
<div id="example-1" class="section level3">
<h3>EXAMPLE 1</h3>
</div>
<div id="calcmc---calculate-strength-of-migratory-connectivity" class="section level3">
<h3><code>calcMC</code> - Calculate strength of migratory connectivity</h3>
<p>This function calculates the strength of migratory connectivity between populations during two different time periods within the annual cycle. Below, we illustrate how to calculate the strength of MC between three breeding and non-breeding regions.</p>
<p>To calculate the strength of MC, you will need:</p>
<ol style="list-style-type: decimal">
<li>to define the number of breeding and non-breeding regions<br /></li>
<li>the distance between the breeding regions and the distance between the non-breeding regions<br /></li>
<li>the transition probabilities between each breeding and non-breeding region (<code>psi</code>)<br /></li>
<li>the relative abundance within each of the regions where individuals originate from (here the breeding regions)</li>
<li>(optional) the total sample size of animals used to estimate the transition probabilities.</li>
</ol>
</div>
<div id="calculate-mc-between-breeding-and-non-breeding-regions" class="section level3">
<h3>Calculate MC between breeding and non-breeding regions</h3>
<p>Simple example with three breeding and three non-breeding regions</p>
<p>Define the number of breeding and non-breeding populations</p>
<pre class="sourceCode r"><code class="sourceCode r">nBreeding &lt;-<span class="st"> </span><span class="dv">3</span> <span class="co">#number of breeding regions</span>
nNonBreeding &lt;-<span class="st"> </span><span class="dv">3</span> <span class="co">#number of non-breeding regions</span></code></pre>
<p>Generate a distance matrix between the different regions</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co">#distances between centriods of three breeding regions</span>
breedDist &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>,
                      <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>,
                      <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">0</span>), nBreeding, nBreeding) 

<span class="co">#distances between centriods of three non-breeding regions</span>
nonBreedDist &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">5</span>, <span class="dv">10</span>,
                         <span class="dv">5</span>, <span class="dv">0</span>, <span class="dv">5</span>,
                        <span class="dv">10</span>, <span class="dv">5</span>, <span class="dv">0</span>), nNonBreeding, nNonBreeding)</code></pre>
<p><img src="data:image/png;base64,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" /></p>
<p>Define the transition probabilities between the breeding and non-breeding regions</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co">#transition probabilities form each breeding to each non-breeding region</span>
psi &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="fl">0.4</span>, <span class="fl">0.35</span>, <span class="fl">0.25</span>,
                <span class="fl">0.3</span>, <span class="fl">0.4</span>, <span class="fl">0.3</span>,
                <span class="fl">0.2</span>, <span class="fl">0.3</span>, <span class="fl">0.5</span>), nBreeding, nNonBreeding, <span class="dt">byrow =</span> <span class="ot">TRUE</span>) </code></pre>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAAEgCAMAAAAjXV6yAAAAV1BMVEUAAAAAADoAAGYAOjoAOpAAZrY6AAA6ADo6OgA6kNtmAABmADpmkJBmtrZmtv+QOgCQkGaQtpCQ2/+2ZgC2tma2///bkDrb////tmb/25D//7b//9v///9ZWHLVAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAIcklEQVR4nO2ci3bjJhRFSZq447R1pnHjOAn//52VQCCQkA6SeSjy2WvNBAOCyw4vubMqJJlF1A5g61AQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEGAeoIuouPpI/aRs3h8/35d8EACNiCoGXXkI/cqSBwjHznHu0xGTUF6tJ8H8dx+evj3IB7eWguizWjxkw9v/Qy6qE+qvluYIcxNCDqa+fT08fViV52TbKyY1WgEaVpDuvDh1/4Eubv0pdus1Txo1By95FXNpLMnqCm8iEFhhjC3IOikP7U/tA81u5xkt/k0OY6gk1mdTmGGMLcgSC8xtZ80QzZrx0k2UtRW5O9BSsqzNMfabvcg/avvBF2FteIklQg5IcgtzBBmfUF6sP0MOnXlTtKdJPc3g5oB9oLMdPCToT3ICrqHPciOWB1Gp3awTZaTDJxivaD9n2LtWI2g7vLTDd8k1ZXRvwf1gnZ/D1LjMoL0cPXblpNUhk7BPUh2s2d3e1BqznleYncg6KwuUvrSmJ4dCLo6W1l6diCo280zfUu0B0FZoSAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBgC0K0v+aBX4oFEzR3qIw/zQPfCgVTcnOouj/8evsh2LhFOwrCuEw86FcPOW6ikLEUTCgcl1FESmoXNgUhAIq1lMcFASgIMDW/GxOEI95iGdh4gMFGQ1iwlDBcMp1FUlwSQ0NFQynXFdxWDlOskv3NUrGU7CvKKwPkx4JKhxPlV6nEY4gT00tQ1sUJOV4iZVeWX1ANTqdRnjzxW7UukzWCHeDgkzCZvRTp8Is2pYgMRIkKcjBkeGd6hTUQUHzuKtpwsp9b9ITc2XqBlRmOm1I0HA7Fm4JqJ4xqvxdxOIusIGU0Cq7O0GDHdoffWDtFXqt35YgJ2Vu1LY0WO2OBHl3ROd1tS92Kg6eyBpX9h7iGF2BOkFuhS7a8FtItsBydxDJcAKNTy7ro+wU2oigkZ/A7UcMi+5NkJ8IXH78XTxYJUNk2XuIwZtAfd641mRZvtBKdTRLeAKNYpstzBVaoX5mGe0uU/tLBUObEWQSTlb4BWyQyB5bmW5mce9AXu4g4eeWiW0LgsBkGZSW/sps04KCF6LChuoLmrzuTQoqGvM2BA0ybIFfXnp/djutx2gCDTfn8REXegnJF1+2lmMDmJpA04KGQrK+k9UWNDO4aUHyzgRNxDEjyJlmMvMXQ5UFmaFNvFd4X/+EbpF9lVyG6goSIwmDUlDWfz27b0H9nXBYKiffS0sZqiposMDG59mMIP+hHQuSkxMICJKjKZQnxiytRvbtL7BQuZz76mdgKFOQeZqN63veT4Sg4MtaWioKEuh3P9jBgxWcH3moLGj+9+9u4YsvAqmizNYy7FmNy+7TE1XkrCCZf5HVFeSskokqwbRXZaYwBdUE2TvQTBhRgqY2qETUEhR1cfGqzB9l2fg5gm6qtJ5KguJuvnGbb15DFQXFVYuqtfSJBdQR5E6guRFFDtf9qjG1oXqC+uRsvcjmnIZ3ICh2AkUvGFtPJDdUTVBsRZuMq7gLQd1LRlzNUWquptiFIPsSFlfVT8xUNQssraFaghae81G3yp0I6kcRd1W0f+Kq7kNQ7KClHXDkjXoHp9iiCSQXzYj000dWFLSo9rK2V8cWbDNpaxH9ZR1y/xVlMioJylRdxt4f4iksaOkxs1zQzz7F7A690NDiHtYEN9FguqZielsraOkcWhVduL10TUV01g12+ZpZ+MSa4KaaS9gW7mx57MsFLdEf01rKxlBfZQSl/W9lpQWteWa5ILHutxFsLEEbsV2tF7QwTCHSfTFUWNDyDeIGrUkMlRO0MuZ140xnqJggsW4CrV0qP1VQ4ecSGColaHW0FIQfvKXHnyJofbDrR/mj9qAbgr3N0Lo+3UZubiGqlyqCkhgqKKjSsysftU3c+Pxc0z4VGpA3N0BBuIlVT8U1TUGgaQoCTVMQaJqCQNMUBJqmINA0BYGmKQg0TUGgaQoCTVMQaJqC7gEKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCFBD0Pfr43v78/z0Ea7weThFNHN9ePt6ial4E3UEief25+2CEgY1RR1Bf/zZjo2CJvh+fb60U0gJugohjlJ+vfzzIkTn5fPw90Hn/vVbNMvxoutIL/HwWy+x/smzzkwbbCVBavNoBV1FO8Tn5k8zsks3us9Dk/g8HJvc1uGl+9Qnzo21qzCCuidNZtpgKwmSl2bkjaDv13ZCqO322C8tJUFeHt9VrvpLXrtPbULXOxtB+kmbmTbYWoJaM40gParmbzWlzKGkc80ppfeaJq9PqFPwagTpJ21m2mBrCWonghXUDM8XpPbw5m8tqPvfIJ5s4hISdNmZIHk+hmaQ2oZDM0i6iXuYQc0E+eXtQd4SU3vQ04eX2ye0wIsvyGamDbaeoOZU9k4xT1AzTF1iB302p5xJ9KdY9+S+TjEpuzPc3oM8Qe09qM9o151aQG6ivweZis096PE//RaTjr29rF4paAq1B+mrUkr2I0hfB5K/3e9IUB4oCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEOB/UorqrnqnfyAAAAAASUVORK5CYII=" /></p>
<p>Define the relative abundance within the three breeding regions</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co">#equal relative abundance among the three breeding regions, must sum to 1                      </span>
relN &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">1</span>/nBreeding, nBreeding) 

relN
<span class="co">#&gt; [1] 0.3333333 0.3333333 0.3333333</span>

<span class="co"># Define total sample size for psi data </span>
<span class="co"># for small sample corrected version of MC </span>

n &lt;-<span class="st"> </span><span class="dv">250</span></code></pre>
<p>Calculate the strength of migratory connectivity using the inputs above</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Calculate the strength of migratory connectivity </span>
MC &lt;-<span class="st"> </span><span class="kw">calcMC</span>(<span class="dt">originDist =</span> breedDist,
             <span class="dt">targetDist =</span> nonBreedDist,
             <span class="dt">originRelAbund =</span> relN,
             <span class="dt">psi =</span> psi)

<span class="kw">round</span>(MC, <span class="dv">3</span>)
<span class="co">#&gt; [1] 0.05</span>

MC &lt;-<span class="st"> </span><span class="kw">calcMC</span>(<span class="dt">originDist =</span> breedDist,
             <span class="dt">targetDist =</span> nonBreedDist,
             <span class="dt">originRelAbund =</span> relN, 
             <span class="dt">psi =</span> psi,
             <span class="dt">sampleSize =</span> n)

<span class="kw">round</span>(MC, <span class="dv">3</span>)
<span class="co">#&gt; [1] 0.044</span></code></pre>
</div>
<div id="example-2" class="section level3">
<h3>EXAMPLE 2</h3>
</div>
<div id="estmc---estimate-strength-of-migratory-connectivity-incorporating-location-and-other-sampling-uncertainty" class="section level3">
<h3><code>estMC</code> - Estimate strength of migratory connectivity incorporating location and other sampling uncertainty</h3>
<p>Estimates of MC may also be influenced by error in individual assignment to regions. Data types vary in location accuracy and precision, which are likely to influence the accuracy with which individuals are assigned to regions.</p>
<p>To estimate MC and include location uncertainty the following data are needed:</p>
<ol style="list-style-type: decimal">
<li>A logical vector indicating the type of device the location estimates were derived from (GPS = FALSE, Light-level geolocator = TRUE)<br /></li>
<li>Location Bias - a vector that has error estimates for both longitude and latitude<br /></li>
<li>Location error - a variance, covariance matrix of longitude and latitude<br /></li>
<li>Distance matrix between breeding and non-breeding regions<br /></li>
<li>A shapefile of both breeding and non-breeding regions<br /></li>
<li>The deployment locations and the ‘unknown’ locations derived from the tracking devices<br /></li>
<li>The relative (or absolute) abundance within each region where the birds originate from (deployment regions)</li>
</ol>
<p>Below is a repeatable example for how to calculate location bias and location error using coordinates derived from light-level geolocators.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Define projections # </span>

WGS84&lt;-<span class="st">&quot;+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0&quot;</span>

Lambert&lt;-<span class="st">&quot;+proj=aea +lat_1=20 +lat_2=60 +lat_0=40 +lon_0=-96 </span>
<span class="st">          +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs&quot;</span>

<span class="co"># Define deployment locations (winter) # </span>

captureLocations&lt;-<span class="kw">matrix</span>(<span class="kw">c</span>(-<span class="fl">77.93</span>,<span class="fl">18.04</span>,   <span class="co"># Jamaica</span>
                           -<span class="fl">80.94</span>,<span class="fl">25.13</span>,   <span class="co"># Florida</span>
                           -<span class="fl">66.86</span>,<span class="fl">17.97</span>),  <span class="co"># Puerto Rico</span>
                            <span class="dt">nrow=</span><span class="dv">3</span>, <span class="dt">ncol=</span><span class="dv">2</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>)

<span class="co"># Convert capture locations into SpatialPoints #</span>

CapLocs&lt;-sp::<span class="kw">SpatialPoints</span>(captureLocations,sp::<span class="kw">CRS</span>(WGS84))

<span class="co"># Project Capture locations # </span>

CapLocsM&lt;-sp::<span class="kw">spTransform</span>(CapLocs, sp::<span class="kw">CRS</span>(Lambert))

<span class="co"># Retrieve raw non-breeding locations from github </span>
<span class="co"># First grab the identity of the bird so we can loop through the files </span>
<span class="co"># For this example we are only interested in the error </span>
<span class="co"># around non-breeding locations </span>
<span class="co"># here we grab only the birds captured during the non-breeding season </span>

winterBirds &lt;-<span class="st"> </span><span class="kw">dget</span>(<span class="kw">paste0</span>(<span class="st">&quot;https://raw.githubusercontent.com/&quot;</span>,
                    <span class="st">&quot;SMBC-NZP/MigConnectivity/master/&quot;</span>,
                    <span class="st">&quot;data-raw/GL_NonBreedingFiles/winterBirds.txt&quot;</span>))

<span class="co"># create empty list to store the location data #</span>
Non_breeding_files &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">'list'</span>,<span class="kw">length</span>(winterBirds))

<span class="co"># Get raw location data from Github #</span>
for(i in <span class="dv">1</span>:<span class="kw">length</span>(winterBirds)){
Non_breeding_files[[i]] &lt;-<span class="st"> </span><span class="kw">dget</span>(<span class="kw">paste0</span>(<span class="st">&quot;https://raw.githubusercontent.com/&quot;</span>,
                                        <span class="st">&quot;SMBC-NZP/MigConnectivity/master/data-raw/&quot;</span>,
                                        <span class="st">&quot;GL_NonBreedingFiles/NonBreeding_&quot;</span>,
                                        winterBirds[i],<span class="st">&quot;.txt&quot;</span>))
}

<span class="co"># Remove locations around spring Equinox and potential migration points</span>
<span class="co"># same NB time frame as Hallworth et al. 2015 </span>

<span class="co"># two steps because subset on shapefile doesn't like it in a single step</span>

Non_breeding_files &lt;-<span class="st"> </span><span class="kw">lapply</span>(Non_breeding_files,
                      <span class="dt">FUN =</span> function(x){
                      month &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(<span class="kw">format</span>(x$Date,<span class="dt">format =</span> <span class="st">&quot;%m&quot;</span>))
                               x[<span class="kw">which</span>(month !=<span class="st"> </span><span class="dv">3</span> &amp;<span class="st"> </span>month !=<span class="st"> </span><span class="dv">4</span>),]})

   
Jam &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>:<span class="dv">9</span>)   <span class="co"># locations w/in list of winterBirds captured in Jamaica</span>
Fla &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">10</span>:<span class="dv">12</span>) <span class="co"># locations w/in list of winterBirds in Florida</span>
PR &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">13</span>:<span class="dv">16</span>)  <span class="co"># locations w/in list of winterBirds in Puerto Rico</span>

<span class="co"># Turn the locations into shapefiles #</span>

NB_GL &lt;-<span class="st"> </span><span class="kw">lapply</span>(Non_breeding_files, 
                <span class="dt">FUN =</span> function(x){
                  sp::<span class="kw">SpatialPoints</span>(<span class="kw">cbind</span>(x$Longitude,x$Latitude),
                                    sp::<span class="kw">CRS</span>(WGS84))})

<span class="co"># Project into UTM projection #</span>

NB_GLmeters &lt;-<span class="st"> </span><span class="kw">lapply</span>(NB_GL,
                      <span class="dt">FUN =</span> function(x){sp::<span class="kw">spTransform</span>(x,
                                                        sp::<span class="kw">CRS</span>(Lambert))})

<span class="co"># Process to determine geolocator bias and variance-covariance in meters #</span>

<span class="co"># generate empty vector to store data #</span>
LongError&lt;-<span class="kw">rep</span>(<span class="ot">NA</span>,<span class="kw">length</span>(winterBirds)) 
LatError&lt;-<span class="kw">rep</span>(<span class="ot">NA</span>,<span class="kw">length</span>(winterBirds))  

<span class="co"># Calculate the error in longitude derived </span>
<span class="co"># from geolocators from the true capture location </span>

LongError[Jam] &lt;-<span class="st"> </span><span class="kw">unlist</span>(<span class="kw">lapply</span>(NB_GLmeters[Jam],
                         <span class="dt">FUN =</span> function(x){<span class="kw">mean</span>(x@coords[,<span class="dv">1</span>]-
<span class="st">                                                  </span>CapLocsM@coords[<span class="dv">1</span>,<span class="dv">1</span>])}))

LongError[Fla] &lt;-<span class="st"> </span><span class="kw">unlist</span>(<span class="kw">lapply</span>(NB_GLmeters[Fla],
                         <span class="dt">FUN =</span> function(x){<span class="kw">mean</span>(x@coords[,<span class="dv">1</span>]-
<span class="st">                                                  </span>CapLocsM@coords[<span class="dv">2</span>,<span class="dv">1</span>])}))

LongError[PR] &lt;-<span class="st"> </span><span class="kw">unlist</span>(<span class="kw">lapply</span>(NB_GLmeters[PR],
                        <span class="dt">FUN =</span> function(x){<span class="kw">mean</span>(x@coords[,<span class="dv">1</span>]-
<span class="st">                                                 </span>CapLocsM@coords[<span class="dv">3</span>,<span class="dv">1</span>])}))

<span class="co"># Calculate the error in latitude derived from</span>
<span class="co"># geolocators from the true capture location </span>

LatError[Jam] &lt;-<span class="st"> </span><span class="kw">unlist</span>(<span class="kw">lapply</span>(NB_GLmeters[Jam],
                        <span class="dt">FUN =</span> function(x){<span class="kw">mean</span>(x@coords[,<span class="dv">2</span>]-
<span class="st">                                                 </span>CapLocsM@coords[<span class="dv">1</span>,<span class="dv">2</span>])}))

LatError[Fla] &lt;-<span class="st"> </span><span class="kw">unlist</span>(<span class="kw">lapply</span>(NB_GLmeters[Fla],
                        <span class="dt">FUN =</span> function(x){<span class="kw">mean</span>(x@coords[,<span class="dv">2</span>]-
<span class="st">                                                 </span>CapLocsM@coords[<span class="dv">2</span>,<span class="dv">2</span>])}))

LatError[PR] &lt;-<span class="st"> </span><span class="kw">unlist</span>(<span class="kw">lapply</span>(NB_GLmeters[PR],
                        <span class="dt">FUN =</span> function(x){<span class="kw">mean</span>(x@coords[,<span class="dv">2</span>]-
<span class="st">                                                 </span>CapLocsM@coords[<span class="dv">3</span>,<span class="dv">2</span>])}))

<span class="co"># Get co-variance matrix for error of </span>
<span class="co"># known non-breeding deployment sites </span>

<span class="co"># lm does multivariate normal models if you give it a matrix dependent variable!</span>

geo.error.model &lt;-<span class="st"> </span><span class="kw">lm</span>(<span class="kw">cbind</span>(LongError,LatError) ~<span class="st"> </span><span class="dv">1</span>) 

geo.bias &lt;-<span class="st"> </span><span class="kw">coef</span>(geo.error.model)
geo.vcov &lt;-<span class="st"> </span><span class="kw">vcov</span>(geo.error.model)</code></pre>
<p>We measured MC for bootstrapped data of birds tracked from breeding to non-breeding regions using light-level and GPS geolocation when 1) GPS location uncertainty was applied to all individuals, 2) GPS and light-level location uncertainty were applied to individuals with those devices, and 3) light-level location uncertainty was applied to all individuals.</p>
<p>Load location data that accompanies the <code>MigConnectivity</code> package. The location data are data from breeding Ovenbirds that were fit with Light-level geolocators or PinPoint-10 GPS tags.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(OVENdata) <span class="co"># Ovenbird </span>

<span class="kw">names</span>(OVENdata)
<span class="co">#&gt;  [1] &quot;geo.bias&quot;       &quot;geo.vcov&quot;       &quot;isGL&quot;           &quot;targetPoints&quot;  </span>
<span class="co">#&gt;  [5] &quot;originPoints&quot;   &quot;targetSites&quot;    &quot;originSites&quot;    &quot;originRelAbund&quot;</span>
<span class="co">#&gt;  [9] &quot;originDist&quot;     &quot;targetDist&quot;</span></code></pre>
<p>The figure below shows the two breeding regions (squares), and the three non-breeding regions (gray scale) used in Cohen et al. (<em>in press</em>) to estimate MC for Ovenbirds tracked with light-level geolocators and PinPoint-10 GPS tags.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">install.packages</span>(<span class="kw">c</span>(<span class="st">'rgeos'</span>, <span class="st">'shape'</span>, <span class="st">'raster'</span>, <span class="st">'maptools'</span>, <span class="st">'rgdal'</span>))</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(rgeos)
<span class="kw">library</span>(shape)
<span class="kw">library</span>(raster)
<span class="kw">library</span>(maptools)
<span class="kw">library</span>(rgdal)

<span class="kw">data</span>(wrld_simpl)

raster::<span class="kw">crs</span>(wrld_simpl)
<span class="co">#&gt; CRS arguments:</span>
<span class="co">#&gt;  +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0</span>

<span class="kw">par</span>(<span class="dt">mar=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>))
<span class="kw">plot</span>(OVENdata$originSites,
     <span class="dt">xlim=</span><span class="kw">c</span>(raster::<span class="kw">extent</span>(OVENdata$targetSites)[<span class="dv">1</span>],
            raster::<span class="kw">extent</span>(OVENdata$targetSites)[<span class="dv">2</span>]),
     
     <span class="dt">ylim=</span><span class="kw">c</span>(raster::<span class="kw">extent</span>(OVENdata$targetSites)[<span class="dv">3</span>],
            raster::<span class="kw">extent</span>(OVENdata$originSites)[<span class="dv">4</span>]))

<span class="kw">plot</span>(OVENdata$targetSites,
     <span class="dt">add =</span> <span class="ot">TRUE</span>,
     <span class="dt">col=</span><span class="kw">c</span>(<span class="st">&quot;gray70&quot;</span>,<span class="st">&quot;gray35&quot;</span>,<span class="st">&quot;gray10&quot;</span>))

wrld_simple&lt;-sp::<span class="kw">spTransform</span>(wrld_simpl,raster::<span class="kw">crs</span>(OVENdata$targetSites))

<span class="kw">plot</span>(wrld_simple,<span class="dt">add=</span><span class="ot">TRUE</span>)</code></pre>
<p><img src="data:image/png;base64,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" /></p>
<p>The following code demonstrates how to estimate MC using location data from light-level geolocators and PinPoint-10 GPS tags.</p>
<pre class="sourceCode r"><code class="sourceCode r">M&lt;-<span class="kw">estMC</span>(<span class="dt">isGL=</span>OVENdata$isGL, <span class="co"># Logical vector: light-level geolocator(T)/GPS(F)</span>
         <span class="dt">geoBias =</span> OVENdata$geo.bias, <span class="co"># Light-level geolocator location bias</span>
         <span class="dt">geoVCov =</span> OVENdata$geo.vcov, <span class="co">#Light-level geolocator covariance matrix</span>
         <span class="dt">targetDist =</span> OVENdata$targetDist, <span class="co"># Target location distance matrix</span>
         <span class="dt">originDist =</span> OVENdata$originDist, <span class="co"># Origin location distance matrix</span>
         <span class="dt">targetSites =</span> OVENdata$targetSites, <span class="co"># Non-breeding / target sites</span>
         <span class="dt">originSites =</span> OVENdata$originSites, <span class="co"># Breeding / origin sites </span>
         <span class="dt">originPoints =</span> OVENdata$originPoints, <span class="co"># Capture Locations </span>
         <span class="dt">targetPoints =</span> OVENdata$targetPoints, <span class="co"># Target locations from devices</span>
         <span class="dt">originRelAbund =</span> OVENdata$originRelAbund, <span class="co"># Origin relative abundances</span>
         <span class="dt">resampleProjection =</span> raster::<span class="kw">projection</span>(OVENdata$targetPoints),<span class="co">#Lambert </span>
         <span class="dt">verbose =</span> <span class="dv">0</span>,   <span class="co"># output options - see help ??estMC</span>
         <span class="dt">nSim =</span> <span class="dv">10</span>,     <span class="co"># This is set low for example</span>
         <span class="dt">nSamples =</span> <span class="dv">10</span>) <span class="co"># This is set low for example </span></code></pre>
<p><img src="data:image/png;base64,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" /></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(M)
<span class="co">#&gt; List of 20</span>
<span class="co">#&gt;  $ sampleMC       : num [1:10] 0.774 0.731 0.433 0.584 0.51 ...</span>
<span class="co">#&gt;  $ samplePsi      : num [1:10, 1:2, 1:3] 0 0 0 0 0 0 0 0 0 0 ...</span>
<span class="co">#&gt;   ..- attr(*, &quot;dimnames&quot;)=List of 3</span>
<span class="co">#&gt;   .. ..$ : chr [1:10] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...</span>
<span class="co">#&gt;   .. ..$ : chr [1:2] &quot;NH&quot; &quot;MD&quot;</span>
<span class="co">#&gt;   .. ..$ : chr [1:3] &quot;Florida&quot; &quot;Cuba&quot; &quot;Hisp&quot;</span>
<span class="co">#&gt;  $ pointPsi       : num [1:2, 1:3] 0 0.4 0.174 0.6 0.826 ...</span>
<span class="co">#&gt;   ..- attr(*, &quot;dimnames&quot;)=List of 2</span>
<span class="co">#&gt;   .. ..$ : chr [1:2] &quot;NH&quot; &quot;MD&quot;</span>
<span class="co">#&gt;   .. ..$ : chr [1:3] &quot;Florida&quot; &quot;Cuba&quot; &quot;Hisp&quot;</span>
<span class="co">#&gt;  $ pointMC        : num 0.621</span>
<span class="co">#&gt;  $ meanMC         : num 0.573</span>
<span class="co">#&gt;  $ medianMC       : num 0.573</span>
<span class="co">#&gt;  $ seMC           : num 0.11</span>
<span class="co">#&gt;  $ simpleCI       : Named num [1:2] 0.433 0.774</span>
<span class="co">#&gt;   ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;2.5%&quot; &quot;97.5%&quot;</span>
<span class="co">#&gt;  $ bcCI           : Named num [1:2] 0.433 0.774</span>
<span class="co">#&gt;   ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;2.5%&quot; &quot;97.5%&quot;</span>
<span class="co">#&gt;  $ hpdCI          : num [1, 1:2] 0.433 0.774</span>
<span class="co">#&gt;   ..- attr(*, &quot;dimnames&quot;)=List of 2</span>
<span class="co">#&gt;   .. ..$ : chr &quot;var1&quot;</span>
<span class="co">#&gt;   .. ..$ : chr [1:2] &quot;lower&quot; &quot;upper&quot;</span>
<span class="co">#&gt;   ..- attr(*, &quot;Probability&quot;)= num 0.9</span>
<span class="co">#&gt;  $ simpleP        : NULL</span>
<span class="co">#&gt;  $ bcP            : NULL</span>
<span class="co">#&gt;  $ sampleCorr     : logi [1:10] NA NA NA NA NA NA ...</span>
<span class="co">#&gt;  $ pointCorr      : NULL</span>
<span class="co">#&gt;  $ meanCorr       : NULL</span>
<span class="co">#&gt;  $ medianCorr     : NULL</span>
<span class="co">#&gt;  $ seCorr         : NULL</span>
<span class="co">#&gt;  $ simpleCICorr   : NULL</span>
<span class="co">#&gt;  $ bcCICorr       : NULL</span>
<span class="co">#&gt;  $ inputSampleSize: int 39</span></code></pre>
</div>
<div id="example-3" class="section level3">
<h3>EXAMPLE 3</h3>
</div>
<div id="simmove-simulates-position-of-animals-by-individual-season-year-and-month" class="section level3">
<h3><code>simMove</code> Simulates position of animals by individual, season, year, and month</h3>
<p>Calculate the strength of migratory connectivity based on simulation data for 10 years of movement between breeding and non-breeding seasonal ranges. Breeding and non-breeding ranges are equally divided into 100 regions on an ellipsoid globe. See above for details regarding the utility functions.</p>
<p>Simulate data to demonstrate the use of <code>calcMC</code></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">75</span>)

<span class="co"># Parameters for simulations</span>

nSeasons &lt;-<span class="st"> </span><span class="dv">2</span> <span class="co"># population with two discrete seasons - breeding / non-breeding</span>
nYears &lt;-<span class="st"> </span><span class="dv">10</span> <span class="co"># Ten years of data</span>
nMonths &lt;-<span class="st"> </span><span class="dv">4</span> <span class="co"># Four months within each season</span>

nBreeding &lt;-<span class="st"> </span><span class="dv">100</span> <span class="co"># Number of populations</span>
nWintering &lt;-<span class="st"> </span><span class="dv">100</span> <span class="co"># Number of populations </span></code></pre>
<p>Generate the spatial arrangement of breeding and non-breeding populations</p>
<pre class="sourceCode r"><code class="sourceCode r">breedingPos &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="kw">rep</span>(<span class="kw">seq</span>(-<span class="dv">99</span>,-<span class="dv">81</span>,<span class="dv">2</span>), <span class="dt">each=</span><span class="kw">sqrt</span>(nBreeding)),
                        <span class="kw">rep</span>(<span class="kw">seq</span>(<span class="dv">49</span>,<span class="dv">31</span>,-<span class="dv">2</span>), <span class="kw">sqrt</span>(nBreeding))), nBreeding, <span class="dv">2</span>)
winteringPos &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="kw">rep</span>(<span class="kw">seq</span>(-<span class="dv">79</span>,-<span class="dv">61</span>,<span class="dv">2</span>), <span class="dt">each=</span><span class="kw">sqrt</span>(nWintering)),
                         <span class="kw">rep</span>(<span class="kw">seq</span>(<span class="dv">9</span>,-<span class="dv">9</span>,-<span class="dv">2</span>), <span class="kw">sqrt</span>(nWintering))), nWintering, <span class="dv">2</span>)

<span class="co"># calculate distance between populations</span>
breedDist &lt;-<span class="st"> </span><span class="kw">distFromPos</span>(breedingPos, <span class="st">'ellipsoid'</span>) 

nonbreedDist &lt;-<span class="st"> </span><span class="kw">distFromPos</span>(winteringPos, <span class="st">'ellipsoid'</span>) </code></pre>
<p>The relative abundance of the study species is needed in each population. Here we generate those data below.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Breeding Abundance</span>
breedingN &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">500</span>, nBreeding)
breedingRelN &lt;-<span class="st"> </span>breedingN/<span class="kw">sum</span>(breedingN)</code></pre>
<p>The transition probability (psi) between the breeding and non-breeding populations is calculated below.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Set up psi matrix</span>
o &lt;-<span class="st"> </span><span class="kw">optimize</span>(mlogitMC, <span class="dt">MC.in =</span> <span class="fl">0.25</span>, <span class="dt">origin.dist =</span> breedDist,
              <span class="dt">target.dist =</span> nonbreedDist, <span class="dt">origin.abund =</span> breedingRelN,
              <span class="dt">sample.size =</span> <span class="kw">sum</span>(breedingN),
              <span class="dt">interval =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">10</span>), <span class="dt">tol =</span> .Machine$double.eps^<span class="fl">0.5</span>)

slope &lt;-<span class="st"> </span>o$minimum

psi &lt;-<span class="st"> </span><span class="kw">mlogitMat</span>(slope, breedDist)</code></pre>
<p>Now that we have all the data needed to calculate the strength of migratory connectivity we can use the <code>calcMC</code> function in the <code>MigConnecitivty</code> package to generate a standardized MC metric.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Baseline strength of migratory connectivity</span>
MC &lt;-<span class="st"> </span><span class="kw">calcMC</span>(<span class="dt">originDist =</span> breedDist, 
             <span class="dt">targetDist =</span> nonbreedDist,
             <span class="dt">psi =</span> psi, 
             <span class="dt">originRelAbund =</span> breedingRelN,
             <span class="dt">sampleSize =</span> <span class="kw">sum</span>(breedingN))

<span class="co"># Show Results</span>
MC
<span class="co">#&gt; [1] 0.25</span></code></pre>
</div>
<div id="simmove-simulation-of-movement-between-breeding-and-non-breeding" class="section level3">
<h3><code>simMove</code> Simulation of movement between breeding and non-breeding</h3>
<p>Recycle data generated for the calcMC function - see above</p>
<pre class="sourceCode r"><code class="sourceCode r">sims &lt;-<span class="st"> </span><span class="kw">simMove</span>(<span class="dt">breedingAbund =</span> breedingN, <span class="co"># Breeding relative abundance</span>
               <span class="dt">breedingDist =</span> breedDist,  <span class="co"># Breeding distance</span>
               <span class="dt">winteringDist =</span> nonbreedDist, <span class="co"># Non-breeding distance</span>
               <span class="dt">psi =</span> psi, <span class="co"># Transition probabilities</span>
               <span class="dt">nYears =</span> nYears, <span class="co"># Number of years</span>
               <span class="dt">nMonths =</span> nMonths, <span class="co"># Number of months</span>
               <span class="dt">winMoveRate =</span> <span class="dv">0</span>, <span class="co"># winter movement rate</span>
               <span class="dt">sumMoveRate =</span> <span class="dv">0</span>, <span class="co"># breeding movement rate</span>
               <span class="dt">winDispRate =</span> <span class="dv">0</span>, <span class="co"># winter dispersal rate</span>
               <span class="dt">sumDispRate =</span> <span class="dv">0</span>, <span class="co"># summer disperal rate</span>
               <span class="dt">natalDispRate =</span> <span class="dv">0</span>, <span class="co"># natal dispersal rate</span>
               <span class="dt">breedDispRate =</span> <span class="dv">0</span>, <span class="co"># breeding dispersal rate</span>
               <span class="dt">verbose =</span> <span class="dv">0</span>) <span class="co"># verbose output</span>


<span class="kw">str</span>(sims)
<span class="co">#&gt; List of 6</span>
<span class="co">#&gt;  $ animalLoc   : int [1:50000, 1:2, 1:10, 1:4] 1 1 1 1 1 1 1 1 1 1 ...</span>
<span class="co">#&gt;  $ natalDispMat: NULL</span>
<span class="co">#&gt;  $ breedDispMat: NULL</span>
<span class="co">#&gt;  $ sumMoveMat  : NULL</span>
<span class="co">#&gt;  $ winDispMat  : NULL</span>
<span class="co">#&gt;  $ winMoveMat  : NULL</span></code></pre>
</div>
</div>
<div id="additional-examples-scenarios" class="section level2">
<h2>Additional Examples / Scenarios</h2>
<div id="example-4" class="section level3">
<h3>EXAMPLE 4</h3>
<p>Calculate migratory connectivity for a range of input values</p>
<p>Cohen et al. (<em>in press</em>) used simulation to assess the influence of the three data inputs needed to calculate MC, including:</p>
<ol style="list-style-type: decimal">
<li>matrix of transition probabilities from breeding regions to non-breeding regions<br /></li>
<li>matrices of distances between breeding regions and between non-breeding regions<br /></li>
<li>relative abundance among breeding regions.</li>
</ol>
<p>Input value simulations included transition probabilities from four breeding to four non-breeding regions and relative abundance measured among breeding regions.</p>
<p>There were eight transition probability scenarios:</p>
<ol style="list-style-type: decimal">
<li>Full Mix</li>
<li>Avoid One Site</li>
<li>Full Connectivity</li>
<li>Half Mix</li>
<li>Low</li>
<li>Medium</li>
<li>One Site Preference</li>
<li>Negative</li>
</ol>
<p>There were twelve spatial arrangement / distance scenarios:</p>
<ol style="list-style-type: decimal">
<li>Base distances, linear/ linear</li>
<li>Distance between breeding sites 2 and 3 doubled<br /></li>
<li>Distance between breeding sites 2 and 3 halved<br /></li>
<li>Distance between breeding sites 3 and 4 doubled<br /></li>
<li>Distance between breeding sites 3 and 4 halved<br /></li>
<li>Breeding sites on square grid/ winter linear</li>
<li>Distance between wintering sites 2 and 3 doubled<br /></li>
<li>Distance between wintering sites 2 and 3 halved<br /></li>
<li>Distance between wintering sites 3 and 4 doubled<br /></li>
<li>Distance between wintering sites 3 and 4 halved<br /></li>
<li>Breeding linear, Wintering sites on square grid<br /></li>
<li>Wintering and breeding on square grid</li>
</ol>
<p>There were five relative breeding abundance scenarios:</p>
<ol style="list-style-type: decimal">
<li>Base, all equal<br /></li>
<li>Abundance at site B doubled<br /></li>
<li>Abundance at site B halved<br /></li>
<li>Abundance at site D doubled<br /></li>
<li>Abundance at site D halved</li>
</ol>
<p>First we calculate MC for the eight transition probability scenarios (with base spatial arrangement and relative abundance):</p>
<pre class="sourceCode r"><code class="sourceCode r">nScenarios1 &lt;-<span class="st"> </span><span class="kw">length</span>(samplePsis) <span class="co"># samplePsis - comes with MigConnectivity pacakge</span>

<span class="co"># Create vector of length nScenarios1</span>
MC1 &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, nScenarios1)

<span class="co"># Loop through the different senarios outlined above #</span>
for (i in <span class="dv">1</span>:nScenarios1) {
  MC1[i] &lt;-<span class="st"> </span><span class="kw">calcMC</span>(<span class="dt">originDist =</span> sampleOriginDist[[<span class="dv">1</span>]],
                 <span class="dt">targetDist =</span> sampleTargetDist[[<span class="dv">1</span>]],
                 <span class="dt">psi =</span> samplePsis[[i]],
                 <span class="dt">originRelAbund =</span> sampleOriginRelN[[<span class="dv">1</span>]])
}

<span class="co"># Give meaningful names to the MC1 vector</span>
<span class="kw">names</span>(MC1) &lt;-<span class="st"> </span><span class="kw">names</span>(samplePsis)

<span class="co"># Print results </span>
<span class="kw">round</span>(MC1, <span class="dv">6</span>)
<span class="co">#&gt;            Full Mix      Avoid One Site   Full Connectivity </span>
<span class="co">#&gt;            0.000000            0.000000            1.000000 </span>
<span class="co">#&gt;            Half Mix                 Low              Medium </span>
<span class="co">#&gt;            0.600000            0.196000            0.504000 </span>
<span class="co">#&gt; One Site Preference            Negative </span>
<span class="co">#&gt;            0.164145           -0.066560</span></code></pre>
<p>Add the scenarios for the spatial arrangements that result in different distances between regions:</p>
<pre class="sourceCode r"><code class="sourceCode r">nScenarios2 &lt;-<span class="st"> </span><span class="kw">length</span>(sampleOriginPos)

MC2 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, nScenarios1, nScenarios2)

<span class="kw">rownames</span>(MC2) &lt;-<span class="st"> </span><span class="kw">names</span>(samplePsis)

<span class="kw">colnames</span>(MC2) &lt;-<span class="st"> </span><span class="kw">names</span>(sampleOriginPos)

for (i in <span class="dv">1</span>:nScenarios1) {
  for (j in <span class="dv">1</span>:nScenarios2) {
    MC2[i, j] &lt;-<span class="st"> </span><span class="kw">calcMC</span>(<span class="dt">originDist =</span> sampleOriginDist[[j]],
                      <span class="dt">targetDist =</span> sampleTargetDist[[j]],
                      <span class="dt">psi =</span> samplePsis[[i]],
                      <span class="dt">originRelAbund =</span> sampleOriginRelN[[<span class="dv">1</span>]])
  }
}

<span class="co"># Print results #</span>
<span class="kw">t</span>(<span class="kw">round</span>(MC2, <span class="dv">4</span>))
<span class="co">#&gt;              Full Mix Avoid One Site Full Connectivity Half Mix    Low</span>
<span class="co">#&gt; Linear              0              0            1.0000   0.6000 0.1960</span>
<span class="co">#&gt; B Dist BC*2         0              0            0.9739   0.6956 0.1818</span>
<span class="co">#&gt; B Dist BC/2         0              0            0.9798   0.4899 0.2000</span>
<span class="co">#&gt; B Dist CD*2         0              0            0.9558   0.5147 0.1912</span>
<span class="co">#&gt; B Dist CD/2         0              0            0.9734   0.6299 0.1878</span>
<span class="co">#&gt; B Grid              0              0            0.7734   0.5256 0.1277</span>
<span class="co">#&gt; NB Dist 23*2        0              0            0.9739   0.6956 0.1818</span>
<span class="co">#&gt; NB Dist 23/2        0              0            0.9798   0.4899 0.2000</span>
<span class="co">#&gt; NB Dist 34*2        0              0            0.9558   0.5147 0.1931</span>
<span class="co">#&gt; NB Dist 34/2        0              0            0.9734   0.6299 0.1863</span>
<span class="co">#&gt; NB Grid             0              0            0.7734   0.5256 0.1277</span>
<span class="co">#&gt; B/NB Grid           0              0            1.0000   0.4605 0.1638</span>
<span class="co">#&gt;              Medium One Site Preference Negative</span>
<span class="co">#&gt; Linear       0.5040              0.1641  -0.0666</span>
<span class="co">#&gt; B Dist BC*2  0.4879              0.1514  -0.0463</span>
<span class="co">#&gt; B Dist BC/2  0.4964              0.1683  -0.0815</span>
<span class="co">#&gt; B Dist CD*2  0.4784              0.1838  -0.0734</span>
<span class="co">#&gt; B Dist CD/2  0.4932              0.1388  -0.0572</span>
<span class="co">#&gt; B Grid       0.3601              0.1695   0.0669</span>
<span class="co">#&gt; NB Dist 23*2 0.4879              0.1428  -0.0463</span>
<span class="co">#&gt; NB Dist 23/2 0.4964              0.1781  -0.0815</span>
<span class="co">#&gt; NB Dist 34*2 0.4882              0.2163  -0.0734</span>
<span class="co">#&gt; NB Dist 34/2 0.4856              0.1149  -0.0572</span>
<span class="co">#&gt; NB Grid      0.3601              0.1263   0.0669</span>
<span class="co">#&gt; B/NB Grid    0.4340              0.1603   0.0728</span></code></pre>
<p>Another way of comparing results:</p>
<pre class="sourceCode r"><code class="sourceCode r">
MC.diff2 &lt;-<span class="st"> </span><span class="kw">apply</span>(MC2, <span class="dv">2</span>, <span class="st">&quot;-&quot;</span>, MC2[ , <span class="dv">1</span>])

<span class="kw">t</span>(<span class="kw">round</span>(MC.diff2, <span class="dv">4</span>))
<span class="co">#&gt;              Full Mix Avoid One Site Full Connectivity Half Mix     Low</span>
<span class="co">#&gt; Linear              0              0            0.0000   0.0000  0.0000</span>
<span class="co">#&gt; B Dist BC*2         0              0           -0.0261   0.0956 -0.0142</span>
<span class="co">#&gt; B Dist BC/2         0              0           -0.0202  -0.1101  0.0040</span>
<span class="co">#&gt; B Dist CD*2         0              0           -0.0442  -0.0853 -0.0048</span>
<span class="co">#&gt; B Dist CD/2         0              0           -0.0266   0.0299 -0.0082</span>
<span class="co">#&gt; B Grid              0              0           -0.2266  -0.0744 -0.0683</span>
<span class="co">#&gt; NB Dist 23*2        0              0           -0.0261   0.0956 -0.0142</span>
<span class="co">#&gt; NB Dist 23/2        0              0           -0.0202  -0.1101  0.0040</span>
<span class="co">#&gt; NB Dist 34*2        0              0           -0.0442  -0.0853 -0.0029</span>
<span class="co">#&gt; NB Dist 34/2        0              0           -0.0266   0.0299 -0.0097</span>
<span class="co">#&gt; NB Grid             0              0           -0.2266  -0.0744 -0.0683</span>
<span class="co">#&gt; B/NB Grid           0              0            0.0000  -0.1395 -0.0322</span>
<span class="co">#&gt;               Medium One Site Preference Negative</span>
<span class="co">#&gt; Linear        0.0000              0.0000   0.0000</span>
<span class="co">#&gt; B Dist BC*2  -0.0161             -0.0128   0.0203</span>
<span class="co">#&gt; B Dist BC/2  -0.0076              0.0042  -0.0150</span>
<span class="co">#&gt; B Dist CD*2  -0.0256              0.0197  -0.0068</span>
<span class="co">#&gt; B Dist CD/2  -0.0108             -0.0253   0.0094</span>
<span class="co">#&gt; B Grid       -0.1439              0.0054   0.1334</span>
<span class="co">#&gt; NB Dist 23*2 -0.0161             -0.0213   0.0203</span>
<span class="co">#&gt; NB Dist 23/2 -0.0076              0.0139  -0.0150</span>
<span class="co">#&gt; NB Dist 34*2 -0.0158              0.0521  -0.0068</span>
<span class="co">#&gt; NB Dist 34/2 -0.0184             -0.0493   0.0094</span>
<span class="co">#&gt; NB Grid      -0.1439             -0.0378   0.1334</span>
<span class="co">#&gt; B/NB Grid    -0.0700             -0.0038   0.1394</span></code></pre>
</div>
<div id="add-the-relative-abundance-breeding-scenarios" class="section level3">
<h3>Add the relative abundance breeding scenarios</h3>
<p>Calculate MC across abundance and transition probability scenarios for breeding linear / winter linear arrangment:</p>
<pre class="sourceCode r"><code class="sourceCode r">nScenarios3 &lt;-<span class="st"> </span><span class="kw">length</span>(sampleOriginRelN)

MC3 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, nScenarios1, nScenarios3)

<span class="kw">rownames</span>(MC3) &lt;-<span class="st"> </span><span class="kw">names</span>(samplePsis)
<span class="kw">colnames</span>(MC3) &lt;-<span class="st"> </span><span class="kw">names</span>(sampleOriginRelN)

for (i in <span class="dv">1</span>:nScenarios1) {
for (j in <span class="dv">1</span>) {
for (k in <span class="dv">1</span>:nScenarios3) {
MC3[i, k] &lt;-<span class="st"> </span><span class="kw">calcMC</span>(<span class="dt">originDist =</span> sampleOriginDist[[j]],
                    <span class="dt">targetDist =</span> sampleTargetDist[[j]], 
                    <span class="dt">psi =</span> samplePsis[[i]],
                    <span class="dt">originRelAbund =</span> sampleOriginRelN[[k]])
}
}
}

<span class="kw">t</span>(<span class="kw">round</span>(MC3, <span class="dv">4</span>)) <span class="co"># linear arrangement</span>
<span class="co">#&gt;        Full Mix Avoid One Site Full Connectivity Half Mix    Low Medium</span>
<span class="co">#&gt; Base          0              0                 1   0.6000 0.1960 0.5040</span>
<span class="co">#&gt; B Doub        0              0                 1   0.5856 0.2060 0.5173</span>
<span class="co">#&gt; B Half        0              0                 1   0.6323 0.1942 0.5027</span>
<span class="co">#&gt; D Doub        0              0                 1   0.6360 0.1663 0.4608</span>
<span class="co">#&gt; D Half        0              0                 1   0.5807 0.2062 0.5235</span>
<span class="co">#&gt;        One Site Preference Negative</span>
<span class="co">#&gt; Base                0.1641  -0.0666</span>
<span class="co">#&gt; B Doub              0.1338  -0.0650</span>
<span class="co">#&gt; B Half              0.1847  -0.0660</span>
<span class="co">#&gt; D Doub              0.2992  -0.0219</span>
<span class="co">#&gt; D Half              0.0886  -0.0399</span></code></pre>
<p>Calculate MC across abundance and transition probability scenarios for breeding grid/ winter grid arrangement:</p>
<pre class="sourceCode r"><code class="sourceCode r">MC4 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, nScenarios1, nScenarios3)

<span class="kw">rownames</span>(MC4) &lt;-<span class="st"> </span><span class="kw">names</span>(samplePsis)
<span class="kw">colnames</span>(MC4) &lt;-<span class="st"> </span><span class="kw">names</span>(sampleOriginRelN)

for (i in <span class="dv">1</span>:nScenarios1) {
for (j in nScenarios2) {
for (k in <span class="dv">1</span>:nScenarios3) {
MC4[i, k] &lt;-<span class="st"> </span><span class="kw">calcMC</span>(<span class="dt">originDist =</span> sampleOriginDist[[j]],
                    <span class="dt">targetDist =</span> sampleTargetDist[[j]],
                    <span class="dt">psi =</span> samplePsis[[i]],
                    <span class="dt">originRelAbund =</span> sampleOriginRelN[[k]])
}
}
}

<span class="kw">t</span>(<span class="kw">round</span>(MC4, <span class="dv">4</span>)) <span class="co"># grid arrangement</span>
<span class="co">#&gt;        Full Mix Avoid One Site Full Connectivity Half Mix    Low Medium</span>
<span class="co">#&gt; Base          0              0                 1   0.4605 0.1638 0.4340</span>
<span class="co">#&gt; B Doub        0              0                 1   0.4668 0.1614 0.4293</span>
<span class="co">#&gt; B Half        0              0                 1   0.4639 0.1699 0.4445</span>
<span class="co">#&gt; D Doub        0              0                 1   0.4668 0.1614 0.4293</span>
<span class="co">#&gt; D Half        0              0                 1   0.4639 0.1699 0.4445</span>
<span class="co">#&gt;        One Site Preference Negative</span>
<span class="co">#&gt; Base                0.1603   0.0728</span>
<span class="co">#&gt; B Doub              0.0970   0.0822</span>
<span class="co">#&gt; B Half              0.1996   0.0778</span>
<span class="co">#&gt; D Doub              0.3649   0.0822</span>
<span class="co">#&gt; D Half              0.0519   0.0778</span></code></pre>
<p>Calculate MC across abundance and transition probability scenarios for for breeding grid, winter linear arrangement</p>
<pre class="sourceCode r"><code class="sourceCode r">MC5 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, nScenarios1, nScenarios3)

<span class="kw">rownames</span>(MC5) &lt;-<span class="st"> </span><span class="kw">names</span>(samplePsis)
<span class="kw">colnames</span>(MC5) &lt;-<span class="st"> </span><span class="kw">names</span>(sampleOriginRelN)

for (i in <span class="dv">1</span>:nScenarios1) {
for (j in <span class="dv">6</span>) {
for (k in <span class="dv">1</span>:nScenarios3) {
MC5[i, k] &lt;-<span class="st"> </span><span class="kw">calcMC</span>(<span class="dt">originDist =</span> sampleOriginDist[[j]],
                    <span class="dt">targetDist =</span> sampleTargetDist[[j]], 
                    <span class="dt">psi =</span> samplePsis[[i]], 
                    <span class="dt">originRelAbund =</span> sampleOriginRelN[[k]])
}
}
}

<span class="kw">t</span>(<span class="kw">round</span>(MC5, <span class="dv">4</span>)) <span class="co"># breeding grid, winter linear arrangement</span>
<span class="co">#&gt;        Full Mix Avoid One Site Full Connectivity Half Mix    Low Medium</span>
<span class="co">#&gt; Base          0              0            0.7734   0.5256 0.1277 0.3601</span>
<span class="co">#&gt; B Doub        0              0            0.7538   0.5384 0.1380 0.3677</span>
<span class="co">#&gt; B Half        0              0            0.8229   0.5323 0.1385 0.3861</span>
<span class="co">#&gt; D Doub        0              0            0.8290   0.5384 0.1096 0.3456</span>
<span class="co">#&gt; D Half        0              0            0.7447   0.5323 0.1313 0.3629</span>
<span class="co">#&gt;        One Site Preference Negative</span>
<span class="co">#&gt; Base                0.1695   0.0669</span>
<span class="co">#&gt; B Doub              0.1140   0.0277</span>
<span class="co">#&gt; B Half              0.2102   0.0801</span>
<span class="co">#&gt; D Doub              0.3419   0.1334</span>
<span class="co">#&gt; D Half              0.0737   0.0647</span></code></pre>
</div>
<div id="examples-5-12-from-sampling-regime-simulations-in-cohen-et-al.-in-press" class="section level3">
<h3>EXAMPLES 5-12 (from sampling regime simulations in Cohen et al. in press)</h3>
<p>Simulation was used to assess the influence of biased or incomplete sampling on the measurement of MC. Below, we measure the influence of several potential sources of sampling error:</p>
<ol style="list-style-type: decimal">
<li>Incorrect grouping of seasonal ranges into regions</li>
<li>Sampling not proportional to abundance</li>
<li>Migratory connectivity strength varies across a range</li>
<li>Low sample size</li>
<li>Uncertainty in assignments to regions from tracking data</li>
<li>Uncertainty in estimates of abundance</li>
<li>Heterogeneity in detection among regions from mark re-encounter data</li>
</ol>
<p>We also demonstrate how to propagate sampling uncertainty into measurement of MC using a combination of parametric and non-parametric bootstrapping. For most simulations, we compare MC to the results of a distance-based correlation coefficient (Mantel correlation; rM) that does not incorporate relative abundance but has been used as a measure of migratory connectivity.</p>
</div>
<div id="example-5" class="section level3">
<h3>EXAMPLE 5</h3>
<p>Sampling regime 1 of 3</p>
<p>Researchers divide populations differently than reality Delineation of seasonal ranges into regions</p>
<ol style="list-style-type: upper-roman">
<li>Breeding range divided along equal longitudinal breaks into ten regions</li>
<li>Non-breeding range divided along equal longitudinal breaks into ten regions</li>
<li>Breeding and non-breeding ranges divided along equal longitudinal breaks into ten regions</li>
<li>Breeding range divided along the longitudinal and latitudinal midpoint into four regions</li>
<li>Non-breeding range divided along the longitudinal and latitudinal midpoint into four regions</li>
<li>Breeding range divided along the longitudinal and latitudinal midpoint into four regions and non-breeding range divided along equal longitudinal breaks into ten regions</li>
<li>Breeding range divided along equal longitudinal breaks into ten regions and non-breeding range divided along the longitudinal and latitudinal midpoint into four regions</li>
</ol>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co">#Run functions and parameters above first</span>
<span class="kw">set.seed</span>(<span class="dv">75</span>)

scenarios14 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Base&quot;</span>, 
                 <span class="st">&quot;Breeding10&quot;</span>,
                 <span class="st">&quot;Wintering10&quot;</span>,
                 <span class="st">&quot;Breeding10Wintering10&quot;</span>,
                 <span class="st">&quot;Breeding4&quot;</span>,
                 <span class="st">&quot;Wintering4&quot;</span>,
                 <span class="st">&quot;Breeding4Wintering10&quot;</span>,
                 <span class="st">&quot;Breeding10Wintering4&quot;</span>,
                 <span class="st">&quot;Breeding4Wintering4&quot;</span>,
                 <span class="st">&quot;CentroidSampleBreeding10&quot;</span>,
                 <span class="st">&quot;CentroidSampleBreeding10Wintering10&quot;</span>,
                 <span class="st">&quot;CentroidSampleBreeding10Wintering4&quot;</span>,
                 <span class="st">&quot;CentroidSampleBreeding4&quot;</span>,
                 <span class="st">&quot;CentroidSampleBreeding4Wintering10&quot;</span>,
                 <span class="st">&quot;CentroidSampleBreeding4Wintering4&quot;</span>)

<span class="co"># Each element is for a scenario (see above 1-8), transferring from natural </span>
<span class="co"># breeding populations to defined ones</span>
breedingSiteTrans14 &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span>:nBreeding, 
                           <span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">each=</span><span class="dv">10</span>), 
                           <span class="dv">1</span>:nBreeding, 
                           <span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">each=</span><span class="dv">10</span>), 
                           <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>), <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)),
                           <span class="dv">1</span>:nBreeding, 
                           <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>), <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)),
                           <span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">each=</span><span class="dv">10</span>),
                           <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>), <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)),
                           <span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">each=</span><span class="dv">10</span>), 
                           <span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">each=</span><span class="dv">10</span>), 
                           <span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">each=</span><span class="dv">10</span>),
                           <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>), <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)),
                           <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>), <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)),
                           <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>), <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)))

<span class="co"># Same for non-breeding populations</span>
winteringSiteTrans14 &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span>:nWintering,
                             <span class="dv">1</span>:nWintering,
                             <span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">each=</span><span class="dv">10</span>),
                             <span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">each=</span><span class="dv">10</span>),
                             <span class="dv">1</span>:nWintering,
                             <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>), <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)),
                             <span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">each=</span><span class="dv">10</span>),
                             <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>), <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)),
                             <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>), <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)),
                             <span class="dv">1</span>:nWintering,
                             <span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">each=</span><span class="dv">10</span>),
                             <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>), <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)),
                             <span class="dv">1</span>:nWintering,
                             <span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">each=</span><span class="dv">10</span>),
                             <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>), <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)))

<span class="co"># Examine the transfers in matrix form</span>
<span class="co">#lapply(breedingSiteTrans14, matrix, nrow=10, ncol=10)</span>
<span class="co">#lapply(winteringSiteTrans14, matrix, nrow=10, ncol=10)</span>

<span class="co">#positions of the human defined populations</span>
breedingPos14 &lt;-<span class="st"> </span><span class="kw">list</span>(breedingPos,
                      <span class="kw">rowsum</span>(breedingPos, <span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">each=</span><span class="dv">10</span>))/<span class="dv">10</span>,
                      breedingPos,
                      <span class="kw">rowsum</span>(breedingPos, <span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">each=</span><span class="dv">10</span>))/<span class="dv">10</span>,
                      <span class="kw">rowsum</span>(breedingPos, <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>),
                                            <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)))/<span class="dv">25</span>,
                      breedingPos, 
                      <span class="kw">rowsum</span>(breedingPos, <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>),
                                            <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)))/<span class="dv">25</span>,
                      <span class="kw">rowsum</span>(breedingPos, <span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">each=</span><span class="dv">10</span>))/<span class="dv">10</span>,
                      <span class="kw">rowsum</span>(breedingPos, <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>),
                                            <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)))/<span class="dv">25</span>,
                      <span class="kw">rowsum</span>(breedingPos, <span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">each=</span><span class="dv">10</span>))/<span class="dv">10</span>,
                      <span class="kw">rowsum</span>(breedingPos, <span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">each=</span><span class="dv">10</span>))/<span class="dv">10</span>,
                      <span class="kw">rowsum</span>(breedingPos, <span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">each=</span><span class="dv">10</span>))/<span class="dv">10</span>,
                      <span class="kw">rowsum</span>(breedingPos, <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>),
                                            <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)))/<span class="dv">25</span>,
                      <span class="kw">rowsum</span>(breedingPos, <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>),
                                            <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)))/<span class="dv">25</span>,
                      <span class="kw">rowsum</span>(breedingPos, <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>),
                                            <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)))/<span class="dv">25</span>)

winteringPos14 &lt;-<span class="st"> </span><span class="kw">list</span>(winteringPos,
                       winteringPos,
                       <span class="kw">rowsum</span>(winteringPos, <span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">each=</span><span class="dv">10</span>))/<span class="dv">10</span>,
                       <span class="kw">rowsum</span>(winteringPos, <span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">each=</span><span class="dv">10</span>))/<span class="dv">10</span>,
                       winteringPos, 
                       <span class="kw">rowsum</span>(winteringPos, <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>),
                                              <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)))/<span class="dv">25</span>,
                       <span class="kw">rowsum</span>(winteringPos,<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">each=</span><span class="dv">10</span>))/<span class="dv">10</span>,
                       <span class="kw">rowsum</span>(winteringPos, <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>),
                                              <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)))/<span class="dv">25</span>,
                       <span class="kw">rowsum</span>(winteringPos, <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>),
                                              <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)))/<span class="dv">25</span>,
                       winteringPos,
                       <span class="kw">rowsum</span>(winteringPos, <span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">each=</span><span class="dv">10</span>))/<span class="dv">10</span>,
                       <span class="kw">rowsum</span>(winteringPos, <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>),
                                              <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)))/<span class="dv">25</span>,
                       winteringPos,
                       <span class="kw">rowsum</span>(winteringPos, <span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">each=</span><span class="dv">10</span>))/<span class="dv">10</span>,
                       <span class="kw">rowsum</span>(winteringPos, <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>),
                                              <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)))/<span class="dv">25</span>)


<span class="co"># Calculate distances between defined breeding populations</span>
breedDist14 &lt;-<span class="st"> </span><span class="kw">lapply</span>(breedingPos14, distFromPos, <span class="dt">surface =</span> <span class="st">'ellipsoid'</span>)

<span class="co"># Calculate distances between defined non-breeding populations</span>
nonbreedDist14 &lt;-<span class="st"> </span><span class="kw">lapply</span>(winteringPos14, distFromPos, <span class="dt">surface =</span> <span class="st">'ellipsoid'</span>)

<span class="co"># Numbers of defined populations</span>
nBreeding14 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">100</span>, <span class="dv">10</span>, <span class="dv">100</span>, <span class="dv">10</span>, <span class="dv">4</span>, <span class="dv">100</span>, <span class="dv">4</span>, <span class="dv">10</span>, <span class="dv">4</span>, <span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">4</span>)

nWintering14 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">100</span>, <span class="dv">100</span>, <span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">100</span>, <span class="dv">4</span>, <span class="dv">10</span>, <span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">100</span>, <span class="dv">10</span>, <span class="dv">4</span>, <span class="dv">100</span>, <span class="dv">10</span>, <span class="dv">4</span>)

<span class="co"># Relative abundance by scenario and breeding population</span>
breedingRelN14 &lt;-<span class="st"> </span><span class="kw">lapply</span>(nBreeding14, function(x) <span class="kw">rep</span>(<span class="dv">1</span>/x, x))

MC14 &lt;-<span class="st"> </span><span class="fl">0.25</span> <span class="co"># Same for all scenarios in this set</span>

nSample14 &lt;-<span class="st"> </span><span class="dv">1000</span> <span class="co"># Total number sampled per simulation</span>

<span class="co"># How many sampled from each natural population (sampling scenarios separate </span>
<span class="co"># from definition scenarios)</span>

sampleBreeding14 &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">round</span>(breedingRelN14[[<span class="dv">1</span>]]*nSample14),
                         <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">22</span>), <span class="kw">round</span>(breedingRelN14[[<span class="dv">5</span>]][<span class="dv">1</span>]*nSample14),
                           <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">4</span>), <span class="kw">round</span>(breedingRelN14[[<span class="dv">5</span>]][<span class="dv">2</span>]*nSample14),
                           <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">44</span>), <span class="kw">round</span>(breedingRelN14[[<span class="dv">5</span>]][<span class="dv">3</span>]*nSample14),
                           <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">4</span>), <span class="kw">round</span>(breedingRelN14[[<span class="dv">5</span>]][<span class="dv">4</span>]*nSample14),
                           <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">22</span>)),
                         <span class="kw">rep</span>(<span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">4</span>), 
                             <span class="kw">rep</span>(<span class="kw">round</span>(breedingRelN14[[<span class="dv">2</span>]][<span class="dv">1</span>]*nSample14/<span class="dv">2</span>), <span class="dv">2</span>),
                             <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">4</span>)), <span class="dv">10</span>))

<span class="co"># for the baseline use the simulation from above, sims</span>

animalLoc14base &lt;-<span class="st"> </span>sims$animalLoc


<span class="co"># Number of scenarios and number of simulations to run</span>
nScenarios14 &lt;-<span class="st"> </span><span class="kw">length</span>(breedingSiteTrans14)
nSims14 &lt;-<span class="st"> </span><span class="dv">100</span>

<span class="co"># Connections between scenarios and sampling regimes</span>
scenarioToSampleMap14 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>, <span class="dv">9</span>), <span class="kw">rep</span>(<span class="dv">3</span>, <span class="dv">3</span>), <span class="kw">rep</span>(<span class="dv">2</span>, <span class="dv">3</span>))

<span class="co"># Set up data structures for storing results</span>
animalLoc14 &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, nScenarios14) <span class="co">#making an empty list to fill</span>

compare14 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">Scenario =</span> <span class="kw">c</span>(<span class="st">&quot;True&quot;</span>, scenarios14),
                        <span class="dt">MC =</span> <span class="kw">c</span>(MC14, <span class="kw">rep</span>(<span class="ot">NA</span>, nScenarios14)), 
                        <span class="dt">Mantel =</span> <span class="kw">c</span>(MC14, <span class="kw">rep</span>(<span class="ot">NA</span>, nScenarios14)))

compare14.array &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NA</span>, <span class="kw">c</span>(nSims14, nScenarios14, <span class="dv">2</span>), <span class="dt">dimnames =</span> 
                           <span class="kw">list</span>(<span class="dv">1</span>:nSims14,
                           scenarios14,
                           <span class="kw">c</span>(<span class="st">&quot;MC&quot;</span>, <span class="st">&quot;Mantel&quot;</span>)))

results14 &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, nScenarios14)

<span class="co"># Run simulations</span>
for (sim in <span class="dv">1</span>:nSims14) {
  <span class="kw">cat</span>(<span class="st">&quot;Simulation&quot;</span>, sim, <span class="st">&quot;of&quot;</span>, nSims14, <span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)
  sim14 &lt;-<span class="st"> </span><span class="kw">lapply</span>(sampleBreeding14, 
                  simMove, 
                  <span class="dt">breedingDist =</span> breedDist14[[<span class="dv">1</span>]],
                  <span class="dt">winteringDist=</span>nonbreedDist14[[<span class="dv">1</span>]], 
                  <span class="dt">psi=</span>psi, 
                  <span class="dt">nYears=</span>nYears,
                  <span class="dt">nMonths=</span>nMonths)
  
  for (i in <span class="dv">1</span>:nScenarios14) {
   <span class="kw">cat</span>(<span class="st">&quot;</span><span class="ch">\t</span><span class="st">Scenario&quot;</span>, i, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
   animalLoc14[[i]]&lt;-<span class="kw">changeLocations</span>(
     sim14[[scenarioToSampleMap14[i]]]$animalLoc,
                                     breedingSiteTrans14[[i]], 
                                     winteringSiteTrans14[[i]])
      
   results14[[i]] &lt;-<span class="st"> </span><span class="kw">calcPsiMC</span>(breedDist14[[i]], nonbreedDist14[[i]],
                               animalLoc14[[i]], 
                               <span class="dt">originRelAbund =</span> breedingRelN14[[i]], 
                               <span class="dt">verbose =</span> F)
      
   compare14.array[sim, i, <span class="st">'MC'</span>] &lt;-<span class="st"> </span>results14[[i]]$MC
      
   compare14.array[sim,i,<span class="st">'Mantel'</span>]&lt;-<span class="kw">calcStrengthInd</span>(breedDist14[[<span class="dv">1</span>]],
                                                    nonbreedDist14[[<span class="dv">1</span>]],
                                   sim14[[scenarioToSampleMap14[i]]]$animalLoc,
                                                    <span class="dt">resamp=</span><span class="dv">0</span>)$correlation
  }
}

<span class="co"># Compute means for each scenario</span>
compare14$MC[<span class="dv">1</span>:nScenarios14 +<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">apply</span>(compare14.array[,,<span class="st">'MC'</span>], <span class="dv">2</span>, mean)
compare14$Mantel[<span class="dv">1</span>:nScenarios14 +<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">apply</span>(compare14.array[,,<span class="st">'Mantel'</span>], <span class="dv">2</span>, 
                                              mean)

compare14 &lt;-<span class="st"> </span><span class="kw">transform</span>(compare14, <span class="dt">MC.diff=</span>MC -<span class="st"> </span>MC[<span class="dv">1</span>], 
                       <span class="dt">Mantel.diff=</span>Mantel -<span class="st"> </span>Mantel[<span class="dv">1</span>])
compare14</code></pre>
</div>
<div id="example-6" class="section level3">
<h3>EXAMPLE 6</h3>
<p>Sampling regime 2 of 3</p>
<p>Researchers divide populations differently than reality PLUS<br />Different distributions of sampling animals across breeding range PLUS<br />Sample sizes don’t always match relative abundances PLUS<br />Compare our approach and simple Mantel approach</p>
<ol style="list-style-type: decimal">
<li>Base (10 years, uneven abundances but matches sampling)</li>
<li>Breeding pops divided into 4 squares, sample across breeding range</li>
<li>Breeding pops divided into 4 squares, sample at centroid of each square</li>
<li>Sampling high in low abundance populations plus base</li>
<li>Scenarios 2 plus 4</li>
<li>Scenarios 3 plus 4</li>
</ol>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">75</span>)

<span class="co"># Transfer between true populations and researcher defined ones (only for</span>
<span class="co"># breeding, as not messing with winter populations here)</span>

breedingSiteTrans15 &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span>:<span class="dv">100</span>,
                            <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>), <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)),
                            <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>), <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)), 
                            <span class="dv">1</span>:<span class="dv">100</span>,
                            <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>), <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)),
                            <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>), <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)))

nScenarios15 &lt;-<span class="st"> </span><span class="kw">length</span>(breedingSiteTrans15)

nSims15 &lt;-<span class="st"> </span><span class="dv">100</span>

<span class="co"># Basing positions of researcher defined breeding populations on above</span>
breedingPos15 &lt;-<span class="st"> </span><span class="kw">list</span>(breedingPos, 
                      breedingPos14[[<span class="dv">5</span>]],
                      breedingPos14[[<span class="dv">5</span>]], 
                      breedingPos,
                      breedingPos14[[<span class="dv">5</span>]], 
                      breedingPos14[[<span class="dv">5</span>]])

winteringPos15 &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="kw">list</span>(winteringPos), nScenarios15)

breedDist15 &lt;-<span class="st"> </span><span class="kw">lapply</span>(breedingPos15, distFromPos)

nonbreedDist15 &lt;-<span class="st"> </span><span class="kw">lapply</span>(winteringPos15, distFromPos)

nBreeding15 &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="kw">c</span>(<span class="dv">100</span>, <span class="dv">4</span>, <span class="dv">4</span>), <span class="dv">2</span>)

nWintering15 &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">100</span>, nScenarios15)

<span class="co"># Highest abundance in lower right corner, lowest in top left</span>
<span class="co"># Making symmetrical</span>

breedingN15base &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, <span class="dv">100</span>)
for (i in <span class="dv">1</span>:<span class="dv">10</span>) <span class="co">#row</span>
  for (j in <span class="dv">1</span>:<span class="dv">10</span>)  <span class="co">#column</span>
    breedingN15base[i<span class="dv">+10</span>*(j<span class="dv">-1</span>)] &lt;-<span class="st"> </span><span class="dv">500</span> +<span class="st"> </span><span class="dv">850</span>*i*j

<span class="kw">sum</span>(breedingN15base)

<span class="co"># For researcher defined populations</span>
breedingN15 &lt;-<span class="st"> </span><span class="kw">lapply</span>(breedingSiteTrans15, rowsum, <span class="dt">x=</span>breedingN15base) 

breedingRelN15 &lt;-<span class="st"> </span><span class="kw">lapply</span>(breedingN15, <span class="st">&quot;/&quot;</span>, <span class="kw">sum</span>(breedingN15base))

nSample15 &lt;-<span class="st"> </span><span class="dv">1000</span> <span class="co"># Total number sampled per simulation</span>

<span class="co"># Number sampled per natural population</span>
sampleBreeding15 &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">round</span>(breedingRelN15[[<span class="dv">1</span>]]*nSample15),
                         <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">22</span>), <span class="kw">round</span>(breedingRelN15[[<span class="dv">3</span>]][<span class="dv">1</span>]*nSample15),
                           <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">4</span>), <span class="kw">round</span>(breedingRelN15[[<span class="dv">3</span>]][<span class="dv">2</span>]*nSample15),
                           <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">44</span>), <span class="kw">round</span>(breedingRelN15[[<span class="dv">3</span>]][<span class="dv">3</span>]*nSample15),
                           <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">4</span>), <span class="kw">round</span>(breedingRelN15[[<span class="dv">3</span>]][<span class="dv">4</span>]*nSample15),
                           <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">22</span>)),
                         <span class="kw">round</span>(breedingRelN15[[<span class="dv">1</span>]]*nSample15)[<span class="dv">100</span>:<span class="dv">1</span>],
                         <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">22</span>), <span class="kw">round</span>(breedingRelN15[[<span class="dv">3</span>]][<span class="dv">1</span>]*nSample15),
                           <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">4</span>), <span class="kw">round</span>(breedingRelN15[[<span class="dv">3</span>]][<span class="dv">2</span>]*nSample15),
                           <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">44</span>), <span class="kw">round</span>(breedingRelN15[[<span class="dv">3</span>]][<span class="dv">3</span>]*nSample15),
                           <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">4</span>), <span class="kw">round</span>(breedingRelN15[[<span class="dv">3</span>]][<span class="dv">4</span>]*nSample15),
                           <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">22</span>))[<span class="dv">100</span>:<span class="dv">1</span>])

<span class="co"># Set up psi matrix</span>
o15 &lt;-<span class="st"> </span><span class="kw">optimize</span>(mlogitMC, <span class="dt">MC.in =</span> <span class="fl">0.25</span>, <span class="dt">origin.dist =</span> breedDist15[[<span class="dv">1</span>]],
                <span class="dt">target.dist =</span> nonbreedDist15[[<span class="dv">1</span>]],
                <span class="dt">origin.abund =</span> breedingN15[[<span class="dv">1</span>]]/<span class="kw">sum</span>(breedingN15[[<span class="dv">1</span>]]),
                <span class="dt">sample.size =</span> <span class="kw">sum</span>(breedingN15[[<span class="dv">1</span>]]),
                <span class="dt">interval =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">10</span>),
                <span class="dt">tol =</span> .Machine$double.eps^<span class="fl">0.5</span>)

slope15 &lt;-<span class="st"> </span>o15$minimum

psi15 &lt;-<span class="st"> </span><span class="kw">mlogitMat</span>(slope15, breedDist15[[<span class="dv">1</span>]])

<span class="co"># Baseline strength of migratory connectivity</span>
MC15 &lt;-<span class="st"> </span><span class="kw">calcMC</span>(<span class="dt">originDist =</span> breedDist15[[<span class="dv">1</span>]], 
               <span class="dt">targetDist =</span> nonbreedDist15[[<span class="dv">1</span>]],
               <span class="dt">psi =</span> psi15,
               <span class="dt">originRelAbund =</span> breedingN15[[<span class="dv">1</span>]]/<span class="kw">sum</span>(breedingN15[[<span class="dv">1</span>]]),
               <span class="dt">sampleSize =</span> <span class="kw">sum</span>(breedingN15[[<span class="dv">1</span>]]))

<span class="co"># Run sampling regimes</span>
scenarioToSampleMap15 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">4</span>)

animalLoc15 &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, nScenarios15)

results15 &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, nScenarios15)

compare15 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">Scenario =</span> <span class="kw">c</span>(<span class="st">&quot;True&quot;</span>, 
                                     <span class="st">&quot;Base&quot;</span>, 
                                     <span class="st">&quot;Breeding4&quot;</span>,
                                     <span class="st">&quot;CentroidSampleBreeding4&quot;</span>,
                                     <span class="st">&quot;BiasedSample&quot;</span>, 
                                     <span class="st">&quot;BiasedSampleBreeding4&quot;</span>,
                                     <span class="st">&quot;BiasedCentroidSampleBreeding4&quot;</span>),
                        <span class="dt">MC =</span> <span class="kw">c</span>(MC15, <span class="kw">rep</span>(<span class="ot">NA</span>, nScenarios15)), 
                        <span class="dt">Mantel =</span> <span class="kw">c</span>(MC15, <span class="kw">rep</span>(<span class="ot">NA</span>, nScenarios15)))

compare15.array &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NA</span>, <span class="kw">c</span>(nSims15, nScenarios15, <span class="dv">2</span>),
                         <span class="dt">dimnames =</span> <span class="kw">list</span>(<span class="dv">1</span>:nSims15,
                                    <span class="kw">c</span>(<span class="st">&quot;Base&quot;</span>, <span class="st">&quot;Breeding4&quot;</span>, 
                                      <span class="st">&quot;CentroidSampleBreeding4&quot;</span>,
                                      <span class="st">&quot;BiasedSample&quot;</span>, <span class="st">&quot;BiasedSampleBreeding4&quot;</span>,
                                      <span class="st">&quot;BiasedCentroidSampleBreeding4&quot;</span>),
                                    <span class="kw">c</span>(<span class="st">&quot;MC&quot;</span>, <span class="st">&quot;Mantel&quot;</span>)))


for (sim in <span class="dv">1</span>:nSims15) {
  <span class="kw">cat</span>(<span class="st">&quot;Simulation&quot;</span>, sim, <span class="st">&quot;of&quot;</span>, nSims15, <span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)
  
  sim15 &lt;-<span class="st"> </span><span class="kw">lapply</span>(sampleBreeding15, 
                  simMove, 
                  <span class="dt">breedingDist =</span> breedDist15[[<span class="dv">1</span>]],
                  <span class="dt">winteringDist=</span>nonbreedDist15[[<span class="dv">1</span>]],
                  <span class="dt">psi=</span>psi15,
                  <span class="dt">nYears=</span>nYears,
                  <span class="dt">nMonths=</span>nMonths)
  
for (i in <span class="dv">1</span>:nScenarios15) {
  <span class="kw">cat</span>(<span class="st">&quot;</span><span class="ch">\t</span><span class="st">Scenario&quot;</span>, i, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
    animalLoc15[[i]] &lt;-<span class="st"> </span><span class="kw">changeLocations</span>(
                        <span class="dt">animalLoc=</span>sim15[[scenarioToSampleMap15[i]]]$animalLoc,
                        <span class="dt">breedingSiteTrans =</span> breedingSiteTrans15[[i]],
                        <span class="dt">winteringSiteTrans =</span> <span class="dv">1</span>:nWintering15[i])
    
    results15[[i]] &lt;-<span class="st"> </span><span class="kw">calcPsiMC</span>(<span class="dt">originDist =</span> breedDist15[[i]], 
                                <span class="dt">targetDist =</span> nonbreedDist15[[i]],
                                <span class="dt">originRelAbund =</span> breedingRelN15[[i]],
                                <span class="dt">locations =</span> animalLoc15[[i]], 
                                <span class="dt">verbose =</span> F)
    
compare15.array[sim, i, <span class="st">'MC'</span>] &lt;-<span class="st"> </span>results15[[i]]$MC

compare15.array[sim, i, <span class="st">'Mantel'</span>] &lt;-<span class="st"> </span><span class="kw">calcStrengthInd</span>(breedDist15[[<span class="dv">1</span>]],
                                                     nonbreedDist15[[<span class="dv">1</span>]],
                                   sim15[[scenarioToSampleMap15[i]]]$animalLoc,
                                                    <span class="dt">resamp=</span><span class="dv">0</span>)$correlation
  }
}

compare15$MC[<span class="dv">1</span>:nScenarios15<span class="dv">+1</span>] &lt;-<span class="st"> </span><span class="kw">apply</span>(compare15.array[,,<span class="st">'MC'</span>], <span class="dv">2</span>, mean, 
                                        <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)

compare15$Mantel[<span class="dv">1</span>:nScenarios15<span class="dv">+1</span>] &lt;-<span class="st"> </span><span class="kw">apply</span>(compare15.array[,,<span class="st">'Mantel'</span>], <span class="dv">2</span>,
                                            mean, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
compare15 &lt;-<span class="st"> </span><span class="kw">transform</span>(compare15, <span class="dt">MC.diff=</span>MC -<span class="st"> </span>MC[<span class="dv">1</span>], 
                       <span class="dt">Mantel.diff=</span>Mantel -<span class="st"> </span>Mantel[<span class="dv">1</span>],
                       <span class="dt">MC.prop=</span>MC/MC[<span class="dv">1</span>],  
                       <span class="dt">Mantel.prop=</span>Mantel/Mantel[<span class="dv">1</span>])


compare15a &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(compare15[<span class="dv">1</span> +<span class="st"> </span><span class="dv">1</span>:nScenarios15, 
                                  <span class="kw">c</span>(<span class="st">&quot;MC&quot;</span>, <span class="st">&quot;MC.diff&quot;</span>, <span class="st">&quot;Mantel&quot;</span>, <span class="st">&quot;Mantel.diff&quot;</span>)])

<span class="kw">rownames</span>(compare15a) &lt;-<span class="st"> </span>compare15$Scenario[<span class="dv">1</span> +<span class="st"> </span><span class="dv">1</span>:nScenarios15]</code></pre>
</div>
<div id="example-7" class="section level3">
<h3>EXAMPLE 7</h3>
<p>Sampling regime 3 of 3 Researchers divide populations differently than reality (simulations) PLUS Different distributions of sampled animals across breeding range PLUS Sample sizes don’t always match relative abundances PLUS Compare our approach and simple Mantel approach PLUS MC not same across subsections of range</p>
<ol style="list-style-type: decimal">
<li>Base (uneven MC (0.15 for NW breeding, 0.3 for SW, 0.45 for NE, and 0.6 for SE), uneven abundances (lowest in NW, highest in SE), sampling proportional to abundance</li>
<li>Breeding pops divided into 4 squares, sample across breeding range</li>
<li>Breeding pops divided into 4 squares, sample at centroid of each square</li>
<li>Sampling high in low abundance populations</li>
<li>Scenarios 2 plus 4</li>
<li>Scenarios 3 plus 4</li>
</ol>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">75</span>)

<span class="co"># Transfer between true populations and researcher defined ones</span>
<span class="co"># (only for breeding, as not messing with winter populations here)</span>
breedingSiteTrans16 &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span>:<span class="dv">100</span>, <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>), <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)),
                            <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>), <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)), <span class="dv">1</span>:<span class="dv">100</span>,
                            <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>), <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)),
                            <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>), <span class="kw">rep</span>(<span class="dv">3</span>:<span class="dv">4</span>, <span class="dv">5</span>, <span class="dt">each=</span><span class="dv">5</span>)))

<span class="co">#lapply(breedingSiteTrans16, matrix, nrow=10, ncol=10)</span>

nScenarios16 &lt;-<span class="st"> </span><span class="kw">length</span>(breedingSiteTrans16)

nSims16 &lt;-<span class="st"> </span><span class="dv">100</span>

<span class="co"># Basing positions of researcher defined breeding populations on above</span>
breedingPos16 &lt;-<span class="st"> </span>breedingPos15
winteringPos16 &lt;-<span class="st"> </span>winteringPos15

breedDist16 &lt;-<span class="st"> </span>breedDist15
nonbreedDist16 &lt;-<span class="st"> </span>nonbreedDist15
nBreeding16 &lt;-<span class="st"> </span>nBreeding15
nWintering16 &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">100</span>, nScenarios16)

<span class="co"># Highest abundance in lower right corner, lowest in top left</span>
<span class="co"># In fact basing on distance from top left population</span>

breedingN16base &lt;-<span class="st"> </span>breedingN15base
breedingN16 &lt;-<span class="st"> </span>breedingN15
breedingRelN16 &lt;-<span class="st"> </span><span class="kw">lapply</span>(breedingN16, <span class="st">&quot;/&quot;</span>, <span class="kw">sum</span>(breedingN16base))

<span class="co"># Set up psi matrix</span>
<span class="co"># Each quadrant of breeding range has different MC</span>

MC.levels16 &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="fl">0.15</span>, <span class="fl">0.6</span>, <span class="fl">0.15</span>)

nLevels16 &lt;-<span class="st"> </span><span class="dv">4</span>

psi16 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, nBreeding16[<span class="dv">1</span>], nWintering16[<span class="dv">1</span>])


for (i in <span class="dv">1</span>:nLevels16) {
  <span class="kw">cat</span>(<span class="st">&quot;MC&quot;</span>, MC.levels16[i])
  <span class="co"># Find a psi matrix that produces the given MC (for whole species)</span>
  o16a &lt;-<span class="st"> </span><span class="kw">optimize</span>(mlogitMC, <span class="dt">MC.in =</span> MC.levels16[i],
                   <span class="dt">origin.dist =</span> breedDist16[[<span class="dv">1</span>]],
                   <span class="dt">target.dist =</span> nonbreedDist16[[<span class="dv">1</span>]],
                   <span class="dt">origin.abund =</span> breedingN16[[<span class="dv">1</span>]]/<span class="kw">sum</span>(breedingN16[[<span class="dv">1</span>]]),
                   <span class="dt">sample.size =</span> <span class="kw">sum</span>(breedingN16[[<span class="dv">1</span>]]),
                   <span class="dt">interval=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">10</span>), <span class="dt">tol=</span>.Machine$double.eps^<span class="fl">0.5</span>)
  
  slope16a &lt;-<span class="st"> </span>o16a$minimum
  
  <span class="kw">cat</span>(<span class="st">&quot; slope&quot;</span>, slope16a, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
  
  psi16a &lt;-<span class="st"> </span><span class="kw">mlogitMat</span>(slope16a, breedDist16[[<span class="dv">1</span>]])
  
  <span class="co"># Then use the rows of that psi matrix only for the one breeding quadrant</span>
  rows &lt;-<span class="st"> </span><span class="dv">50</span>*(i %/%<span class="st"> </span><span class="dv">3</span>) +<span class="st"> </span><span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">5</span>, <span class="dv">5</span>) +<span class="st"> </span><span class="kw">rep</span>(<span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">40</span>, <span class="dv">10</span>), <span class="dt">each=</span><span class="dv">5</span>) +<span class="st"> </span>
<span class="st">    </span>((i<span class="dv">-1</span>) %%<span class="st"> </span><span class="dv">2</span>) *<span class="st"> </span><span class="dv">5</span>
  psi16[rows, ] &lt;-<span class="st"> </span>psi16a[rows, ]
}


<span class="co"># Baseline strength of migratory connectivity</span>
MC16 &lt;-<span class="st"> </span><span class="kw">calcMC</span>(<span class="dt">originDist =</span> breedDist16[[<span class="dv">1</span>]],
               <span class="dt">targetDist =</span> nonbreedDist16[[<span class="dv">1</span>]], 
               <span class="dt">psi =</span> psi16,
               <span class="dt">originRelAbund =</span> breedingN16[[<span class="dv">1</span>]]/<span class="kw">sum</span>(breedingN16[[<span class="dv">1</span>]]),
               <span class="dt">sampleSize =</span> <span class="kw">sum</span>(breedingN16[[<span class="dv">1</span>]]))


<span class="co"># Set up sampling regimes (different number than number of scenarios)</span>
nSample16 &lt;-<span class="st"> </span><span class="dv">1000</span>
sampleBreeding16 &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">round</span>(breedingRelN16[[<span class="dv">1</span>]]*nSample16),
                         <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">22</span>), <span class="kw">round</span>(breedingRelN16[[<span class="dv">3</span>]][<span class="dv">1</span>]*nSample16),
                           <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">4</span>), <span class="kw">round</span>(breedingRelN16[[<span class="dv">3</span>]][<span class="dv">2</span>]*nSample16),
                           <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">44</span>), <span class="kw">round</span>(breedingRelN16[[<span class="dv">3</span>]][<span class="dv">3</span>]*nSample16),
                           <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">4</span>), <span class="kw">round</span>(breedingRelN16[[<span class="dv">3</span>]][<span class="dv">4</span>]*nSample16),
                           <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">22</span>)),
                         <span class="kw">round</span>(breedingRelN16[[<span class="dv">1</span>]]*nSample16)[<span class="dv">100</span>:<span class="dv">1</span>],
                         <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">22</span>), <span class="kw">round</span>(breedingRelN16[[<span class="dv">3</span>]][<span class="dv">1</span>]*nSample16),
                           <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">4</span>), <span class="kw">round</span>(breedingRelN16[[<span class="dv">3</span>]][<span class="dv">2</span>]*nSample16),
                           <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">44</span>), <span class="kw">round</span>(breedingRelN16[[<span class="dv">3</span>]][<span class="dv">3</span>]*nSample16),
                           <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">4</span>), <span class="kw">round</span>(breedingRelN16[[<span class="dv">3</span>]][<span class="dv">4</span>]*nSample16),
                           <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">22</span>))[<span class="dv">100</span>:<span class="dv">1</span>])

<span class="kw">sapply</span>(sampleBreeding16, sum)

<span class="co"># Run sampling regimes</span>
scenarioToSampleMap16 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">4</span>)
animalLoc16 &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, nScenarios16)
results16 &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, nScenarios16)
compare16 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">Scenario =</span> <span class="kw">c</span>(<span class="st">&quot;True&quot;</span>,
                                     <span class="st">&quot;Base&quot;</span>,
                                     <span class="st">&quot;Breeding4&quot;</span>,
                                     <span class="st">&quot;CentroidSampleBreeding4&quot;</span>, 
                                     <span class="st">&quot;BiasedSample&quot;</span>,
                                     <span class="st">&quot;BiasedSampleBreeding4&quot;</span>,
                                     <span class="st">&quot;BiasedCentroidSampleBreeding4&quot;</span>),
                        <span class="dt">MC =</span> <span class="kw">c</span>(MC16, <span class="kw">rep</span>(<span class="ot">NA</span>, nScenarios16)),
                        <span class="dt">Mantel =</span> <span class="kw">c</span>(MC16, <span class="kw">rep</span>(<span class="ot">NA</span>, nScenarios16)))

compare16.array &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NA</span>, <span class="kw">c</span>(nSims16, nScenarios16, <span class="dv">2</span>), 
                         <span class="dt">dimnames =</span> <span class="kw">list</span>(<span class="dv">1</span>:nSims16,
                                         <span class="kw">c</span>(<span class="st">&quot;Base&quot;</span>, <span class="st">&quot;Breeding4&quot;</span>,
                                           <span class="st">&quot;CentroidSampleBreeding4&quot;</span>,
                                           <span class="st">&quot;BiasedSample&quot;</span>,
                                           <span class="st">&quot;BiasedSampleBreeding4&quot;</span>,
                                           <span class="st">&quot;BiasedCentroidSampleBreeding4&quot;</span>),
                                         <span class="kw">c</span>(<span class="st">&quot;MC&quot;</span>, <span class="st">&quot;Mantel&quot;</span>)))

<span class="kw">set.seed</span>(<span class="dv">80</span>)
for (sim in <span class="dv">1</span>:nSims16) {
  <span class="kw">cat</span>(<span class="st">&quot;Simulation&quot;</span>, sim, <span class="st">&quot;of&quot;</span>, nSims16, <span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)
  
  sim16 &lt;-<span class="st"> </span><span class="kw">lapply</span>(sampleBreeding16, simMove, <span class="dt">breedingDist =</span> breedDist16[[<span class="dv">1</span>]],
                  <span class="dt">winteringDist=</span>nonbreedDist16[[<span class="dv">1</span>]], <span class="dt">psi=</span>psi16, <span class="dt">nYears=</span>nYears,
                  <span class="dt">nMonths=</span>nMonths)
  
for (i in <span class="dv">1</span>:nScenarios16) {
  <span class="kw">cat</span>(<span class="st">&quot;</span><span class="ch">\t</span><span class="st">Scenario&quot;</span>, i, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
  animalLoc16[[i]]&lt;-<span class="kw">changeLocations</span>(sim16[[scenarioToSampleMap16[i]]]$animalLoc,
                                      breedingSiteTrans16[[i]], 
                                      <span class="dv">1</span>:nWintering16[i])
    
  results16[[i]] &lt;-<span class="st"> </span><span class="kw">calcPsiMC</span>(<span class="dt">originDist =</span> breedDist16[[i]],
                              <span class="dt">targetDist =</span> nonbreedDist16[[i]],
                              <span class="dt">locations =</span> animalLoc16[[i]],
                              <span class="dt">originRelAbund =</span> breedingRelN16[[i]],
                              <span class="dt">verbose =</span> <span class="ot">FALSE</span>)
    
compare16.array[sim, i, <span class="st">'MC'</span>] &lt;-<span class="st"> </span>results16[[i]]$MC
    
compare16.array[sim, i, <span class="st">'Mantel'</span>] &lt;-<span class="st"> </span><span class="kw">calcStrengthInd</span>(breedDist16[[<span class="dv">1</span>]],
                                                         nonbreedDist16[[<span class="dv">1</span>]],
                                   sim16[[scenarioToSampleMap16[i]]]$animalLoc,
                                                         <span class="dt">resamp=</span><span class="dv">0</span>)$correlation
  }
}

compare16$MC[<span class="dv">1</span>:nScenarios16<span class="dv">+1</span>] &lt;-<span class="st"> </span><span class="kw">apply</span>(compare16.array[,,<span class="st">'MC'</span>], <span class="dv">2</span>, mean, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)

compare16$Mantel[<span class="dv">1</span>:nScenarios16<span class="dv">+1</span>] &lt;-<span class="st"> </span><span class="kw">apply</span>(compare16.array[,,<span class="st">'Mantel'</span>], <span class="dv">2</span>, 
                                            mean, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)

compare16 &lt;-<span class="st"> </span><span class="kw">transform</span>(compare16, <span class="dt">MC.diff=</span>MC -<span class="st"> </span>MC[<span class="dv">1</span>], 
                       <span class="dt">Mantel.diff=</span>Mantel -<span class="st"> </span>Mantel[<span class="dv">1</span>])

compare16a &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(compare16[<span class="dv">1</span> +<span class="st"> </span><span class="dv">1</span>:nScenarios16, <span class="kw">c</span>(<span class="st">'MC'</span>,<span class="st">'MC.diff'</span>,
                                                        <span class="st">&quot;Mantel&quot;</span>,
                                                        <span class="st">&quot;Mantel.diff&quot;</span>)])

<span class="kw">rownames</span>(compare16a) &lt;-<span class="st"> </span>compare16$Scenario[<span class="dv">1</span> +<span class="st"> </span><span class="dv">1</span>:nScenarios16]</code></pre>
</div>
<div id="example-8" class="section level3">
<h3>EXAMPLE 8</h3>
<p><code>estMC</code> Estimate strength of migratory connectivity incorporating uncertainty from limited sample size (no other sampling error). Here we simulated data using the 13th scenario from example 5 above (“CentroidSampleBreeding4”; make sure you run example 5 code before running this section). We changed the total sample size from 1000 to 100 animals and the total abundance from 50000 to 2500 animals.</p>
<pre class="sourceCode r"><code class="sourceCode r">WGS84 &lt;-<span class="st"> &quot;+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0&quot;</span>
  
<span class="kw">set.seed</span>(<span class="dv">75</span>)
capLocs14 &lt;-<span class="st"> </span><span class="kw">lapply</span>(breedingPos14, sp::SpatialPoints, 
                    <span class="dt">proj4string =</span> sp::<span class="kw">CRS</span>(WGS84))
targLocs14 &lt;-<span class="st"> </span><span class="kw">lapply</span>(winteringPos14, sp::SpatialPoints, 
                     <span class="dt">proj4string =</span> sp::<span class="kw">CRS</span>(WGS84))


<span class="co"># Relative abundance by scenario and breeding population</span>
breedingN14base &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">25</span>, nBreeding14[<span class="dv">1</span>])
breedingN14 &lt;-<span class="st"> </span><span class="kw">lapply</span>(breedingSiteTrans14, rowsum, <span class="dt">x=</span>breedingN14base)
breedingRelN14 &lt;-<span class="st"> </span><span class="kw">lapply</span>(breedingN14, <span class="st">&quot;/&quot;</span>, <span class="kw">sum</span>(breedingN14base))


MC14 &lt;-<span class="st"> </span><span class="fl">0.25</span>

nSample14<span class="fl">.1</span> &lt;-<span class="st"> </span><span class="dv">100</span> <span class="co"># Total number sampled per simulation</span>

<span class="co"># How many sampled from each natural population (sampling scenarios separate</span>
<span class="co"># from definition scenarios)</span>
sampleBreeding14<span class="fl">.1</span> &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">round</span>(breedingRelN14[[<span class="dv">1</span>]]*nSample14<span class="fl">.1</span>),
                         <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">0</span>,<span class="dv">22</span>),<span class="kw">round</span>(breedingRelN14[[<span class="dv">5</span>]][<span class="dv">1</span>]*nSample14<span class="fl">.1</span>),
                           <span class="kw">rep</span>(<span class="dv">0</span>,<span class="dv">4</span>), <span class="kw">round</span>(breedingRelN14[[<span class="dv">5</span>]][<span class="dv">2</span>]*nSample14<span class="fl">.1</span>),
                           <span class="kw">rep</span>(<span class="dv">0</span>,<span class="dv">44</span>),<span class="kw">round</span>(breedingRelN14[[<span class="dv">5</span>]][<span class="dv">3</span>]*nSample14<span class="fl">.1</span>),
                           <span class="kw">rep</span>(<span class="dv">0</span>,<span class="dv">4</span>), <span class="kw">round</span>(breedingRelN14[[<span class="dv">5</span>]][<span class="dv">4</span>]*nSample14<span class="fl">.1</span>),
                           <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">22</span>)),
                           <span class="kw">rep</span>(<span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">4</span>),
                           <span class="kw">rep</span>(<span class="kw">round</span>(breedingRelN14[[<span class="dv">2</span>]][<span class="dv">1</span>]*nSample14<span class="fl">.1</span>/<span class="dv">2</span>), <span class="dv">2</span>),
                           <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">4</span>)), <span class="dv">10</span>))

<span class="kw">lapply</span>(sampleBreeding14<span class="fl">.1</span>, matrix, <span class="dt">nrow=</span><span class="dv">10</span>, <span class="dt">ncol=</span><span class="dv">10</span>)

<span class="co"># Number of simulations to run</span>
nSims14 &lt;-<span class="st"> </span><span class="dv">100</span>
nSimsLarge14 &lt;-<span class="st"> </span><span class="dv">2500</span>
nYears &lt;-<span class="st"> </span><span class="dv">1</span>
nMonths &lt;-<span class="st"> </span><span class="dv">1</span>

<span class="co"># Set up data structures for storing results</span>
animalLoc14 &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, nScenarios14) <span class="co">#making an empty list to fill</span>
sim14 &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, nSimsLarge14) <span class="co">#making an empty list to fill</span>

compare14<span class="fl">.1</span>.array &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NA</span>, <span class="kw">c</span>(nSimsLarge14, <span class="dv">2</span>), 
                           <span class="dt">dimnames =</span> <span class="kw">list</span>(<span class="dv">1</span>:nSimsLarge14,
                                           <span class="kw">c</span>(<span class="st">&quot;MC&quot;</span>, <span class="st">&quot;Mantel&quot;</span>)))

results14 &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, nScenarios14)

<span class="co"># Run simulations</span>
<span class="kw">set.seed</span>(<span class="dv">7</span>)

<span class="kw">system.time</span>(for (sim in <span class="dv">1</span>:nSimsLarge14) {
  
  <span class="kw">cat</span>(<span class="st">&quot;Simulation&quot;</span>, sim, <span class="st">&quot;of&quot;</span>, nSimsLarge14, <span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)
  
  sim14[[sim]] &lt;-<span class="st"> </span><span class="kw">lapply</span>(sampleBreeding14<span class="fl">.1</span>,
                         simMove, 
                         <span class="dt">breedingDist =</span> breedDist14[[<span class="dv">1</span>]],
                         <span class="dt">winteringDist=</span>nonbreedDist14[[<span class="dv">1</span>]],
                         <span class="dt">psi=</span>psi,
                         <span class="dt">nYears=</span>nYears,
                         <span class="dt">nMonths=</span>nMonths)
  
for (i in <span class="dv">13</span>) {
 animalLoc14[[i]] &lt;-<span class="st"> </span><span class="kw">changeLocations</span>(sim14[[sim]][[scenarioToSampleMap14[i]]]$animalLoc,
                                     breedingSiteTrans14[[i]], 
                                     winteringSiteTrans14[[i]])
 
 results14[[i]] &lt;-<span class="st"> </span><span class="kw">calcPsiMC</span>(breedDist14[[i]], 
                             nonbreedDist14[[i]],
                             animalLoc14[[i]],
                             <span class="dt">originRelAbund =</span> breedingRelN14[[i]],
                             <span class="dt">verbose =</span> F)
 
  compare14<span class="fl">.1</span>.array[sim,<span class="st">'MC'</span>] &lt;-<span class="st"> </span>results14[[i]]$MC
    
  compare14<span class="fl">.1</span>.array[sim,<span class="st">'Mantel'</span>] &lt;-<span class="st"> </span><span class="kw">calcStrengthInd</span>(breedDist14[[<span class="dv">1</span>]],
                                                  nonbreedDist14[[<span class="dv">1</span>]],
                            sim14[[sim]][[scenarioToSampleMap14[i]]]$animalLoc,
                                                  <span class="dt">resamp=</span><span class="dv">0</span>)$correlation
  }
})

means14 &lt;-<span class="st"> </span><span class="kw">apply</span>(compare14<span class="fl">.1</span>.array, <span class="dv">2</span>, mean)

vars14 &lt;-<span class="st"> </span><span class="kw">apply</span>(compare14<span class="fl">.1</span>.array, <span class="dv">2</span>, var)

rmse14 &lt;-<span class="st"> </span><span class="kw">apply</span>(compare14<span class="fl">.1</span>.array, <span class="dv">2</span>, function(x) <span class="kw">sqrt</span>(<span class="kw">mean</span>((x -<span class="st"> </span>MC14)^<span class="dv">2</span>)))

<span class="co"># Set up data structures for storing estimation results</span>
est14.array &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NA</span>, <span class="kw">c</span>(nSims14, <span class="dv">2</span>), 
                     <span class="dt">dimnames =</span> <span class="kw">list</span>(<span class="dv">1</span>:nSims14,<span class="kw">c</span>(<span class="st">&quot;MC&quot;</span>, <span class="st">&quot;Mantel&quot;</span>)))

var14.array &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NA</span>, <span class="kw">c</span>(nSims14, <span class="dv">2</span>), 
                     <span class="dt">dimnames =</span><span class="kw">list</span>(<span class="dv">1</span>:nSims14,<span class="kw">c</span>(<span class="st">&quot;MC&quot;</span>, <span class="st">&quot;Mantel&quot;</span>)))

ci14.array &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NA</span>, <span class="kw">c</span>(nSims14, <span class="dv">2</span>, <span class="dv">2</span>), 
                    <span class="dt">dimnames =</span> <span class="kw">list</span>(<span class="dv">1</span>:nSims14,
                                    <span class="kw">c</span>(<span class="st">&quot;MC&quot;</span>, <span class="st">&quot;Mantel&quot;</span>),
                                    <span class="kw">c</span>(<span class="st">'lower'</span>, <span class="st">'upper'</span>)))

<span class="co">#making an empty list to fill</span>

animalLoc14 &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, nSims14) 

results14 &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, nSims14)

<span class="co"># Run estimations</span>
<span class="kw">set.seed</span>(<span class="dv">567</span>)

sim14.sub &lt;-<span class="st"> </span>sim14[<span class="kw">sample.int</span>(nSimsLarge14, nSims14, T)]

for (sim in <span class="dv">1</span>:nSims14) {
  <span class="kw">cat</span>(<span class="st">&quot;Estimation&quot;</span>, sim, <span class="st">&quot;of&quot;</span>, nSims14, <span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)
  
 for (i in <span class="dv">13</span>) {<span class="co">#:nScenarios14) {</span>
  animalLoc14[[sim]] &lt;-<span class="st"> </span>
<span class="st">    </span><span class="kw">changeLocations</span>(sim14.sub[[sim]][[scenarioToSampleMap14[i]]]$animalLoc,
                                        breedingSiteTrans14[[i]], 
                                        winteringSiteTrans14[[i]])
  
  results14[[sim]] &lt;-<span class="st"> </span><span class="kw">estMC</span>(breedDist14[[i]], 
                            nonbreedDist14[[i]],
                            <span class="dt">originRelAbund =</span> breedingRelN14[[i]],
              <span class="dt">originPoints =</span> capLocs14[[i]][animalLoc14[[sim]][, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>], ],
              <span class="dt">targetPoints =</span> targLocs14[[i]][animalLoc14[[sim]][, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>], ],
                            <span class="dt">originAssignment =</span> animalLoc14[[sim]][, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>],
                            <span class="dt">targetAssignment =</span> animalLoc14[[sim]][, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>],
                            <span class="dt">nSamples =</span> <span class="dv">1000</span>,
                            <span class="dt">verbose =</span> <span class="dv">0</span>,
                            <span class="dt">calcCorr =</span> T,
                            <span class="dt">geoBias =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>),
                            <span class="dt">geoVCov =</span> <span class="kw">matrix</span>(<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">2</span>))
  
    est14.array[sim, <span class="st">'MC'</span>] &lt;-<span class="st"> </span>results14[[sim]]$meanMC
    est14.array[sim, <span class="st">'Mantel'</span>] &lt;-<span class="st"> </span>results14[[sim]]$meanCorr
    var14.array[sim, <span class="st">'MC'</span>] &lt;-<span class="st"> </span>results14[[sim]]$seMC ^<span class="st"> </span><span class="dv">2</span>
    var14.array[sim, <span class="st">'Mantel'</span>] &lt;-<span class="st"> </span>results14[[sim]]$seCorr ^<span class="st"> </span><span class="dv">2</span>
    ci14.array[sim, <span class="st">'MC'</span>, ] &lt;-<span class="st"> </span>results14[[sim]]$bcCI
    ci14.array[sim, <span class="st">'Mantel'</span>, ] &lt;-<span class="st"> </span>results14[[sim]]$bcCICorr
  }
}

<span class="co"># Crude point estimates (bootstrap means are better)</span>
pointEsts14<span class="fl">.1</span> &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">sapply</span>(results14, function(x) <span class="kw">c</span>(x$pointMC, x$pointCorr)))

<span class="co"># Summarize results</span>
<span class="kw">summary</span>(var14.array)
vars14
<span class="kw">summary</span>(est14.array)
<span class="kw">summary</span>(pointEsts14<span class="fl">.1</span>)
means14
<span class="kw">colMeans</span>(pointEsts14<span class="fl">.1</span>) -<span class="st"> </span>MC14
<span class="kw">sqrt</span>(<span class="kw">colMeans</span>((pointEsts14<span class="fl">.1</span> -<span class="st"> </span>MC14)^<span class="dv">2</span>))
<span class="kw">summary</span>(ci14.array[, <span class="st">&quot;MC&quot;</span>, <span class="st">'lower'</span>] &lt;=<span class="st"> </span>MC14 &amp;<span class="st"> </span>
<span class="st">          </span>ci14.array[, <span class="st">&quot;MC&quot;</span>, <span class="st">'upper'</span>] &gt;=<span class="st"> </span>MC14)
<span class="kw">summary</span>(ci14.array[, <span class="st">&quot;Mantel&quot;</span>, <span class="st">'lower'</span>] &lt;=<span class="st"> </span>MC14 &amp;<span class="st"> </span>
<span class="st">          </span>ci14.array[, <span class="st">&quot;Mantel&quot;</span>, <span class="st">'upper'</span>] &gt;=<span class="st"> </span>MC14)

<span class="co"># Plot histograms of bootstrap estimation results</span>
est.df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">Parameter =</span> <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;MC&quot;</span>, <span class="st">'rM'</span>), <span class="dv">2</span>, <span class="dt">each =</span> nSims14),
                     <span class="dt">Quantity =</span> <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">'Mean'</span>, <span class="st">'Variance'</span>), <span class="dt">each =</span> <span class="dv">2</span> *<span class="st"> </span>nSims14),
                     <span class="dt">sim =</span> <span class="kw">rep</span>(<span class="dv">1</span>:nSims14, <span class="dv">4</span>), 
                     <span class="dt">Estimate =</span> <span class="kw">c</span>(est14.array, var14.array))

trues.df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">Parameter =</span> <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;MC&quot;</span>, <span class="st">'rM'</span>), <span class="dv">2</span>),
                       <span class="dt">Quantity =</span> <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">'Mean'</span>, <span class="st">'Variance'</span>), <span class="dt">each =</span> <span class="dv">2</span>),
                       <span class="dt">Value =</span> <span class="kw">c</span>(MC14, MC14, vars14))

<span class="kw">library</span>(ggplot2)
g.est &lt;-<span class="st"> </span><span class="kw">ggplot</span>(est.df, <span class="kw">aes</span>(Estimate)) +<span class="st"> </span><span class="kw">geom_histogram</span>(<span class="dt">bins =</span> <span class="dv">15</span>) +
<span class="st">  </span><span class="kw">facet_grid</span>(Parameter ~<span class="st"> </span>Quantity, <span class="dt">scales =</span> <span class="st">'free_x'</span>) +
<span class="st">  </span><span class="kw">geom_vline</span>(<span class="kw">aes</span>(<span class="dt">xintercept =</span> Value), <span class="dt">data =</span> trues.df) +
<span class="st">  </span><span class="kw">theme_bw</span>() +<span class="st"> </span><span class="kw">scale_x_continuous</span>(<span class="dt">breaks =</span> <span class="kw">c</span>(<span class="fl">0.002</span>, <span class="fl">0.003</span>, <span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.3</span>))

g.est


<span class="co"># Summary table of bootstrap estimation results</span>
qualities14 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">Parameter =</span> <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;MC&quot;</span>, <span class="st">'rM'</span>), <span class="dv">5</span>),
                          <span class="dt">Quantity =</span> <span class="kw">rep</span>(<span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">'Mean'</span>, <span class="st">'Variance'</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>)), 
                                         <span class="dv">3</span>, <span class="dv">10</span>),
                          <span class="dt">Measure =</span> <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">'Bias'</span>, <span class="st">'RMSE'</span>, <span class="st">&quot;Coverage&quot;</span>), 
                                        <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">2</span>)),
                          <span class="dt">Value =</span> <span class="kw">c</span>(<span class="kw">colMeans</span>(est14.array -<span class="st"> </span>MC14),
                                    <span class="kw">colMeans</span>(var14.array) -<span class="st"> </span>vars14,
                                    <span class="kw">sqrt</span>(<span class="kw">colMeans</span>((est14.array -<span class="st"> </span>MC14)^<span class="dv">2</span>)),
                                    <span class="kw">sqrt</span>(<span class="kw">mean</span>((var14.array[,<span class="dv">1</span>]-vars14[<span class="dv">1</span>])^<span class="dv">2</span>)),
                                    <span class="kw">sqrt</span>(<span class="kw">mean</span>((var14.array[,<span class="dv">2</span>]-vars14[<span class="dv">2</span>])^<span class="dv">2</span>)),
                                    <span class="kw">mean</span>(ci14.array[, <span class="st">&quot;MC&quot;</span>, <span class="st">'lower'</span>] &lt;=<span class="st"> </span>MC14 &amp;<span class="st"> </span>
<span class="st">                                         </span>ci14.array[, <span class="st">&quot;MC&quot;</span>, <span class="st">'upper'</span>] &gt;=<span class="st"> </span>MC14),
                                    <span class="kw">mean</span>(ci14.array[,<span class="st">&quot;Mantel&quot;</span>,<span class="st">'lower'</span>]&lt;=MC14 &amp;
<span class="st">                                         </span>ci14.array[,<span class="st">&quot;Mantel&quot;</span>,<span class="st">'upper'</span>]&gt;=MC14)))

<span class="kw">format</span>(qualities14, <span class="dt">digits =</span> <span class="dv">2</span>, <span class="dt">scientific =</span> F)</code></pre>
</div>
<div id="example-9" class="section level3">
<h3>EXAMPLE 9</h3>
<p><code>estMC</code> Estimate strength of migratory connectivity incorporating uncertainty from location error associated with light-level geolocators. Again, we simulated data using the 13th scenario from example 5 above (“CentroidSampleBreeding4”; make sure you run examples 5 and 8 code before running this section).</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Simulation using error associated with light-level geolocators</span>
<span class="co"># Assign geolocator bias / variance co-variance matrix</span>

geoBias &lt;-<span class="st"> </span><span class="kw">c</span>(-<span class="dv">10000</span>, <span class="dv">50000</span>)
geoVCov &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="fl">1.2e+8</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="fl">1.2e+9</span>), <span class="dv">2</span>, <span class="dv">2</span>)
<span class="kw">sqrt</span>(<span class="kw">diag</span>(geoVCov))

<span class="co"># Define projections</span>
WGS84 &lt;-<span class="st"> &quot;+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0&quot;</span>

Lambert &lt;-<span class="st"> &quot;+proj=aea +lat_1=20 +lat_2=60 +lat_0=40 +lon_0=-96 +x_0=0 +y_0=0 </span>
<span class="st">            +ellps=GRS80 +datum=NAD83 +units=m +no_defs&quot;</span>

resampleProjection &lt;-<span class="st"> &quot;+proj=eqc +lat_ts=0 +lat_0=0 +lon_0=0 +x_0=0 +y_0=0 </span>
<span class="st">                      +a=6371007 +b=6371007 +units=m +no_defs&quot;</span>

targLocs14<span class="fl">.2</span> &lt;-<span class="st"> </span><span class="kw">lapply</span>(targLocs14, sp::spTransform, <span class="dt">CRSobj =</span> sp::<span class="kw">CRS</span>(Lambert))

<span class="co"># convert wintering locations to polygons using the helper function</span>
WinteringPolys &lt;-<span class="st"> </span><span class="kw">lapply</span>(winteringPos14,
                         toPoly,
                         <span class="dt">projection.in =</span> WGS84, 
                         <span class="dt">projection.out =</span> Lambert)

winteringPolys &lt;-<span class="st"> </span><span class="kw">lapply</span>(winteringPos14,
                         toPoly,
                         <span class="dt">projection.in =</span> WGS84,
                         <span class="dt">projection.out =</span> WGS84)

winteringPolys2 &lt;-<span class="st"> </span><span class="kw">lapply</span>(winteringPos14,
                          toPoly,
                          <span class="dt">projection.in =</span> WGS84,
                          <span class="dt">projection.out =</span> resampleProjection)

<span class="co"># Double check that the input center points and output polygons are ordered</span>
<span class="co"># correctly </span>
<span class="kw">cbind</span>(breedingPos14[[<span class="dv">1</span>]][,<span class="dv">1</span>:<span class="dv">2</span>],
      <span class="kw">t</span>(<span class="kw">sapply</span>(<span class="kw">slot</span>(breedingPolys[[<span class="dv">1</span>]], <span class="st">&quot;polygons&quot;</span>),
               function(x){ <span class="kw">slot</span>(x,<span class="st">&quot;labpt&quot;</span>)})))

<span class="kw">cbind</span>(winteringPos14[[<span class="dv">1</span>]][,<span class="dv">1</span>:<span class="dv">2</span>],
      <span class="kw">t</span>(<span class="kw">sapply</span>(<span class="kw">slot</span>(winteringPolys[[<span class="dv">1</span>]], <span class="st">&quot;polygons&quot;</span>),
               function(x){ <span class="kw">slot</span>(x,<span class="st">&quot;labpt&quot;</span>)})))
  
<span class="co"># Simulate capture and non-breeding locations of 100 individuals #</span>

nSample14<span class="fl">.2</span> &lt;-<span class="st"> </span><span class="dv">100</span> <span class="co"># Total number sampled per simulation</span>

<span class="co"># How many sampled from each natural population (sampling scenarios separate</span>
<span class="co"># from definition scenarios)</span>
sampleBreeding14<span class="fl">.2</span> &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">round</span>(breedingRelN14[[<span class="dv">1</span>]]*nSample14<span class="fl">.2</span>),
                         <span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">0</span>,<span class="dv">22</span>),<span class="kw">round</span>(breedingRelN14[[<span class="dv">5</span>]][<span class="dv">1</span>]*nSample14<span class="fl">.2</span>),
                           <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">4</span>),<span class="kw">round</span>(breedingRelN14[[<span class="dv">5</span>]][<span class="dv">2</span>]*nSample14<span class="fl">.2</span>),
                           <span class="kw">rep</span>(<span class="dv">0</span>,<span class="dv">44</span>),<span class="kw">round</span>(breedingRelN14[[<span class="dv">5</span>]][<span class="dv">3</span>]*nSample14<span class="fl">.2</span>),
                           <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">4</span>),<span class="kw">round</span>(breedingRelN14[[<span class="dv">5</span>]][<span class="dv">4</span>]*nSample14<span class="fl">.2</span>),
                           <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">22</span>)),
                         <span class="kw">rep</span>(<span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">4</span>),
                               <span class="kw">rep</span>(<span class="kw">round</span>(breedingRelN14[[<span class="dv">2</span>]][<span class="dv">1</span>]*nSample14<span class="fl">.2</span>/<span class="dv">2</span>),
                                   <span class="dv">2</span>),
                               <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">4</span>)), <span class="dv">10</span>))

<span class="kw">lapply</span>(sampleBreeding14<span class="fl">.2</span>, matrix, <span class="dt">nrow=</span><span class="dv">10</span>, <span class="dt">ncol=</span><span class="dv">10</span>)

<span class="co"># Number of simulations to run</span>
nSims14<span class="fl">.2</span> &lt;-<span class="st"> </span><span class="dv">100</span>
nSimsLarge14<span class="fl">.2</span> &lt;-<span class="st"> </span><span class="dv">2500</span>
nYears &lt;-<span class="st"> </span><span class="dv">1</span>
nMonths &lt;-<span class="st"> </span><span class="dv">1</span>

<span class="co"># Set up data structures for storing results</span>

<span class="co">#making an empty list to fill</span>
animalLoc14 &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, nScenarios14) 
sim14<span class="fl">.2</span> &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, nSimsLarge14<span class="fl">.2</span>) 

compare14<span class="fl">.2</span>.array &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NA</span>, <span class="kw">c</span>(nSimsLarge14<span class="fl">.2</span>, <span class="dv">2</span>), 
                           <span class="dt">dimnames =</span> <span class="kw">list</span>(<span class="dv">1</span>:nSimsLarge14<span class="fl">.2</span>,
                                           <span class="kw">c</span>(<span class="st">&quot;MC&quot;</span>, <span class="st">&quot;Mantel&quot;</span>)))

results14 &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, nScenarios14)
results14<span class="fl">.2</span> &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, nSimsLarge14<span class="fl">.2</span>)
originDist1 &lt;-<span class="st"> </span>targetDist1 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, nSample14<span class="fl">.2</span>, nSample14<span class="fl">.2</span>)
targetDist1[<span class="kw">lower.tri</span>(targetDist1)] &lt;-<span class="st"> </span><span class="dv">1</span>
distIndices &lt;-<span class="st"> </span><span class="kw">which</span>(!<span class="kw">is.na</span>(targetDist1), <span class="dt">arr.ind =</span> T)

<span class="co"># Run simulations</span>
<span class="kw">set.seed</span>(<span class="dv">7</span>)

<span class="kw">system.time</span>(for (sim in <span class="dv">1</span>:nSimsLarge14<span class="fl">.2</span>) {
  <span class="kw">cat</span>(<span class="st">&quot;Simulation&quot;</span>, sim, <span class="st">&quot;of&quot;</span>, nSimsLarge14<span class="fl">.2</span>, <span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)
  sim14<span class="fl">.2</span>[[sim]] &lt;-<span class="st"> </span><span class="kw">lapply</span>(sampleBreeding14<span class="fl">.2</span>,
                           simMove,
                           <span class="dt">breedingDist =</span> breedDist14[[<span class="dv">1</span>]],
                           <span class="dt">winteringDist=</span>nonbreedDist14[[<span class="dv">1</span>]],
                           <span class="dt">psi=</span>psi,
                           <span class="dt">nYears=</span>nYears,
                           <span class="dt">nMonths=</span>nMonths)
  
for (i in <span class="dv">13</span>) { <span class="co"># only run one scenario</span>
  animalLoc14<span class="fl">.0</span> &lt;-<span class="st"> </span>sim14<span class="fl">.2</span>[[sim]][[scenarioToSampleMap14[i]]]$animalLoc
  animalLoc14[[i]] &lt;-<span class="st"> </span><span class="kw">changeLocations</span>(animalLoc14<span class="fl">.0</span>,
                                      breedingSiteTrans14[[i]],
                                      winteringSiteTrans14[[i]])
  
    breedingTruePoints14 &lt;-<span class="st"> </span>capLocs14[[i]][animalLoc14[[i]][,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>], ]
    
    winteringTruePoints14 &lt;-<span class="st"> </span>targLocs14<span class="fl">.2</span>[[i]][animalLoc14<span class="fl">.0</span>[,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">1</span>], ]
    
    results14<span class="fl">.2</span>[[sim]] &lt;-<span class="st"> </span><span class="kw">simLocationError</span>(winteringTruePoints14, 
                                           WinteringPolys[[i]], 
                                           geoBias,
                                           geoVCov,
                                           Lambert)
    
    animalLoc14<span class="fl">.2</span> &lt;-<span class="st"> </span>animalLoc14[[i]]
    
    animalLoc14<span class="fl">.2</span>[ , <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>] &lt;-<span class="st"> </span>results14<span class="fl">.2</span>[[sim]]$targetSample
    
    results14[[i]] &lt;-<span class="st"> </span><span class="kw">calcPsiMC</span>(breedDist14[[i]], 
                                nonbreedDist14[[i]],
                                animalLoc14<span class="fl">.2</span>,
                                <span class="dt">originRelAbund =</span> breedingRelN14[[i]],
                                <span class="dt">verbose =</span> F)
    
    compare14<span class="fl">.2</span>.array[sim, <span class="st">'MC'</span>] &lt;-<span class="st"> </span>results14[[i]]$MC
    
    originDist0 &lt;-<span class="st"> </span>geosphere::<span class="kw">distVincentyEllipsoid</span>(
                                     breedingTruePoints14[distIndices[,<span class="st">'row'</span>]],
                                     breedingTruePoints14[distIndices[,<span class="st">'col'</span>]])
    
    originDist1[<span class="kw">lower.tri</span>(originDist1)] &lt;-<span class="st"> </span>originDist0
    
    target.point.sample &lt;-<span class="st"> </span>sp::<span class="kw">SpatialPoints</span>(
      results14<span class="fl">.2</span>[[sim]]$targetPointSample,
                                             sp::<span class="kw">CRS</span>(Lambert))
    
    target.point.sample2 &lt;-<span class="st"> </span>sp::<span class="kw">spTransform</span>(target.point.sample,sp::<span class="kw">CRS</span>(WGS84))
    
    targetDist0 &lt;-<span class="st"> </span>geosphere::<span class="kw">distVincentyEllipsoid</span>(
                                     target.point.sample2[distIndices[,<span class="st">'row'</span>]],
                                     target.point.sample2[distIndices[,<span class="st">'col'</span>]])
    
    targetDist1[<span class="kw">lower.tri</span>(targetDist1)] &lt;-<span class="st"> </span>targetDist0
    
    compare14<span class="fl">.2</span>.array[sim, <span class="st">'Mantel'</span>] &lt;-<span class="st"> </span>ncf::<span class="kw">mantel.test</span>(originDist1, 
                                                         targetDist1, 
                                                         <span class="dt">resamp=</span><span class="dv">0</span>, 
                                                         <span class="dt">quiet =</span> T)$correlation
  }
})

means14<span class="fl">.2</span> &lt;-<span class="st"> </span><span class="kw">apply</span>(compare14<span class="fl">.2</span>.array, <span class="dv">2</span>, mean)
vars14<span class="fl">.2</span> &lt;-<span class="st"> </span><span class="kw">apply</span>(compare14<span class="fl">.2</span>.array, <span class="dv">2</span>, var)
rmse14<span class="fl">.2</span> &lt;-<span class="st"> </span><span class="kw">apply</span>(compare14<span class="fl">.2</span>.array, <span class="dv">2</span>, function(x) <span class="kw">sqrt</span>(<span class="kw">mean</span>((x -<span class="st"> </span>MC14)^<span class="dv">2</span>)))

<span class="co"># Set up data structures for storing estimation results</span>
est14<span class="fl">.2</span>.array &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NA</span>, <span class="kw">c</span>(nSims14<span class="fl">.2</span>, <span class="dv">2</span>), 
                       <span class="dt">dimnames =</span> <span class="kw">list</span>(<span class="dv">1</span>:nSims14<span class="fl">.2</span>,
                                       <span class="kw">c</span>(<span class="st">&quot;MC&quot;</span>, <span class="st">&quot;Mantel&quot;</span>)))

var14<span class="fl">.2</span>.array &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NA</span>, <span class="kw">c</span>(nSims14<span class="fl">.2</span>, <span class="dv">2</span>), 
                       <span class="dt">dimnames =</span> <span class="kw">list</span>(<span class="dv">1</span>:nSims14<span class="fl">.2</span>,
                                       <span class="kw">c</span>(<span class="st">&quot;MC&quot;</span>, <span class="st">&quot;Mantel&quot;</span>)))

ci14<span class="fl">.2</span>.array &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NA</span>, <span class="kw">c</span>(nSims14<span class="fl">.2</span>, <span class="dv">2</span>, <span class="dv">2</span>), 
                      <span class="dt">dimnames =</span> <span class="kw">list</span>(<span class="dv">1</span>:nSims14<span class="fl">.2</span>,
                                      <span class="kw">c</span>(<span class="st">&quot;MC&quot;</span>, <span class="st">&quot;Mantel&quot;</span>),
                                      <span class="kw">c</span>(<span class="st">'lower'</span>, <span class="st">'upper'</span>)))

animalLoc14 &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, nSims14<span class="fl">.2</span>) <span class="co">#making an empty list to fill</span>
results14 &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, nSims14<span class="fl">.2</span>)

<span class="co"># Run estimations</span>

<span class="kw">set.seed</span>(<span class="dv">567</span>)
sim14<span class="fl">.2</span>.sub &lt;-<span class="st"> </span>sim14<span class="fl">.2</span>[<span class="kw">sample.int</span>(nSimsLarge14<span class="fl">.2</span>, nSims14<span class="fl">.2</span>, T)]

for (sim in <span class="dv">1</span>:nSims14<span class="fl">.2</span>) {
  <span class="kw">cat</span>(<span class="st">&quot;Estimation&quot;</span>, sim, <span class="st">&quot;of&quot;</span>, nSims14<span class="fl">.2</span>, <span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)
 for (i in <span class="dv">13</span>) {
  points0 &lt;-<span class="st"> </span>sp::<span class="kw">SpatialPoints</span>(results14<span class="fl">.2</span>[[sim]]$targetPointSample,
                                sp::<span class="kw">CRS</span>(Lambert))
    
  points1 &lt;-<span class="st"> </span>sp::<span class="kw">spTransform</span>(points0, 
                              sp::<span class="kw">CRS</span>(resampleProjection))
    
  animalLoc14[[sim]] &lt;-<span class="st"> </span><span class="kw">changeLocations</span>(
    sim14<span class="fl">.2</span>.sub[[sim]][[scenarioToSampleMap14[i]]]$animalLoc,
                                        breedingSiteTrans14[[i]],
                                        winteringSiteTrans14[[i]])
  
  results14[[sim]] &lt;-<span class="st"> </span><span class="kw">estMC</span>(<span class="dt">originDist =</span> breedDist14[[i]],
                            <span class="dt">targetDist =</span> nonbreedDist14[[i]],
                            <span class="dt">originRelAbund =</span> breedingRelN14[[i]],
                <span class="dt">originPoints =</span> capLocs14[[i]][animalLoc14[[sim]][, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>], ],
                            <span class="dt">targetPoints =</span> points1,
                            <span class="dt">originAssignment =</span> animalLoc14[[sim]][, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>],
                            <span class="dt">targetAssignment =</span> results14<span class="fl">.2</span>[[sim]]$targetSample,
                            <span class="dt">nSamples =</span> <span class="dv">1000</span>,
                            <span class="dt">verbose =</span> <span class="dv">0</span>,
                            <span class="dt">calcCorr =</span> T,
                            <span class="dt">geoBias =</span> geoBias,
                            <span class="dt">geoVCov =</span> geoVCov,
                            <span class="dt">isGL =</span> T,
                            <span class="dt">targetSites =</span> winteringPolys2[[i]])
  
    est14<span class="fl">.2</span>.array[sim, <span class="st">'MC'</span>] &lt;-<span class="st"> </span>results14[[sim]]$meanMC
    
    est14<span class="fl">.2</span>.array[sim, <span class="st">'Mantel'</span>] &lt;-<span class="st"> </span>results14[[sim]]$meanCorr
    
    var14<span class="fl">.2</span>.array[sim, <span class="st">'MC'</span>] &lt;-<span class="st"> </span>results14[[sim]]$seMC ^<span class="st"> </span><span class="dv">2</span>
    
    var14<span class="fl">.2</span>.array[sim, <span class="st">'Mantel'</span>] &lt;-<span class="st"> </span>results14[[sim]]$seCorr ^<span class="st"> </span><span class="dv">2</span>
    
    ci14<span class="fl">.2</span>.array[sim, <span class="st">'MC'</span>, ] &lt;-<span class="st"> </span>results14[[sim]]$bcCI
    
    ci14<span class="fl">.2</span>.array[sim, <span class="st">'Mantel'</span>, ] &lt;-<span class="st"> </span>results14[[sim]]$bcCICorr
    
  }
}

pointEsts14<span class="fl">.2</span> &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">sapply</span>(results14, function(x) <span class="kw">c</span>(x$pointMC, x$pointCorr)))

<span class="co"># Summarize estimation results</span>
<span class="kw">summary</span>(var14<span class="fl">.2</span>.array)
vars14<span class="fl">.2</span>
<span class="kw">summary</span>(est14<span class="fl">.2</span>.array)
<span class="kw">summary</span>(pointEsts14<span class="fl">.2</span>)
<span class="kw">colMeans</span>(pointEsts14<span class="fl">.2</span>) -<span class="st"> </span>MC14
<span class="kw">sqrt</span>(<span class="kw">colMeans</span>((pointEsts14<span class="fl">.2</span> -<span class="st"> </span>MC14)^<span class="dv">2</span>))
means14<span class="fl">.2</span>
<span class="kw">mean</span>(ci14<span class="fl">.2</span>.array[, <span class="st">&quot;MC&quot;</span>, <span class="st">'lower'</span>] &lt;=<span class="st"> </span>MC14 &amp;<span class="st"> </span>
<span class="st">       </span>ci14<span class="fl">.2</span>.array[, <span class="st">&quot;MC&quot;</span>, <span class="st">'upper'</span>] &gt;=<span class="st"> </span>MC14)
<span class="kw">mean</span>(ci14<span class="fl">.2</span>.array[, <span class="st">&quot;Mantel&quot;</span>, <span class="st">'lower'</span>] &lt;=<span class="st"> </span>MC14 &amp;<span class="st"> </span>
<span class="st">       </span>ci14<span class="fl">.2</span>.array[, <span class="st">&quot;Mantel&quot;</span>, <span class="st">'upper'</span>] &gt;=<span class="st"> </span>MC14)
<span class="kw">sqrt</span>(vars14<span class="fl">.2</span>) /<span class="st"> </span>MC14
<span class="kw">summary</span>(<span class="kw">sqrt</span>(var14<span class="fl">.2</span>.array)/est14<span class="fl">.2</span>.array)

<span class="co"># Plot histograms of bootstrap estimation results</span>
est14<span class="fl">.2</span>.df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">Parameter =</span> <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;MC&quot;</span>, <span class="st">'rM'</span>), <span class="dv">2</span>, <span class="dt">each =</span> nSims14<span class="fl">.2</span>),
                     <span class="dt">Quantity =</span> <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">'Mean'</span>, <span class="st">'Variance'</span>), 
                                    <span class="dt">each =</span> <span class="dv">2</span> *<span class="st"> </span>nSims14<span class="fl">.2</span>),
                     <span class="dt">sim =</span> <span class="kw">rep</span>(<span class="dv">1</span>:nSims14<span class="fl">.2</span>, <span class="dv">4</span>), 
                     <span class="dt">Estimate =</span> <span class="kw">c</span>(est14<span class="fl">.2</span>.array, var14<span class="fl">.2</span>.array))

trues14<span class="fl">.2</span>.df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">Parameter =</span> <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;MC&quot;</span>, <span class="st">'rM'</span>), <span class="dv">2</span>),
                       <span class="dt">Quantity =</span> <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">'Mean'</span>, <span class="st">'Variance'</span>), <span class="dt">each =</span> <span class="dv">2</span>),
                       <span class="dt">Value =</span> <span class="kw">c</span>(MC14, MC14, vars14<span class="fl">.2</span>))

g.est &lt;-<span class="st"> </span><span class="kw">ggplot</span>(est14<span class="fl">.2</span>.df, <span class="kw">aes</span>(Estimate)) +<span class="st"> </span><span class="kw">geom_histogram</span>(<span class="dt">bins =</span> <span class="dv">15</span>) +
<span class="st">  </span><span class="kw">facet_grid</span>(Parameter ~<span class="st"> </span>Quantity, <span class="dt">scales =</span> <span class="st">'free_x'</span>) +
<span class="st">  </span><span class="kw">geom_vline</span>(<span class="kw">aes</span>(<span class="dt">xintercept =</span> Value), <span class="dt">data =</span> trues14<span class="fl">.2</span>.df) +
<span class="st">  </span><span class="kw">theme_bw</span>() +<span class="st"> </span><span class="kw">scale_x_continuous</span>(<span class="dt">breaks =</span> <span class="kw">c</span>(<span class="fl">0.002</span>, <span class="fl">0.003</span>, <span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.3</span>))

g.est


<span class="co"># Summary table of bootstrap estimation results</span>
qualities14<span class="fl">.2</span> &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">Parameter =</span> <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;MC&quot;</span>, <span class="st">'rM'</span>), <span class="dv">5</span>),
                            <span class="dt">Quantity =</span> <span class="kw">rep</span>(<span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">'Mean'</span>, <span class="st">'Variance'</span>), 
                                               <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>)), <span class="dv">3</span>, <span class="dv">10</span>),
                            <span class="dt">Measure =</span> <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">'Bias'</span>, <span class="st">'RMSE'</span>, <span class="st">&quot;Coverage&quot;</span>), 
                                          <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">2</span>)),
                            <span class="dt">Value =</span> <span class="kw">c</span>(<span class="kw">colMeans</span>(est14<span class="fl">.2</span>.array -<span class="st"> </span>MC14),
                                      <span class="kw">colMeans</span>(var14<span class="fl">.2</span>.array) -<span class="st"> </span>vars14<span class="fl">.2</span>,
                                      <span class="kw">sqrt</span>(<span class="kw">colMeans</span>((est14<span class="fl">.2</span>.array -<span class="st"> </span>MC14)^<span class="dv">2</span>)),
                                      <span class="kw">sqrt</span>(<span class="kw">mean</span>((var14<span class="fl">.2</span>.array[,<span class="dv">1</span>] -<span class="st"> </span>
<span class="st">                                                   </span>vars14[<span class="dv">1</span>])^<span class="dv">2</span>)),
                                      <span class="kw">sqrt</span>(<span class="kw">mean</span>((var14<span class="fl">.2</span>.array[,<span class="dv">2</span>] -<span class="st"> </span>
<span class="st">                                                   </span>vars14[<span class="dv">2</span>])^<span class="dv">2</span>)),
                                      <span class="kw">mean</span>(ci14<span class="fl">.2</span>.array[,<span class="st">&quot;MC&quot;</span>,<span class="st">'lower'</span>]&lt;=MC14 &amp;
<span class="st">                                           </span>ci14<span class="fl">.2</span>.array[,<span class="st">&quot;MC&quot;</span>,<span class="st">'upper'</span>]&gt;=MC14),
                              <span class="kw">mean</span>(ci14<span class="fl">.2</span>.array[, <span class="st">&quot;Mantel&quot;</span>, <span class="st">'lower'</span>] &lt;=<span class="st"> </span>MC14 &amp;<span class="st"> </span>
<span class="st">                                   </span>ci14<span class="fl">.2</span>.array[, <span class="st">&quot;Mantel&quot;</span>, <span class="st">'upper'</span>] &gt;=<span class="st"> </span>MC14)))

<span class="kw">format</span>(qualities14<span class="fl">.2</span>, <span class="dt">digits =</span> <span class="dv">2</span>, <span class="dt">scientific =</span> F)



<span class="co"># Make summary table and figures of results with (Example 9) and without </span>
<span class="co"># (Example 8) location error</span>

qualities.all &lt;-<span class="st"> </span><span class="kw">rbind</span>(<span class="kw">data.frame</span>(<span class="dt">DataType =</span> <span class="st">'GPS'</span>, qualities14),
                       <span class="kw">data.frame</span>(<span class="dt">DataType =</span> <span class="st">'GL'</span>, qualities14<span class="fl">.2</span>))


est14.all.df &lt;-<span class="st"> </span><span class="kw">rbind</span>(<span class="kw">data.frame</span>(<span class="dt">DataType =</span> <span class="st">'GPS'</span>, est.df),
                       <span class="kw">data.frame</span>(<span class="dt">DataType =</span> <span class="st">'GL'</span>, est14<span class="fl">.2</span>.df))

trues14.all.df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">DataType =</span> <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;GPS&quot;</span>, <span class="st">&quot;GL&quot;</span>), <span class="dv">2</span>, <span class="dt">each =</span> <span class="dv">2</span>),
                             <span class="dt">Parameter =</span> <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;MC&quot;</span>, <span class="st">'rM'</span>), <span class="dv">4</span>),
                       <span class="dt">Quantity =</span> <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">'Mean'</span>, <span class="st">'Variance'</span>), <span class="dt">each =</span> <span class="dv">4</span>),
                       <span class="dt">Value =</span> <span class="kw">c</span>(<span class="kw">rep</span>(MC14, <span class="dv">4</span>), vars14, vars14<span class="fl">.2</span>))

g.est &lt;-<span class="st"> </span><span class="kw">ggplot</span>(est14.all.df, <span class="kw">aes</span>(Estimate)) +<span class="st"> </span><span class="kw">geom_histogram</span>(<span class="dt">bins =</span> <span class="dv">12</span>) +
<span class="st">  </span><span class="kw">facet_grid</span>(DataType +<span class="st"> </span>Parameter ~<span class="st"> </span>Quantity, <span class="dt">scales =</span> <span class="st">'free_x'</span>) +
<span class="st">  </span><span class="kw">geom_vline</span>(<span class="kw">aes</span>(<span class="dt">xintercept =</span> Value), <span class="dt">data =</span> trues14.all.df) +
<span class="st">  </span><span class="kw">theme_bw</span>() +<span class="st"> </span><span class="kw">scale_x_continuous</span>(<span class="dt">breaks =</span> <span class="kw">c</span>(<span class="fl">0.002</span>, <span class="fl">0.003</span>, <span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.3</span>))

g.est</code></pre>
</div>
<div id="example-10" class="section level3">
<h3>EXAMPLE 10</h3>
<p><code>estMC</code> Estimate strength of migratory connectivity incorporating uncertainty in estimates of breeding abundance (see estMC help file)</p>
</div>
<div id="example-11" class="section level3">
<h3>EXAMPLE 11</h3>
<p><code>estMC</code> Estimate strength of migratory connectivity incorporating detection heterogeneity (see estMC help file)</p>
</div>
<div id="example-12" class="section level3">
<h3>EXAMPLE 12</h3>
<p><code>estMC</code> Estimate strength of migratory connectivity incorporating location uncertainty</p>
<p>Estimates of MC may also be influenced by error in individual assignment to regions. Data types vary in location accuracy and precision, which are likely to influence the accuracy with which individuals are assigned to regions. We measured MC for bootstrapped data of birds tracked from breeding to non-breeding regions using light-level and GPS geolocation when 1) GPS location uncertainty was applied to all individuals, 2) GPS and light-level location uncertainty were applied to individuals with those devices, and 3) light-level location uncertainty was applied to all individuals. See Example 2 above and estMC help file.</p>
</div>
<div id="example-13-from-process-error-simulation-in-cohen-et-al.-in-press" class="section level3">
<h3>EXAMPLE 13 (from process error simulation in Cohen et al. in press)</h3>
<p><code>simMove</code> for measuring the influence of dispersal rates on MC</p>
<p>Long-distance dispersal occurs when individuals that originate or breed in one population do not return to the same population to breed the next year. To quantify the sensitivity of MC to dispersal, we used simulations in which dispersal probability between breeding regions varied from low to high to measure the sensitivity of MC to dispersal.</p>
<pre class="sourceCode r"><code class="sourceCode r">## Simulation ----
nBreeding &lt;-<span class="st"> </span><span class="dv">100</span>
nWintering &lt;-<span class="st"> </span><span class="dv">100</span>
breedingPos &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="kw">rep</span>(<span class="kw">seq</span>(-<span class="dv">99</span>, -<span class="dv">81</span>, <span class="dv">2</span>), <span class="dt">each=</span><span class="kw">sqrt</span>(nBreeding)),
                        <span class="kw">rep</span>(<span class="kw">seq</span>(<span class="dv">49</span>, <span class="dv">31</span>, -<span class="dv">2</span>), <span class="kw">sqrt</span>(nBreeding))), nBreeding, <span class="dv">2</span>)
winteringPos &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="kw">rep</span>(<span class="kw">seq</span>(-<span class="dv">79</span>, -<span class="dv">61</span>, <span class="dv">2</span>), <span class="dt">each=</span><span class="kw">sqrt</span>(nWintering)),
                         <span class="kw">rep</span>(<span class="kw">seq</span>(<span class="dv">9</span>, -<span class="dv">9</span>, -<span class="dv">2</span>), <span class="kw">sqrt</span>(nWintering))), nWintering, <span class="dv">2</span>)
<span class="kw">head</span>(breedingPos)
<span class="kw">tail</span>(breedingPos)
<span class="kw">head</span>(winteringPos)
<span class="kw">tail</span>(winteringPos)

breedDist &lt;-<span class="st"> </span><span class="kw">distFromPos</span>(breedingPos, <span class="st">'ellipsoid'</span>)
nonbreedDist &lt;-<span class="st"> </span><span class="kw">distFromPos</span>(winteringPos, <span class="st">'ellipsoid'</span>)

<span class="co"># Breeding Abundance</span>
breedingN &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">5000</span>, nBreeding)
breedingRelN &lt;-<span class="st"> </span>breedingN/<span class="kw">sum</span>(breedingN)

<span class="co"># Set up psi matrix</span>
o &lt;-<span class="st"> </span><span class="kw">optimize</span>(mlogitMC, <span class="dt">MC.in =</span> <span class="fl">0.25</span>, <span class="dt">origin.dist =</span> breedDist,
              <span class="dt">target.dist =</span> nonbreedDist, <span class="dt">origin.abund =</span> breedingRelN,
              <span class="dt">sample.size =</span> <span class="kw">sum</span>(breedingN),
              <span class="dt">interval =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">10</span>), <span class="dt">tol =</span> .Machine$double.eps^<span class="fl">0.5</span>)

slope &lt;-<span class="st"> </span>o$minimum
psi &lt;-<span class="st"> </span><span class="kw">mlogitMat</span>(slope, breedDist)

<span class="co"># Baseline strength of migratory connectivity</span>
MC &lt;-<span class="st"> </span><span class="kw">calcMC</span>(breedDist, nonbreedDist, breedingRelN, psi, <span class="kw">sum</span>(breedingN))
MC

<span class="co"># Other basic simulation parameters</span>

## Dispersal simulations---
<span class="kw">set.seed</span>(<span class="dv">1516</span>)

nYears &lt;-<span class="st"> </span><span class="dv">15</span>

nMonths &lt;-<span class="st"> </span><span class="dv">4</span> <span class="co"># Each season</span>

Drates &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">0.02</span>, <span class="fl">0.04</span>, <span class="fl">0.08</span>, <span class="fl">0.16</span>, <span class="fl">0.32</span>, <span class="fl">0.64</span>)    <span class="co">#rates of dispersal</span>

birdLocDisp &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">'list'</span>, <span class="kw">length</span>(Drates))

Disp.df  &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">Year=</span><span class="kw">rep</span>(<span class="dv">1</span>:nYears, <span class="kw">length</span>(Drates)),
                       <span class="dt">Rate=</span><span class="kw">rep</span>(Drates, <span class="dt">each =</span> nYears), <span class="dt">MC =</span> <span class="ot">NA</span>)

for(i in <span class="dv">1</span>:<span class="kw">length</span>(Drates)){
  <span class="kw">cat</span>(<span class="st">'Dispersal Rate'</span>, Drates[i], <span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)
  birdLocDisp[[i]] &lt;-<span class="st"> </span><span class="kw">simMove</span>(breedingN, 
                              breedDist, 
                              nonbreedDist, 
                              psi, 
                              nYears, 
                              nMonths,
                              <span class="dt">sumDispRate =</span> Drates[i])
  for(j in <span class="dv">1</span>:nYears){
    <span class="kw">cat</span>(<span class="st">'</span><span class="ch">\t</span><span class="st">Year'</span>, j, <span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)
    temp.results &lt;-<span class="st"> </span><span class="kw">calcPsiMC</span>(breedDist,
                              nonbreedDist,
                              breedingRelN,
                              birdLocDisp[[i]]$animalLoc,
                              <span class="dt">years=</span>j,
                              <span class="dt">verbose =</span> F)
    
    Disp.df$MC[j +<span class="st"> </span>(i -<span class="st"> </span><span class="dv">1</span>) *<span class="st"> </span>nYears] &lt;-<span class="st"> </span>temp.results$MC
  }
} <span class="co"># end i loop</span>

Disp.df$Year &lt;-<span class="st"> </span>Disp.df$Year -<span class="st"> </span><span class="dv">1</span> <span class="co">#just run once!</span>

<span class="kw">data.frame</span>(Disp.df, <span class="dt">roundMC =</span> <span class="kw">round</span>(Disp.df$MC, <span class="dv">2</span>), 
           <span class="dt">nearZero =</span> Disp.df$MC &lt;<span class="st"> </span><span class="fl">0.01</span>)


<span class="co"># Convert dispersal rates to probabilities of dispersing at least certain distance</span>
threshold &lt;-<span class="st"> </span><span class="dv">1000</span>
probFarDisp &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, nBreeding, <span class="kw">length</span>(Drates), <span class="dt">dimnames =</span> <span class="kw">list</span>(<span class="ot">NULL</span>, Drates))

for (i in <span class="dv">1</span>:<span class="kw">length</span>(Drates)) {
  for (k in <span class="dv">1</span>:nBreeding) {
    probFarDisp[k, i] &lt;-<span class="st"> </span>
<span class="st">      </span><span class="kw">sum</span>(birdLocDisp[[i]]$natalDispMat[k, <span class="kw">which</span>(breedDist[k, ]&gt;=<span class="st"> </span>threshold)])
  }
}

<span class="kw">summary</span>(probFarDisp)

<span class="co">#plot results</span>
\dontrun{
<span class="kw">require</span>(ggplot2)
<span class="kw">require</span>(ggthemes)

line_set=<span class="kw">c</span>(<span class="fl">0.5</span>, <span class="fl">0.75</span>, <span class="dv">1</span>, <span class="fl">1.25</span>, <span class="fl">1.75</span>, <span class="fl">2.25</span>)
<span class="kw">ggplot</span>(Disp.df, <span class="kw">aes</span>(<span class="dt">x=</span>Year, <span class="dt">y=</span>MC, <span class="dt">size=</span><span class="kw">as.factor</span>(Rate)))+
<span class="st"> </span><span class="kw">geom_line</span>()+
<span class="st"> </span><span class="kw">scale_size_manual</span>(<span class="dt">values=</span>line_set)+
<span class="st"> </span><span class="kw">labs</span>(<span class="dt">size=</span><span class="st">&quot;Dispersal Rate&quot;</span>)+
<span class="st"> </span><span class="kw">scale_y_continuous</span>(<span class="st">&quot;MC&quot;</span>, <span class="dt">limits=</span><span class="kw">c</span>(-.<span class="dv">005</span>, <span class="fl">0.26</span>), 
                    <span class="dt">breaks=</span><span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">0.05</span>, <span class="fl">0.1</span>, <span class="fl">0.15</span>, <span class="fl">0.2</span>, <span class="fl">0.25</span>))+
<span class="st"> </span><span class="kw">scale_x_continuous</span>(<span class="dt">breaks=</span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">9</span>, <span class="dv">12</span>, <span class="dv">15</span>))+
<span class="st"> </span><span class="kw">theme_bw</span>()+
<span class="st"> </span><span class="kw">theme</span>(<span class="dt">axis.title=</span><span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">16</span>, <span class="dt">face =</span><span class="st">&quot;bold&quot;</span>),
       <span class="dt">axis.text=</span><span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">14</span>),
       <span class="dt">panel.grid.major =</span> <span class="kw">element_line</span>(<span class="dt">color=</span><span class="st">&quot;grey90&quot;</span>),
       <span class="dt">panel.grid.major.x =</span> <span class="kw">element_blank</span>(),
       <span class="dt">legend.title=</span><span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">14</span>), 
       <span class="dt">legend.text=</span><span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">14</span>))
}</code></pre>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
