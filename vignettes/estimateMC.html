<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Jeffrey A. Hostetler, Michael T. Hallworth" />

<meta name="date" content="2018-07-03" />

<title>MigConnectivity package: some estMC function examples</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">‘MigConnectivity’ package: some estMC function examples</h1>
<h4 class="author"><em>Jeffrey A. Hostetler, Michael T. Hallworth</em></h4>
<h4 class="date"><em>2018-07-03</em></h4>



<p><code>estMC</code> estimates the strength of migratory connectivity (MC) with estimates of uncertainty. MC estimated either with transition probability estimates or individual assignments to regions from either tracking data or stable-isotopes. Uses re-sampling to measure MC uncertainty from RMark transition probability matrix estimates and/or JAGS relative abundance MCMC samples OR geolocator and/or GPS data OR stable-isotope assignments.</p>
<div id="estmc---estimate-strength-of-migratory-connectivity-incorporating-location-and-other-sampling-uncertainty" class="section level2">
<h2><code>estMC</code> - Estimate strength of migratory connectivity incorporating location and other sampling uncertainty</h2>
<p>Estimates of MC may also be influenced by error in individual assignment to regions. Data types vary in location accuracy and precision, which are likely to influence the accuracy with which individuals are assigned to regions.</p>
</div>
<div id="light-level-geolocator-gps" class="section level2">
<h2>Light-level geolocator / GPS</h2>
<p>To estimate MC and include location uncertainty the following data are needed:</p>
<ol style="list-style-type: decimal">
<li>A logical vector indicating the type of device the location estimates were derived from (GPS = FALSE, Light-level geolocator = TRUE)<br />
</li>
<li>Location Bias - a vector that has error estimates for both longitude and latitude<br />
</li>
<li>Location error - a variance, covariance matrix of longitude and latitude<br />
</li>
<li>Distance matrix between breeding and non-breeding regions<br />
</li>
<li>A shapefile of both breeding and non-breeding regions<br />
</li>
<li>The deployment locations and the ‘unknown’ locations derived from the tracking devices<br />
</li>
<li>The relative (or absolute) abundance within each region where the birds originate from (deployment regions)</li>
</ol>
<p>Below is a repeatable example for how to calculate location bias and location error using coordinates derived from light-level geolocators.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Load in projections</span>
<span class="kw">data</span>(<span class="st">&quot;projections&quot;</span>)

<span class="co"># Define deployment locations (winter) # </span>
captureLocations&lt;-<span class="kw">matrix</span>(<span class="kw">c</span>(<span class="op">-</span><span class="fl">77.93</span>,<span class="fl">18.04</span>,   <span class="co"># Jamaica</span>
                           <span class="op">-</span><span class="fl">80.94</span>,<span class="fl">25.13</span>,   <span class="co"># Florida</span>
                           <span class="op">-</span><span class="fl">66.86</span>,<span class="fl">17.97</span>),  <span class="co"># Puerto Rico</span>
                            <span class="dt">nrow=</span><span class="dv">3</span>, <span class="dt">ncol=</span><span class="dv">2</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>)

<span class="co"># Convert capture locations into SpatialPoints #</span>

CapLocs&lt;-sp<span class="op">::</span><span class="kw">SpatialPoints</span>(captureLocations,sp<span class="op">::</span><span class="kw">CRS</span>(projections<span class="op">$</span>WGS84))

<span class="co"># Project Capture locations # </span>

CapLocsM&lt;-sp<span class="op">::</span><span class="kw">spTransform</span>(CapLocs, sp<span class="op">::</span><span class="kw">CRS</span>(projections<span class="op">$</span>EquidistConic))

<span class="co"># Retrieve raw non-breeding locations from github </span>
<span class="co"># First grab the identity of the bird so we can loop through the files </span>
<span class="co"># For this example we are only interested in the error </span>
<span class="co"># around non-breeding locations </span>
<span class="co"># here we grab only the birds captured during the non-breeding season </span>
<span class="co"># Using paste0 for vignette formatting purposes</span>

winterBirds &lt;-<span class="st"> </span><span class="kw">dget</span>(<span class="kw">paste0</span>(<span class="st">&quot;https://raw.githubusercontent.com/&quot;</span>,
                    <span class="st">&quot;SMBC-NZP/MigConnectivity/master/&quot;</span>,
                    <span class="st">&quot;data-raw/GL_NonBreedingFiles/winterBirds.txt&quot;</span>))

<span class="co"># create empty list to store the location data #</span>
Non_breeding_files &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">'list'</span>,<span class="kw">length</span>(winterBirds))

<span class="co"># Get raw location data from Github #</span>
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(winterBirds)){
Non_breeding_files[[i]] &lt;-<span class="st"> </span><span class="kw">dget</span>(<span class="kw">paste0</span>(<span class="st">&quot;https://raw.githubusercontent.com/&quot;</span>,
                                        <span class="st">&quot;SMBC-NZP/MigConnectivity/master/data-raw/&quot;</span>,
                                        <span class="st">&quot;GL_NonBreedingFiles/NonBreeding_&quot;</span>,
                                        winterBirds[i],<span class="st">&quot;.txt&quot;</span>))
}

<span class="co"># Remove locations around spring Equinox and potential migration points</span>
<span class="co"># same NB time frame as Hallworth et al. 2015 </span>

<span class="co"># two steps because subset on shapefile doesn't like it in a single step</span>

Non_breeding_files &lt;-<span class="st"> </span><span class="kw">lapply</span>(Non_breeding_files,
                      <span class="dt">FUN =</span> <span class="cf">function</span>(x){
                      month &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(<span class="kw">format</span>(x<span class="op">$</span>Date,<span class="dt">format =</span> <span class="st">&quot;%m&quot;</span>))
                               x[<span class="kw">which</span>(month <span class="op">!=</span><span class="st"> </span><span class="dv">3</span> <span class="op">&amp;</span><span class="st"> </span>month <span class="op">!=</span><span class="st"> </span><span class="dv">4</span>),]})

   
Jam &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">9</span>)   <span class="co"># locations w/in list of winterBirds captured in Jamaica</span>
Fla &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">10</span><span class="op">:</span><span class="dv">12</span>) <span class="co"># locations w/in list of winterBirds in Florida</span>
PR &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">13</span><span class="op">:</span><span class="dv">16</span>)  <span class="co"># locations w/in list of winterBirds in Puerto Rico</span>

<span class="co"># Turn the locations into shapefiles #</span>

NB_GL &lt;-<span class="st"> </span><span class="kw">lapply</span>(Non_breeding_files, 
                <span class="dt">FUN =</span> <span class="cf">function</span>(x){
                  sp<span class="op">::</span><span class="kw">SpatialPoints</span>(<span class="kw">cbind</span>(x<span class="op">$</span>Longitude,x<span class="op">$</span>Latitude),
                                    sp<span class="op">::</span><span class="kw">CRS</span>(projections<span class="op">$</span>WGS84))})

<span class="co"># Project into UTM projection #</span>

NB_GLmeters &lt;-<span class="st"> </span><span class="kw">lapply</span>(NB_GL,
                      <span class="dt">FUN =</span> <span class="cf">function</span>(x){sp<span class="op">::</span><span class="kw">spTransform</span>(x,
                                          sp<span class="op">::</span><span class="kw">CRS</span>(projections<span class="op">$</span>EquidistConic))})

<span class="co"># Process to determine geolocator bias and variance-covariance in meters #</span>

<span class="co"># generate empty vector to store data #</span>
LongError&lt;-<span class="kw">rep</span>(<span class="ot">NA</span>,<span class="kw">length</span>(winterBirds)) 
LatError&lt;-<span class="kw">rep</span>(<span class="ot">NA</span>,<span class="kw">length</span>(winterBirds))  

<span class="co"># Calculate the error in longitude derived </span>
<span class="co"># from geolocators from the true capture location </span>

LongError[Jam] &lt;-<span class="st"> </span><span class="kw">unlist</span>(<span class="kw">lapply</span>(NB_GLmeters[Jam],
                         <span class="dt">FUN =</span> <span class="cf">function</span>(x){<span class="kw">mean</span>(x<span class="op">@</span>coords[,<span class="dv">1</span>]<span class="op">-</span>
<span class="st">                                                  </span>CapLocsM<span class="op">@</span>coords[<span class="dv">1</span>,<span class="dv">1</span>])}))

LongError[Fla] &lt;-<span class="st"> </span><span class="kw">unlist</span>(<span class="kw">lapply</span>(NB_GLmeters[Fla],
                         <span class="dt">FUN =</span> <span class="cf">function</span>(x){<span class="kw">mean</span>(x<span class="op">@</span>coords[,<span class="dv">1</span>]<span class="op">-</span>
<span class="st">                                                  </span>CapLocsM<span class="op">@</span>coords[<span class="dv">2</span>,<span class="dv">1</span>])}))

LongError[PR] &lt;-<span class="st"> </span><span class="kw">unlist</span>(<span class="kw">lapply</span>(NB_GLmeters[PR],
                        <span class="dt">FUN =</span> <span class="cf">function</span>(x){<span class="kw">mean</span>(x<span class="op">@</span>coords[,<span class="dv">1</span>]<span class="op">-</span>
<span class="st">                                                 </span>CapLocsM<span class="op">@</span>coords[<span class="dv">3</span>,<span class="dv">1</span>])}))

<span class="co"># Calculate the error in latitude derived from</span>
<span class="co"># geolocators from the true capture location </span>

LatError[Jam] &lt;-<span class="st"> </span><span class="kw">unlist</span>(<span class="kw">lapply</span>(NB_GLmeters[Jam],
                        <span class="dt">FUN =</span> <span class="cf">function</span>(x){<span class="kw">mean</span>(x<span class="op">@</span>coords[,<span class="dv">2</span>]<span class="op">-</span>
<span class="st">                                                 </span>CapLocsM<span class="op">@</span>coords[<span class="dv">1</span>,<span class="dv">2</span>])}))

LatError[Fla] &lt;-<span class="st"> </span><span class="kw">unlist</span>(<span class="kw">lapply</span>(NB_GLmeters[Fla],
                        <span class="dt">FUN =</span> <span class="cf">function</span>(x){<span class="kw">mean</span>(x<span class="op">@</span>coords[,<span class="dv">2</span>]<span class="op">-</span>
<span class="st">                                                 </span>CapLocsM<span class="op">@</span>coords[<span class="dv">2</span>,<span class="dv">2</span>])}))

LatError[PR] &lt;-<span class="st"> </span><span class="kw">unlist</span>(<span class="kw">lapply</span>(NB_GLmeters[PR],
                        <span class="dt">FUN =</span> <span class="cf">function</span>(x){<span class="kw">mean</span>(x<span class="op">@</span>coords[,<span class="dv">2</span>]<span class="op">-</span>
<span class="st">                                                 </span>CapLocsM<span class="op">@</span>coords[<span class="dv">3</span>,<span class="dv">2</span>])}))

<span class="co"># Get co-variance matrix for error of </span>
<span class="co"># known non-breeding deployment sites </span>

<span class="co"># lm does multivariate normal models if you give it a matrix dependent variable!</span>

geo.error.model &lt;-<span class="st"> </span><span class="kw">lm</span>(<span class="kw">cbind</span>(LongError,LatError) <span class="op">~</span><span class="st"> </span><span class="dv">1</span>) 

geo.bias &lt;-<span class="st"> </span><span class="kw">coef</span>(geo.error.model)
geo.vcov &lt;-<span class="st"> </span><span class="kw">vcov</span>(geo.error.model)</code></pre></div>
<p>We measured MC for bootstrapped data of birds tracked from breeding to non-breeding regions using light-level and GPS geolocation when 1) GPS location uncertainty was applied to all individuals, 2) GPS and light-level location uncertainty were applied to individuals with those devices, and 3) light-level location uncertainty was applied to all individuals.</p>
<p>Load location data that accompanies the <code>MigConnectivity</code> package. The location data are data from breeding Ovenbirds that were fit with Light-level geolocators or PinPoint-10 GPS tags.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(OVENdata) <span class="co"># Ovenbird </span>

<span class="kw">names</span>(OVENdata)
<span class="co">#&gt;  [1] &quot;geo.bias&quot;       &quot;geo.vcov&quot;       &quot;isGL&quot;           &quot;targetPoints&quot;  </span>
<span class="co">#&gt;  [5] &quot;originPoints&quot;   &quot;targetSites&quot;    &quot;originSites&quot;    &quot;originRelAbund&quot;</span>
<span class="co">#&gt;  [9] &quot;originDist&quot;     &quot;targetDist&quot;</span></code></pre></div>
<p>The figure below shows the two breeding regions (squares), and the three non-breeding regions (gray scale) used in Cohen et al. (<em>in press</em>) to estimate MC for Ovenbirds tracked with light-level geolocators and PinPoint-10 GPS tags.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">install.packages</span>(<span class="kw">c</span>(<span class="st">'rgeos'</span>, <span class="st">'shape'</span>, <span class="st">'raster'</span>, <span class="st">'maptools'</span>, <span class="st">'rgdal'</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(rgeos)
<span class="kw">library</span>(shape)
<span class="kw">library</span>(raster)
<span class="kw">library</span>(maptools)
<span class="kw">library</span>(rgdal)

<span class="kw">data</span>(wrld_simpl)

raster<span class="op">::</span><span class="kw">crs</span>(wrld_simpl)
<span class="co">#&gt; CRS arguments:</span>
<span class="co">#&gt;  +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0</span>

<span class="kw">par</span>(<span class="dt">mar=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>))
<span class="kw">plot</span>(OVENdata<span class="op">$</span>originSites,
     <span class="dt">xlim=</span><span class="kw">c</span>(raster<span class="op">::</span><span class="kw">extent</span>(OVENdata<span class="op">$</span>targetSites)[<span class="dv">1</span>],
            raster<span class="op">::</span><span class="kw">extent</span>(OVENdata<span class="op">$</span>targetSites)[<span class="dv">2</span>]),
     
     <span class="dt">ylim=</span><span class="kw">c</span>(raster<span class="op">::</span><span class="kw">extent</span>(OVENdata<span class="op">$</span>targetSites)[<span class="dv">3</span>],
            raster<span class="op">::</span><span class="kw">extent</span>(OVENdata<span class="op">$</span>originSites)[<span class="dv">4</span>]))

<span class="kw">plot</span>(OVENdata<span class="op">$</span>targetSites,
     <span class="dt">add =</span> <span class="ot">TRUE</span>,
     <span class="dt">col=</span><span class="kw">c</span>(<span class="st">&quot;gray70&quot;</span>,<span class="st">&quot;gray35&quot;</span>,<span class="st">&quot;gray10&quot;</span>))

wrld_simple&lt;-sp<span class="op">::</span><span class="kw">spTransform</span>(wrld_simpl,raster<span class="op">::</span><span class="kw">crs</span>(OVENdata<span class="op">$</span>targetSites))

<span class="kw">plot</span>(wrld_simple,<span class="dt">add=</span><span class="ot">TRUE</span>)</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>The following code demonstrates how to estimate MC using location data from light-level geolocators and PinPoint-10 GPS tags.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M&lt;-<span class="kw">estMC</span>(<span class="dt">isGL=</span>OVENdata<span class="op">$</span>isGL, <span class="co"># Logical vector: light-level geolocator(T)/GPS(F)</span>
         <span class="dt">geoBias =</span> OVENdata<span class="op">$</span>geo.bias, <span class="co"># Light-level geolocator location bias</span>
         <span class="dt">geoVCov =</span> OVENdata<span class="op">$</span>geo.vcov, <span class="co">#Light-level geolocator covariance matrix</span>
         <span class="dt">targetDist =</span> OVENdata<span class="op">$</span>targetDist, <span class="co"># Target location distance matrix</span>
         <span class="dt">originDist =</span> OVENdata<span class="op">$</span>originDist, <span class="co"># Origin location distance matrix</span>
         <span class="dt">targetSites =</span> OVENdata<span class="op">$</span>targetSites, <span class="co"># Non-breeding / target sites</span>
         <span class="dt">originSites =</span> OVENdata<span class="op">$</span>originSites, <span class="co"># Breeding / origin sites </span>
         <span class="dt">originPoints =</span> OVENdata<span class="op">$</span>originPoints, <span class="co"># Capture Locations </span>
         <span class="dt">targetPoints =</span> OVENdata<span class="op">$</span>targetPoints, <span class="co"># Target locations from devices</span>
         <span class="dt">originRelAbund =</span> OVENdata<span class="op">$</span>originRelAbund, <span class="co"># Origin relative abundances</span>
         <span class="dt">resampleProjection =</span> raster<span class="op">::</span><span class="kw">projection</span>(OVENdata<span class="op">$</span>targetPoints), 
         <span class="dt">verbose =</span> <span class="dv">0</span>,   <span class="co"># output options - see help ??estMC</span>
         <span class="dt">nSamples =</span> <span class="dv">10</span>) <span class="co"># This is set low for example </span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(M)
<span class="co">#&gt; List of 22</span>
<span class="co">#&gt;  $ sampleMC       : num [1:10] 0.761 0.353 0.774 0.656 0.683 ...</span>
<span class="co">#&gt;  $ samplePsi      : num [1:10, 1:2, 1:3] 0 0 0 0 0 0 0 0 0 0 ...</span>
<span class="co">#&gt;   ..- attr(*, &quot;dimnames&quot;)=List of 3</span>
<span class="co">#&gt;   .. ..$ : chr [1:10] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...</span>
<span class="co">#&gt;   .. ..$ : chr [1:2] &quot;NH&quot; &quot;MD&quot;</span>
<span class="co">#&gt;   .. ..$ : chr [1:3] &quot;Florida&quot; &quot;Cuba&quot; &quot;Hisp&quot;</span>
<span class="co">#&gt;  $ pointPsi       : num [1:2, 1:3] 0 0.4 0.174 0.6 0.826 ...</span>
<span class="co">#&gt;   ..- attr(*, &quot;dimnames&quot;)=List of 2</span>
<span class="co">#&gt;   .. ..$ : chr [1:2] &quot;NH&quot; &quot;MD&quot;</span>
<span class="co">#&gt;   .. ..$ : chr [1:3] &quot;Florida&quot; &quot;Cuba&quot; &quot;Hisp&quot;</span>
<span class="co">#&gt;  $ pointMC        : num 0.621</span>
<span class="co">#&gt;  $ meanMC         : num 0.67</span>
<span class="co">#&gt;  $ medianMC       : num 0.702</span>
<span class="co">#&gt;  $ seMC           : num 0.126</span>
<span class="co">#&gt;  $ simpleCI       : num [1:2] 0.353 0.774</span>
<span class="co">#&gt;  $ bcCI           : num [1:2] 0.353 0.76</span>
<span class="co">#&gt;  $ hpdCI          : num [1:2] 0.353 0.774</span>
<span class="co">#&gt;  $ simpleP        : NULL</span>
<span class="co">#&gt;  $ bcP            : NULL</span>
<span class="co">#&gt;  $ sampleCorr     : logi [1:10] NA NA NA NA NA NA ...</span>
<span class="co">#&gt;  $ pointCorr      : NULL</span>
<span class="co">#&gt;  $ meanCorr       : NULL</span>
<span class="co">#&gt;  $ medianCorr     : NULL</span>
<span class="co">#&gt;  $ seCorr         : NULL</span>
<span class="co">#&gt;  $ simpleCICorr   : NULL</span>
<span class="co">#&gt;  $ bcCICorr       : NULL</span>
<span class="co">#&gt;  $ inputSampleSize: int 39</span>
<span class="co">#&gt;  $ alpha          : num 0.05</span>
<span class="co">#&gt;  $ sigConst       : num 0</span>
<span class="co">#&gt;  - attr(*, &quot;class&quot;)= chr [1:2] &quot;estMC&quot; &quot;estMigConnectivity&quot;</span></code></pre></div>
</div>
<div id="stable-hydrogen-isotopes" class="section level2">
<h2>Stable-hydrogen isotopes</h2>
<p>To estimate MC and include location uncertainty the following data are needed:</p>
<ol style="list-style-type: decimal">
<li>Distance matrix between breeding and non-breeding regions<br />
</li>
<li>A shapefile of both breeding and non-breeding regions<br />
</li>
<li>The capture locations and the ‘unknown’ locations derived from the isoAssign function.<br />
</li>
<li>The relative (or absolute) abundance within each region where the birds were captured(capture regions)</li>
</ol>
<p>Below is a repeatable example for how to make isotope assignments, generate random point locations based on the assignments and to estimate the strength of migratory connectivity.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Load in projections</span>
<span class="kw">data</span>(<span class="st">&quot;projections&quot;</span>)
<span class="co"># Read in distribution for the Ovenbird</span>
OVENdist &lt;-<span class="st"> </span>raster<span class="op">::</span><span class="kw">shapefile</span>(<span class="st">&quot;data-raw/Spatial_Layers/OVENdist.shp&quot;</span>)
<span class="co"># subset out only the breeding distribution</span>
OVENdist &lt;-<span class="st"> </span>OVENdist[OVENdist<span class="op">$</span>ORIGIN<span class="op">==</span><span class="dv">2</span>,] <span class="co"># only breeding</span>
<span class="co"># assign coordinate reference system</span>
<span class="kw">crs</span>(OVENdist) &lt;-<span class="st"> </span>projections<span class="op">$</span>WGS84

<span class="co"># Read in stable-hydrogen isotope values </span>
OVENvals &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;data-raw/deltaDvalues.csv&quot;</span>)</code></pre></div>
<p>Read in raw isotope data collected from Ovenbirds from multiple locations.</p>
<p>Below is a brief walkthrough of how isotopes are typically used to assign breeding/molting origin. First, a ‘tissue’ or ‘feather’ isoscape is created either using ‘known-origin’ samples, or If those data are not available, values found in the literature. ‘Tissues’ or ‘feathers’ of ‘known-origin’ are used to generate the relationship between tissues values and the predicted isotope values in precipitation at sampling locations. The resulting relationship is then used to generate a ‘tissue’ or ‘feather’ isoscape that is then used to assign animals of unknown origin.</p>
<p>In the example below Ovenbirds were captured at known breeding locations in New Hampshire. The data are from <a href="https://github.com/MTHallworth/Manuscripts/blob/master/Hallworth_et_al_2013_AUK.pdf" target="_blank">Hallworth et al. 2013</a>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># THESE DATA NEED TO BE MOVED TO DATA-RAW FOLDER</span>
OVENknown &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;F:/IsotopeGLmanuscript/Feathers_for_Fractionation_Equation.csv&quot;</span>)</code></pre></div>
<div id="get-measured-annual-isotope-values-in-precipitation" class="section level3">
<h3>Get measured annual isotope values in precipitation</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">isomap &lt;-<span class="st"> </span><span class="kw">getIsoMap</span>(<span class="dt">element =</span> <span class="st">&quot;Hydrogen&quot;</span>,
                    <span class="dt">period =</span> <span class="st">&quot;Annual&quot;</span>)</code></pre></div>
<p>Once you have predicted hydrogen isotope in precipitation, one can extract the predicted value for each known capture location.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">predvals &lt;-<span class="st"> </span><span class="kw">extract</span>(isomap,<span class="kw">cbind</span>(OVENknown<span class="op">$</span>lon,OVENknown<span class="op">$</span>lat))</code></pre></div>
<p>Use the extracted predicted values in a linear model to determine the intercept, slope and standard deviation of the residuals to turn the hydrogen isoscape into a feather isoscape used for assignment.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># linear model</span>
iso.fit &lt;-<span class="st"> </span><span class="kw">lm</span>(OVENknown<span class="op">$</span>dD<span class="op">~</span>predvals)

<span class="co"># get the intercept and slope</span>
<span class="kw">coefficients</span>(iso.fit)

<span class="co"># get standard deviation of residuals</span>
<span class="kw">sd</span>(iso.fit<span class="op">$</span>residuals)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
b &lt;-<span class="st"> </span><span class="kw">isoAssign</span>(<span class="dt">isovalues =</span> OVENvals[,<span class="dv">2</span>],
               <span class="dt">isoSTD =</span> <span class="fl">13.73904</span>, <span class="co"># from above</span>
               <span class="dt">intercept =</span> <span class="op">-</span><span class="fl">19.2703031</span>,
               <span class="dt">slope =</span> <span class="fl">0.8079186</span>,
               <span class="dt">odds =</span> <span class="ot">NULL</span>,
               <span class="dt">restrict2Likely =</span> <span class="ot">TRUE</span>,
               <span class="dt">nSamples =</span> <span class="dv">1000</span>,
               <span class="dt">sppShapefile =</span> OVENdist,
               <span class="dt">assignExtent =</span> <span class="kw">c</span>(<span class="op">-</span><span class="dv">179</span>,<span class="op">-</span><span class="dv">60</span>,<span class="dv">15</span>,<span class="dv">89</span>),
               <span class="dt">element =</span> <span class="st">&quot;Hydrogen&quot;</span>,
               <span class="dt">surface =</span> <span class="ot">FALSE</span>,
               <span class="dt">period =</span> <span class="st">&quot;Annual&quot;</span>)
<span class="kw">Sys.time</span>()<span class="op">-</span>a</code></pre></div>
<p>We can now estimate the strength of MC from stable-hydrogen isotopes using the 1000 probable locations for each individual.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Make origin sites - birds were captured in Florida and Jamaica </span>
Countries &lt;-<span class="st"> </span><span class="kw">shapefile</span>(<span class="st">&quot;data-raw/Spatial_Layers/TM_WORLD_BORDERS-0.3.shp&quot;</span>)

JAM &lt;-<span class="st"> </span>Countries[Countries<span class="op">$</span>NAME <span class="op">==</span><span class="st"> &quot;Jamaica&quot;</span>,]
JAM &lt;-<span class="st"> </span><span class="kw">as</span>(JAM,<span class="st">&quot;SpatialPolygons&quot;</span>)

States &lt;-<span class="st"> </span><span class="kw">shapefile</span>(<span class="st">&quot;data-raw/Spatial_Layers/st99_d00.shp&quot;</span>)

FL &lt;-<span class="st"> </span>States[States<span class="op">$</span>NAME <span class="op">==</span><span class="st"> &quot;Florida&quot;</span>,]
FL &lt;-<span class="st"> </span>rgeos<span class="op">::</span><span class="kw">gUnaryUnion</span>(FL,<span class="dt">id =</span> FL<span class="op">$</span>STATE)

originSites &lt;-<span class="st"> </span><span class="kw">rbind</span>(JAM,FL)

<span class="co"># Distance between origin sites</span>
originDist &lt;-<span class="st"> </span><span class="kw">distFromPos</span>(rgeos<span class="op">::</span><span class="kw">gCentroid</span>(originSites,<span class="dt">byid =</span> <span class="ot">TRUE</span>)<span class="op">@</span>coords)

<span class="co"># Determine relative abundance based on number of birds captured</span>
ever &lt;-<span class="st"> </span><span class="kw">length</span>(<span class="kw">grep</span>(OVENiso[,<span class="dv">1</span>],<span class="dt">pattern =</span> <span class="st">&quot;EVER&quot;</span>))<span class="op">/</span>
<span class="st">  </span><span class="kw">length</span>(<span class="kw">grep</span>(OVENiso[,<span class="dv">1</span>], <span class="dt">pattern =</span> <span class="st">&quot;NH&quot;</span>, <span class="dt">invert =</span> <span class="ot">TRUE</span>))
jam &lt;-<span class="st"> </span><span class="kw">length</span>(<span class="kw">grep</span>(OVENiso[,<span class="dv">1</span>],<span class="dt">pattern =</span> <span class="st">&quot;JAM&quot;</span>))<span class="op">/</span>
<span class="st">  </span><span class="kw">length</span>(<span class="kw">grep</span>(OVENiso[,<span class="dv">1</span>],<span class="dt">pattern =</span> <span class="st">&quot;NH&quot;</span>, <span class="dt">invert =</span> <span class="ot">TRUE</span>))


originRelAbundance &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(<span class="kw">c</span>(jam,ever))

<span class="co"># Generate random capture locations within each polygon as capture locations </span>

<span class="kw">set.seed</span>(<span class="dv">12</span>)
originLongLat &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NA</span>,<span class="kw">c</span>(<span class="kw">length</span>(<span class="kw">grep</span>(OVENiso[,<span class="dv">1</span>],<span class="dt">pattern =</span> <span class="st">&quot;NH&quot;</span>, <span class="dt">invert =</span> <span class="ot">TRUE</span>)),<span class="dv">2</span>))
sample1 &lt;-<span class="st"> </span>sp<span class="op">::</span><span class="kw">spsample</span>(originSites[<span class="dv">1</span>, ], 
                        <span class="kw">length</span>(<span class="kw">grep</span>(OVENiso[, <span class="dv">1</span>], <span class="dt">pattern =</span> <span class="st">&quot;JAM&quot;</span>)),
                        <span class="dt">type =</span> <span class="st">&quot;random&quot;</span>)
sample2 &lt;-<span class="st"> </span>sp<span class="op">::</span><span class="kw">spsample</span>(originSites[<span class="dv">2</span>, ],
                        <span class="kw">length</span>(<span class="kw">grep</span>(OVENiso[, <span class="dv">1</span>],<span class="dt">pattern =</span> <span class="st">&quot;EVER&quot;</span>)),
                        <span class="dt">type =</span> <span class="st">&quot;random&quot;</span>)
originLongLat[<span class="kw">grep</span>(OVENiso[,<span class="dv">1</span>],<span class="dt">pattern =</span> <span class="st">&quot;JAM&quot;</span>),]&lt;-sample1<span class="op">@</span>coords
originLongLat[<span class="kw">grep</span>(OVENiso[,<span class="dv">1</span>],<span class="dt">pattern =</span> <span class="st">&quot;EVER&quot;</span>),]&lt;-sample2<span class="op">@</span>coords

originPoints &lt;-<span class="st"> </span>sp<span class="op">::</span><span class="kw">SpatialPoints</span>(originLongLat, 
                                  <span class="dt">proj4string =</span> sp<span class="op">::</span><span class="kw">CRS</span>(originSites<span class="op">@</span>proj4string<span class="op">@</span>projargs))

<span class="co"># Make sure all spatial layers have the same CRS (coordinate reference system)</span>
originSites &lt;-<span class="st"> </span>sp<span class="op">::</span><span class="kw">spTransform</span>(originSites,sp<span class="op">::</span><span class="kw">CRS</span>(projections<span class="op">$</span>WGS84))
originPoints &lt;-<span class="st"> </span>sp<span class="op">::</span><span class="kw">spTransform</span>(originPoints,sp<span class="op">::</span><span class="kw">CRS</span>(projections<span class="op">$</span>WGS84))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Sys.time</span>()
a &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
ovenMC &lt;-<span class="st"> </span><span class="kw">estMC</span>(<span class="dt">originRelAbund =</span> originRelAbund,
              <span class="dt">targetIntrinsic =</span> b,
              <span class="dt">originPoints =</span> originPoints,
              <span class="dt">originSites =</span> originSites,
              <span class="dt">originDist =</span> originDist,
              <span class="dt">verbose=</span><span class="dv">0</span>,
              <span class="dt">calcCorr=</span><span class="ot">TRUE</span>,
              <span class="dt">alpha =</span> <span class="fl">0.05</span>,
              <span class="dt">approxSigTest =</span> F,
              <span class="dt">sigConst =</span> <span class="dv">0</span>,
              <span class="dt">isIntrinsic =</span> <span class="ot">TRUE</span>) 
<span class="kw">Sys.time</span>()<span class="op">-</span>a
<span class="kw">Sys.time</span>()</code></pre></div>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
