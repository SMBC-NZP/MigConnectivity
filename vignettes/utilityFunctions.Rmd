---
title: '''MigConnectivity'' package'
author: "Jeffrey A. Hostetler, Michael T. Hallworth"
date: '`r Sys.Date()`'
output:
  rmarkdown::html_vignette: default
  rmarkdown::pdf_document: default
vignette: |
  %\VignetteIndexEntry{utility functions}
  %\usepackage[utf8]{inputenc}
  %\VignetteEngine{knitr::rmarkdown}
---
```{r, echo = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", tidy = FALSE)
```

### Utility functions for use in vignette    

`mlogitMat`: Calculates probability matrix based on exponential decline with distance

```{r}
mlogitMat <- function(slope, dist) {
       preMat <- exp(-slope/mean(dist)*dist)
       diag(preMat) <- 0
       nr <- nrow(dist)
       nc <- ncol(dist)
       outMat <- matrix(0, nr, nc)
  for (b in 1:nr) {
      outMat[b,] <- preMat[b,]/(1+sum(preMat[b, ]))
      outMat[b,b] <- 1 - sum(outMat[b, ])
  }
  return(outMat)
}
```

`mlogitMC`: Crude optimization function for developing migratory connectivity pattern based on migratory connectivity strength.  Uses same argument (origin.abund) for relative or absolute abundance.

```{r}
mlogitMC <- function(slope, 
                     MC.in, 
                     origin.dist,
                     target.dist,
                     origin.abund,
                     sample.size) {
  
    nBreeding <- nrow(origin.dist)
    nWintering <- nrow(target.dist)
    psi <- mlogitMat(slope, origin.dist)
    
  if (any(psi<0))
    
    return(5*slope^2)
    
  MC <- calcMC(origin.dist, 
               target.dist, 
               originRelAbund = origin.abund,
               psi, 
               sampleSize = sample.size)
  
  return((MC.in - MC)^2)
}
```

`calcStrengthInd`:  rM function for individuals

```{r}
calcStrengthInd <- function(originDist, 
                            targetDist, 
                            locations, 
                            resamp=1000, 
                            verbose = 0) {
nInd <- dim(locations)[1]
originDist2 <- targetDist2 <- matrix(0, nInd, nInd)
for (i in 1:(nInd-1)) {
 for (j in (i+1):nInd) {
      originDist2[i,j] <- originDist[locations[i,1,1,1], locations[j,1,1,1]]
      targetDist2[i,j] <- targetDist[locations[i,2,1,1], locations[j,2,1,1]]
      originDist2[j,i] <- originDist[locations[i,1,1,1], locations[j,1,1,1]]
      targetDist2[j,i] <- targetDist[locations[i,2,1,1], locations[j,2,1,1]]
    }
  }
return(ncf::mantel.test(originDist2, targetDist2, resamp=resamp, quiet = !verbose))
} 
```

`calcPsiMC`: Simple approach to estimate psi matrix (transition probabilities) and MC from simulated or real data (does not incorporate sampling uncertainty)

```{r}
calcPsiMC <- function(originDist, 
                      targetDist, 
                      originRelAbund, 
                      locations, 
                      years = 1, 
                      months = 1, 
                      verbose=F) {
  
  nOrigin <- nrow(originDist)
  nTarget <- nrow(targetDist)
  psiMat <- matrix(0, nOrigin, nTarget)
  nInd <- dim(locations)[1]
  nYears <- dim(locations)[3]
  nMonths <- dim(locations)[4]
for (i in 1:nInd) {
  if (i %% 1000 == 0 && verbose) #
      cat("Individual", i, "of", nInd, "\n")
    originMat <- locations[i, 1, years, months]
    targetMat <- locations[i, 2, years, months]
    bIndices <- which(!is.na(originMat))
    wIndices <- which(!is.na(targetMat))
  if (length(bIndices) && length(wIndices))
    for (bi in bIndices)
      for (wi in wIndices)
       psiMat[originMat[bi], targetMat[wi]] <- psiMat[originMat[bi], 
                                                      targetMat[wi]] + 1
  }
  psiMat <- apply(psiMat, 2, "/", rowSums(psiMat))
  MC <- calcMC(originDist, targetDist, psi = psiMat,
               originRelAbund = originRelAbund, sampleSize = nInd)
  return(list(psi=psiMat, MC=MC))
}
```   

`changeLocations`: transfers the simulated bird locations from the true populations to the researcher defined regions
```{r}
changeLocations <- function(animalLoc, 
                            breedingSiteTrans, 
                            winteringSiteTrans) {
  animalLoc[,1,,] <- breedingSiteTrans[animalLoc[,1,,]]
  animalLoc[,2,,] <- winteringSiteTrans[animalLoc[,2,,]]
  return(animalLoc)
}
```   


`simLocationError`: Simulates location error with defined bias and variance / covariance matrix

```{r}
simLocationError <- function(targetPoints, 
                             targetSites, 
              							 geoBias, 
              							 geoVCov, 
                             projection, 
              							 verbose = 0, 
              							 nSim = 1000) {

nAnimals <- length(targetPoints)
geoBias2 <- matrix(rep(geoBias, nSim), nrow=nSim, byrow=T)
target.sample <- rep(NA, nAnimals)
target.point.sample <- matrix(NA, nAnimals, 2)

for(i in 1:nAnimals){
  if (verbose > 0)
    cat('Animal', i, 'of', nAnimals)
  draws <- 0
  while (is.na(target.sample[i])) {
    draws <- draws + 1
    # Sample random point for each bird 
    # from parametric distribution of NB error
    point.sample <- sp::SpatialPoints(
                  MASS::mvrnorm(n=nSim, 
                  mu=cbind(targetPoints@coords[i,1],targetPoints@coords[i,2]),
                  Sigma=geoVCov)+
                  geoBias2,
                  sp::CRS(projection))
	  
    # filtered to stay in NB areas (land)
    target.sample0 <- sp::over(point.sample, targetSites)
    target.sample[i]<-target.sample0[!is.na(target.sample0)][1]
  }
	
  target.point.sample[i, ]<-point.sample[!is.na(target.sample0)][1]@coords
  if (verbose > 0)
    cat(' ', draws, 'draws\n')
}
  return(list(targetSample = target.sample, 
              targetPointSample = target.point.sample))
}
```

`toPoly`: Helper function to convert a string of XY coordinates of centroids to polygons

```{r}
toPoly <- function(siteCentroids,
                   projection.in = "+proj=longlat 
                                    +datum=WGS84 
                                    +no_defs 
                                    +ellps=WGS84 
                                    +towgs84=0,0,0",
                   projection.out = NA,
                   resolution = NA,
                   order.by.input = TRUE)
{
# This automatically sets the resolution so that all polygons touch and
# cover the entire surface. Alternatively the user can supply the 
# resolution of the raster cells in the units of the input projection 
#(projection.in) 
  
  if(is.na(resolution)){
     long <- unique(siteCentroids[,1])
     lat <- unique(siteCentroids[,2])
     long.res <- long[2]-long[1]
     lat.res <- lat[2]-lat[1]
     resolution <- c(long.res,long.res)
  }
  rast <- suppressWarnings(
          raster::rasterFromXYZ(cbind(cbind(siteCentroids),
                                (1:nrow(siteCentroids))),
                                 res = resolution,
                                  crs = projection.in))
  
  polys <- raster::rasterToPolygons(rast)
  
  # Give unique names to polygons #
  
  polys <- sp::SpatialPolygons(polys@polygons)
  raster::crs(polys)<-projection.in
  
  # Reorders the polygons to match that of the input #
  centers <- sp::SpatialPoints(siteCentroids, sp::CRS(projection.in))
  
  if(order.by.input){
  orders <- sp::over(centers,polys)
  polys <- polys[orders] 
  }
  sp::spChFIDs(polys,as.character(1:length(polys)))
  
  if(!is.na(projection.out)){
    polys <- sp::spTransform(polys,sp::CRS(projection.out))
  }
  
  return(polys)
}
```   
