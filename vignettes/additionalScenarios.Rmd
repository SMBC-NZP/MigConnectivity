---
title: '''MigConnectivity'' package'
author: "Jeffrey A. Hostetler, Michael T. Hallworth"
date: '`r Sys.Date()`'
output:
  rmarkdown::html_vignette: default
  rmarkdown::pdf_document: default
vignette: |
  %\VignetteIndexEntry{Additional scenarios}
  %\usepackage[utf8]{inputenc}
  %\VignetteEngine{knitr::rmarkdown}
---
```{r, echo = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", tidy = FALSE)
```
```{r, echo = FALSE, message = FALSE}
library(MigConnectivity)
```

## Additional Examples / Scenarios 
Below are some additional examples / scenarios that are discussed in the paper that accompanies the MigConnectivity package. 

<a href="https://doi.org/10.1111/2041-210X.12916" target=blank>Cohen, E. B., J.A. Hostetler, M.T. Hallworth, C.S. Rushing, T.S. Sillett, P.P. Marra. 2018. Quantifying the strength of migratory connectivity. Methods in Ecology and Evolution. 9(3) 513-524.</a> 


Calculate migratory connectivity for a range of input values 

Cohen et al. (2018) used simulation to assess the influence of the three data inputs needed to calculate MC, including:  
  
1. matrix of transition probabilities from breeding regions to non-breeding regions  
1. matrices of distances between breeding regions and between non-breeding regions  
1. relative abundance among breeding regions. 

Input value simulations included transition probabilities from four breeding to four non-breeding regions and relative abundance measured among breeding regions.

There were eight transition probability scenarios:

1. Full Mix 
1. Avoid One Site 
1. Full Connectivity 
1. Half Mix 
1. Low 
1. Medium 
1. One Site Preference 
1. Negative 


There were twelve spatial arrangement / distance scenarios:

1. Base distances, linear/ linear
1. Distance between breeding sites 2 and 3 doubled  
1. Distance between breeding sites 2 and 3 halved  
1. Distance between breeding sites 3 and 4 doubled  
1. Distance between breeding sites 3 and 4 halved  
1. Breeding sites on square grid/ winter linear
1. Distance between wintering sites 2 and 3 doubled  
1. Distance between wintering sites 2 and 3 halved  
1. Distance between wintering sites 3 and 4 doubled  
1. Distance between wintering sites 3 and 4 halved  
1. Breeding linear, Wintering sites on square grid  
1. Wintering and breeding on square grid

There were five relative breeding abundance scenarios:

1. Base, all equal  
1. Abundance at site B doubled  
1. Abundance at site B halved  
1. Abundance at site D doubled  
1. Abundance at site D halved  

First we calculate MC for the eight transition probability scenarios (with base spatial arrangement and relative abundance):
```{r}
nScenarios1 <- length(samplePsis) # samplePsis - comes with MigConnectivity pacakge

# Create vector of length nScenarios1
MC1 <- rep(NA, nScenarios1)

# Loop through the different senarios outlined above #
for (i in 1:nScenarios1) {
  MC1[i] <- calcMC(originDist = sampleOriginDist[[1]],
                 targetDist = sampleTargetDist[[1]],
                 psi = samplePsis[[i]],
                 originRelAbund = sampleOriginRelN[[1]])
}

# Give meaningful names to the MC1 vector
names(MC1) <- names(samplePsis)

# Print results 
round(MC1, 6)
```

Add the scenarios for the spatial arrangements that result in different distances between regions:

```{r}
nScenarios2 <- length(sampleOriginPos)

MC2 <- matrix(NA, nScenarios1, nScenarios2)

rownames(MC2) <- names(samplePsis)

colnames(MC2) <- names(sampleOriginPos)

for (i in 1:nScenarios1) {
  for (j in 1:nScenarios2) {
    MC2[i, j] <- calcMC(originDist = sampleOriginDist[[j]],
                      targetDist = sampleTargetDist[[j]],
                      psi = samplePsis[[i]],
                      originRelAbund = sampleOriginRelN[[1]])
  }
}

# Print results #
t(round(MC2, 4))
```

Another way of comparing results:
```{r}

MC.diff2 <- apply(MC2, 2, "-", MC2[ , 1])

t(round(MC.diff2, 4))
```

### Add the relative abundance breeding scenarios

Calculate MC across abundance and transition probability scenarios for breeding linear / winter linear arrangment: 
```{r}
nScenarios3 <- length(sampleOriginRelN)

MC3 <- matrix(NA, nScenarios1, nScenarios3)

rownames(MC3) <- names(samplePsis)
colnames(MC3) <- names(sampleOriginRelN)

for (i in 1:nScenarios1) {
for (j in 1) {
for (k in 1:nScenarios3) {
MC3[i, k] <- calcMC(originDist = sampleOriginDist[[j]],
                    targetDist = sampleTargetDist[[j]], 
                    psi = samplePsis[[i]],
                    originRelAbund = sampleOriginRelN[[k]])
}
}
}

t(round(MC3, 4)) # linear arrangement
```

Calculate MC across abundance and transition probability scenarios for breeding grid/ winter grid arrangement:
```{r}
MC4 <- matrix(NA, nScenarios1, nScenarios3)

rownames(MC4) <- names(samplePsis)
colnames(MC4) <- names(sampleOriginRelN)

for (i in 1:nScenarios1) {
for (j in nScenarios2) {
for (k in 1:nScenarios3) {
MC4[i, k] <- calcMC(originDist = sampleOriginDist[[j]],
                    targetDist = sampleTargetDist[[j]],
                    psi = samplePsis[[i]],
                    originRelAbund = sampleOriginRelN[[k]])
}
}
}

t(round(MC4, 4)) # grid arrangement
```

Calculate MC across abundance and transition probability scenarios for for breeding grid, winter linear arrangement
```{r}
MC5 <- matrix(NA, nScenarios1, nScenarios3)

rownames(MC5) <- names(samplePsis)
colnames(MC5) <- names(sampleOriginRelN)

for (i in 1:nScenarios1) {
for (j in 6) {
for (k in 1:nScenarios3) {
MC5[i, k] <- calcMC(originDist = sampleOriginDist[[j]],
                    targetDist = sampleTargetDist[[j]], 
                    psi = samplePsis[[i]], 
                    originRelAbund = sampleOriginRelN[[k]])
}
}
}

t(round(MC5, 4)) # breeding grid, winter linear arrangement
```

###EXAMPLES 5-12 (from sampling regime simulations in Cohen et al. 2018)

Simulation was used to assess the influence of biased or incomplete sampling on the measurement of MC. Below, we measure the influence of several potential sources of sampling error:  

1. Incorrect grouping of seasonal ranges into regions
1. Sampling not proportional to abundance
1. Migratory connectivity strength varies across a range
1. Low sample size
1. Uncertainty in assignments to regions from tracking data
1. Uncertainty in estimates of abundance
1. Heterogeneity in detection among regions from mark re-encounter data

We also demonstrate how to propagate sampling uncertainty into measurement of MC using a combination of parametric and non-parametric bootstrapping. For most simulations, we compare MC to the results of a distance-based correlation coefficient (Mantel correlation; rM) that does not incorporate relative abundance but has been used as a measure of migratory connectivity.

###EXAMPLE 5

Sampling regime 1 of 3

Researchers divide populations differently than reality
Delineation of seasonal ranges into regions

   I) Breeding range divided along equal longitudinal breaks into ten regions
   II) Non-breeding range divided along equal longitudinal breaks into ten regions
   III) Breeding and non-breeding ranges divided along equal longitudinal breaks into ten regions
   IV) Breeding range divided along the longitudinal and latitudinal midpoint into four regions
   V) Non-breeding range divided along the longitudinal and latitudinal midpoint into four regions
   VI) Breeding range divided along the longitudinal and latitudinal midpoint into four regions and
      non-breeding range divided along equal longitudinal breaks into ten regions
   VII) Breeding range divided along equal longitudinal breaks into ten regions and
      non-breeding range divided along the longitudinal and latitudinal midpoint into four regions

```{r, eval=FALSE}
#Run functions and parameters above first
set.seed(75)

scenarios14 <- c("Base", 
                 "Breeding10",
                 "Wintering10",
                 "Breeding10Wintering10",
                 "Breeding4",
                 "Wintering4",
                 "Breeding4Wintering10",
                 "Breeding10Wintering4",
                 "Breeding4Wintering4",
                 "CentroidSampleBreeding10",
                 "CentroidSampleBreeding10Wintering10",
                 "CentroidSampleBreeding10Wintering4",
                 "CentroidSampleBreeding4",
                 "CentroidSampleBreeding4Wintering10",
                 "CentroidSampleBreeding4Wintering4")

# Each element is for a scenario (see above 1-8), transferring from natural 
# breeding populations to defined ones
breedingSiteTrans14 <- list(1:nBreeding, 
                           rep(1:10, each=10), 
                           1:nBreeding, 
                           rep(1:10, each=10), 
                           c(rep(1:2, 5, each=5), rep(3:4, 5, each=5)),
                           1:nBreeding, 
                           c(rep(1:2, 5, each=5), rep(3:4, 5, each=5)),
                           rep(1:10, each=10),
                           c(rep(1:2, 5, each=5), rep(3:4, 5, each=5)),
                           rep(1:10, each=10), 
                           rep(1:10, each=10), 
                           rep(1:10, each=10),
                           c(rep(1:2, 5, each=5), rep(3:4, 5, each=5)),
                           c(rep(1:2, 5, each=5), rep(3:4, 5, each=5)),
                           c(rep(1:2, 5, each=5), rep(3:4, 5, each=5)))

# Same for non-breeding populations
winteringSiteTrans14 <- list(1:nWintering,
                             1:nWintering,
                             rep(1:10, each=10),
                             rep(1:10, each=10),
                             1:nWintering,
                             c(rep(1:2, 5, each=5), rep(3:4, 5, each=5)),
                             rep(1:10, each=10),
                             c(rep(1:2, 5, each=5), rep(3:4, 5, each=5)),
                             c(rep(1:2, 5, each=5), rep(3:4, 5, each=5)),
                             1:nWintering,
                             rep(1:10, each=10),
                             c(rep(1:2, 5, each=5), rep(3:4, 5, each=5)),
                             1:nWintering,
                             rep(1:10, each=10),
                             c(rep(1:2, 5, each=5), rep(3:4, 5, each=5)))

# Examine the transfers in matrix form
#lapply(breedingSiteTrans14, matrix, nrow=10, ncol=10)
#lapply(winteringSiteTrans14, matrix, nrow=10, ncol=10)

#positions of the human defined populations
breedingPos14 <- list(breedingPos,
                      rowsum(breedingPos, rep(1:10, each=10))/10,
                      breedingPos,
                      rowsum(breedingPos, rep(1:10, each=10))/10,
                      rowsum(breedingPos, c(rep(1:2, 5, each=5),
                                            rep(3:4, 5, each=5)))/25,
                      breedingPos, 
                      rowsum(breedingPos, c(rep(1:2, 5, each=5),
                                            rep(3:4, 5, each=5)))/25,
                      rowsum(breedingPos, rep(1:10, each=10))/10,
                      rowsum(breedingPos, c(rep(1:2, 5, each=5),
                                            rep(3:4, 5, each=5)))/25,
                      rowsum(breedingPos, rep(1:10, each=10))/10,
                      rowsum(breedingPos, rep(1:10, each=10))/10,
                      rowsum(breedingPos, rep(1:10, each=10))/10,
                      rowsum(breedingPos, c(rep(1:2, 5, each=5),
                                            rep(3:4, 5, each=5)))/25,
                      rowsum(breedingPos, c(rep(1:2, 5, each=5),
                                            rep(3:4, 5, each=5)))/25,
                      rowsum(breedingPos, c(rep(1:2, 5, each=5),
                                            rep(3:4, 5, each=5)))/25)

winteringPos14 <- list(winteringPos,
                       winteringPos,
                       rowsum(winteringPos, rep(1:10, each=10))/10,
                       rowsum(winteringPos, rep(1:10, each=10))/10,
                       winteringPos, 
                       rowsum(winteringPos, c(rep(1:2, 5, each=5),
                                              rep(3:4, 5, each=5)))/25,
                       rowsum(winteringPos,rep(1:10, each=10))/10,
                       rowsum(winteringPos, c(rep(1:2, 5, each=5),
                                              rep(3:4, 5, each=5)))/25,
                       rowsum(winteringPos, c(rep(1:2, 5, each=5),
                                              rep(3:4, 5, each=5)))/25,
                       winteringPos,
                       rowsum(winteringPos, rep(1:10, each=10))/10,
                       rowsum(winteringPos, c(rep(1:2, 5, each=5),
                                              rep(3:4, 5, each=5)))/25,
                       winteringPos,
                       rowsum(winteringPos, rep(1:10, each=10))/10,
                       rowsum(winteringPos, c(rep(1:2, 5, each=5),
                                              rep(3:4, 5, each=5)))/25)


# Calculate distances between defined breeding populations
breedDist14 <- lapply(breedingPos14, distFromPos, surface = 'ellipsoid')

# Calculate distances between defined non-breeding populations
nonbreedDist14 <- lapply(winteringPos14, distFromPos, surface = 'ellipsoid')

# Numbers of defined populations
nBreeding14 <- c(100, 10, 100, 10, 4, 100, 4, 10, 4, 10, 10, 10, 4, 4, 4)

nWintering14 <- c(100, 100, 10, 10, 100, 4, 10, 4, 4, 100, 10, 4, 100, 10, 4)

# Relative abundance by scenario and breeding population
breedingRelN14 <- lapply(nBreeding14, function(x) rep(1/x, x))

MC14 <- 0.25 # Same for all scenarios in this set

nSample14 <- 1000 # Total number sampled per simulation

# How many sampled from each natural population (sampling scenarios separate 
# from definition scenarios)

sampleBreeding14 <- list(round(breedingRelN14[[1]]*nSample14),
                         c(rep(0, 22), round(breedingRelN14[[5]][1]*nSample14),
                           rep(0, 4), round(breedingRelN14[[5]][2]*nSample14),
                           rep(0, 44), round(breedingRelN14[[5]][3]*nSample14),
                           rep(0, 4), round(breedingRelN14[[5]][4]*nSample14),
                           rep(0, 22)),
                         rep(c(rep(0, 4), 
                             rep(round(breedingRelN14[[2]][1]*nSample14/2), 2),
                             rep(0, 4)), 10))

# for the baseline use the simulation from above, sims

animalLoc14base <- sims$animalLoc


# Number of scenarios and number of simulations to run
nScenarios14 <- length(breedingSiteTrans14)
nSims14 <- 100

# Connections between scenarios and sampling regimes
scenarioToSampleMap14 <- c(rep(1, 9), rep(3, 3), rep(2, 3))

# Set up data structures for storing results
animalLoc14 <- vector("list", nScenarios14) #making an empty list to fill

compare14 <- data.frame(Scenario = c("True", scenarios14),
                        MC = c(MC14, rep(NA, nScenarios14)), 
                        Mantel = c(MC14, rep(NA, nScenarios14)))

compare14.array <- array(NA, c(nSims14, nScenarios14, 2), dimnames = 
                           list(1:nSims14,
                           scenarios14,
                           c("MC", "Mantel")))

results14 <- vector("list", nScenarios14)

# Run simulations
for (sim in 1:nSims14) {
  cat("Simulation", sim, "of", nSims14, '\n')
  sim14 <- lapply(sampleBreeding14, 
                  simMove, 
                  breedingDist = breedDist14[[1]],
                  winteringDist=nonbreedDist14[[1]], 
                  psi=psi, 
                  nYears=nYears,
                  nMonths=nMonths)
  
  for (i in 1:nScenarios14) {
   cat("\tScenario", i, "\n")
   animalLoc14[[i]]<-changeLocations(
     sim14[[scenarioToSampleMap14[i]]]$animalLoc,
                                     breedingSiteTrans14[[i]], 
                                     winteringSiteTrans14[[i]])
      
   results14[[i]] <- calcPsiMC(breedDist14[[i]], nonbreedDist14[[i]],
                               animalLoc14[[i]], 
                               originRelAbund = breedingRelN14[[i]], 
                               verbose = F)
      
   compare14.array[sim, i, 'MC'] <- results14[[i]]$MC
      
   compare14.array[sim,i,'Mantel']<-calcStrengthInd(breedDist14[[1]],
                                                    nonbreedDist14[[1]],
                                   sim14[[scenarioToSampleMap14[i]]]$animalLoc,
                                                    resamp=0)$correlation
  }
}

# Compute means for each scenario
compare14$MC[1:nScenarios14 + 1] <- apply(compare14.array[,,'MC'], 2, mean)
compare14$Mantel[1:nScenarios14 + 1] <- apply(compare14.array[,,'Mantel'], 2, 
                                              mean)

compare14 <- transform(compare14, MC.diff=MC - MC[1], 
                       Mantel.diff=Mantel - Mantel[1])
compare14

```
###EXAMPLE 6

Sampling regime 2 of 3

Researchers divide populations differently than reality PLUS  
Different distributions of sampling animals across breeding range  PLUS  
Sample sizes don't always match relative abundances PLUS  
Compare our approach and simple Mantel approach   

1.  Base (10 years, uneven abundances but matches sampling)
1.  Breeding pops divided into 4 squares, sample across breeding range 
1.  Breeding pops divided into 4 squares, sample at centroid of each square
1.  Sampling high in low abundance populations plus base
1.  Scenarios 2 plus 4
1.  Scenarios 3 plus 4  

```{r eval = FALSE}
set.seed(75)

# Transfer between true populations and researcher defined ones (only for
# breeding, as not messing with winter populations here)

breedingSiteTrans15 <- list(1:100,
                            c(rep(1:2, 5, each=5), rep(3:4, 5, each=5)),
                            c(rep(1:2, 5, each=5), rep(3:4, 5, each=5)), 
                            1:100,
                            c(rep(1:2, 5, each=5), rep(3:4, 5, each=5)),
                            c(rep(1:2, 5, each=5), rep(3:4, 5, each=5)))

nScenarios15 <- length(breedingSiteTrans15)

nSims15 <- 100

# Basing positions of researcher defined breeding populations on above
breedingPos15 <- list(breedingPos, 
                      breedingPos14[[5]],
                      breedingPos14[[5]], 
                      breedingPos,
                      breedingPos14[[5]], 
                      breedingPos14[[5]])

winteringPos15 <- rep(list(winteringPos), nScenarios15)

breedDist15 <- lapply(breedingPos15, distFromPos)

nonbreedDist15 <- lapply(winteringPos15, distFromPos)

nBreeding15 <- rep(c(100, 4, 4), 2)

nWintering15 <- rep(100, nScenarios15)

# Highest abundance in lower right corner, lowest in top left
# Making symmetrical

breedingN15base <- rep(NA, 100)
for (i in 1:10) #row
  for (j in 1:10)  #column
    breedingN15base[i+10*(j-1)] <- 500 + 850*i*j

sum(breedingN15base)

# For researcher defined populations
breedingN15 <- lapply(breedingSiteTrans15, rowsum, x=breedingN15base) 

breedingRelN15 <- lapply(breedingN15, "/", sum(breedingN15base))

nSample15 <- 1000 # Total number sampled per simulation

# Number sampled per natural population
sampleBreeding15 <- list(round(breedingRelN15[[1]]*nSample15),
                         c(rep(0, 22), round(breedingRelN15[[3]][1]*nSample15),
                           rep(0, 4), round(breedingRelN15[[3]][2]*nSample15),
                           rep(0, 44), round(breedingRelN15[[3]][3]*nSample15),
                           rep(0, 4), round(breedingRelN15[[3]][4]*nSample15),
                           rep(0, 22)),
                         round(breedingRelN15[[1]]*nSample15)[100:1],
                         c(rep(0, 22), round(breedingRelN15[[3]][1]*nSample15),
                           rep(0, 4), round(breedingRelN15[[3]][2]*nSample15),
                           rep(0, 44), round(breedingRelN15[[3]][3]*nSample15),
                           rep(0, 4), round(breedingRelN15[[3]][4]*nSample15),
                           rep(0, 22))[100:1])

# Set up psi matrix
o15 <- optimize(mlogitMC, MC.in = 0.25, origin.dist = breedDist15[[1]],
                target.dist = nonbreedDist15[[1]],
                origin.abund = breedingN15[[1]]/sum(breedingN15[[1]]),
                sample.size = sum(breedingN15[[1]]),
                interval = c(0,10),
                tol = .Machine$double.eps^0.5)

slope15 <- o15$minimum

psi15 <- mlogitMat(slope15, breedDist15[[1]])

# Baseline strength of migratory connectivity
MC15 <- calcMC(originDist = breedDist15[[1]], 
               targetDist = nonbreedDist15[[1]],
               psi = psi15,
               originRelAbund = breedingN15[[1]]/sum(breedingN15[[1]]),
               sampleSize = sum(breedingN15[[1]]))

# Run sampling regimes
scenarioToSampleMap15 <- c(1, 1, 2, 3, 3, 4)

animalLoc15 <- vector("list", nScenarios15)

results15 <- vector("list", nScenarios15)

compare15 <- data.frame(Scenario = c("True", 
                                     "Base", 
                                     "Breeding4",
                                     "CentroidSampleBreeding4",
                                     "BiasedSample", 
                                     "BiasedSampleBreeding4",
                                     "BiasedCentroidSampleBreeding4"),
                        MC = c(MC15, rep(NA, nScenarios15)), 
                        Mantel = c(MC15, rep(NA, nScenarios15)))

compare15.array <- array(NA, c(nSims15, nScenarios15, 2),
                         dimnames = list(1:nSims15,
                                    c("Base", "Breeding4", 
                                      "CentroidSampleBreeding4",
                                      "BiasedSample", "BiasedSampleBreeding4",
                                      "BiasedCentroidSampleBreeding4"),
                                    c("MC", "Mantel")))


for (sim in 1:nSims15) {
  cat("Simulation", sim, "of", nSims15, '\n')
  
  sim15 <- lapply(sampleBreeding15, 
                  simMove, 
                  breedingDist = breedDist15[[1]],
                  winteringDist=nonbreedDist15[[1]],
                  psi=psi15,
                  nYears=nYears,
                  nMonths=nMonths)
  
for (i in 1:nScenarios15) {
  cat("\tScenario", i, "\n")
    animalLoc15[[i]] <- changeLocations(
                        animalLoc=sim15[[scenarioToSampleMap15[i]]]$animalLoc,
                        breedingSiteTrans = breedingSiteTrans15[[i]],
                        winteringSiteTrans = 1:nWintering15[i])
    
    results15[[i]] <- calcPsiMC(originDist = breedDist15[[i]], 
                                targetDist = nonbreedDist15[[i]],
                                originRelAbund = breedingRelN15[[i]],
                                locations = animalLoc15[[i]], 
                                verbose = F)
    
compare15.array[sim, i, 'MC'] <- results15[[i]]$MC

compare15.array[sim, i, 'Mantel'] <- calcStrengthInd(breedDist15[[1]],
                                                     nonbreedDist15[[1]],
                                   sim15[[scenarioToSampleMap15[i]]]$animalLoc,
                                                    resamp=0)$correlation
  }
}

compare15$MC[1:nScenarios15+1] <- apply(compare15.array[,,'MC'], 2, mean, 
                                        na.rm = TRUE)

compare15$Mantel[1:nScenarios15+1] <- apply(compare15.array[,,'Mantel'], 2,
                                            mean, na.rm = TRUE)
compare15 <- transform(compare15, MC.diff=MC - MC[1], 
                       Mantel.diff=Mantel - Mantel[1],
                       MC.prop=MC/MC[1],  
                       Mantel.prop=Mantel/Mantel[1])


compare15a <- as.matrix(compare15[1 + 1:nScenarios15, 
                                  c("MC", "MC.diff", "Mantel", "Mantel.diff")])

rownames(compare15a) <- compare15$Scenario[1 + 1:nScenarios15]
```

###EXAMPLE 7
Sampling regime 3 of 3
Researchers divide populations differently than reality (simulations) PLUS
Different distributions of sampled animals across breeding range PLUS
Sample sizes don't always match relative abundances PLUS
Compare our approach and simple Mantel approach PLUS
MC not same across subsections of range   

1.  Base (uneven MC (0.15 for NW breeding, 0.3 for SW, 0.45 for NE, and 0.6 for SE), uneven abundances (lowest in NW, highest in SE), sampling proportional to abundance
1.  Breeding pops divided into 4 squares, sample across breeding range
1.  Breeding pops divided into 4 squares, sample at centroid of each square
1.  Sampling high in low abundance populations
1.  Scenarios 2 plus 4
1.  Scenarios 3 plus 4  

```{r eval = FALSE}
set.seed(75)

# Transfer between true populations and researcher defined ones
# (only for breeding, as not messing with winter populations here)
breedingSiteTrans16 <- list(1:100, c(rep(1:2, 5, each=5), rep(3:4, 5, each=5)),
                            c(rep(1:2, 5, each=5), rep(3:4, 5, each=5)), 1:100,
                            c(rep(1:2, 5, each=5), rep(3:4, 5, each=5)),
                            c(rep(1:2, 5, each=5), rep(3:4, 5, each=5)))

#lapply(breedingSiteTrans16, matrix, nrow=10, ncol=10)

nScenarios16 <- length(breedingSiteTrans16)

nSims16 <- 100

# Basing positions of researcher defined breeding populations on above
breedingPos16 <- breedingPos15
winteringPos16 <- winteringPos15

breedDist16 <- breedDist15
nonbreedDist16 <- nonbreedDist15
nBreeding16 <- nBreeding15
nWintering16 <- rep(100, nScenarios16)

# Highest abundance in lower right corner, lowest in top left
# In fact basing on distance from top left population

breedingN16base <- breedingN15base
breedingN16 <- breedingN15
breedingRelN16 <- lapply(breedingN16, "/", sum(breedingN16base))

# Set up psi matrix
# Each quadrant of breeding range has different MC

MC.levels16 <- seq(0.15, 0.6, 0.15)

nLevels16 <- 4

psi16 <- matrix(NA, nBreeding16[1], nWintering16[1])


for (i in 1:nLevels16) {
  cat("MC", MC.levels16[i])
  # Find a psi matrix that produces the given MC (for whole species)
  o16a <- optimize(mlogitMC, MC.in = MC.levels16[i],
                   origin.dist = breedDist16[[1]],
                   target.dist = nonbreedDist16[[1]],
                   origin.abund = breedingN16[[1]]/sum(breedingN16[[1]]),
                   sample.size = sum(breedingN16[[1]]),
                   interval=c(0,10), tol=.Machine$double.eps^0.5)
  
  slope16a <- o16a$minimum
  
  cat(" slope", slope16a, "\n")
  
  psi16a <- mlogitMat(slope16a, breedDist16[[1]])
  
  # Then use the rows of that psi matrix only for the one breeding quadrant
  rows <- 50*(i %/% 3) + rep(1:5, 5) + rep(seq(0, 40, 10), each=5) + 
    ((i-1) %% 2) * 5
  psi16[rows, ] <- psi16a[rows, ]
}


# Baseline strength of migratory connectivity
MC16 <- calcMC(originDist = breedDist16[[1]],
               targetDist = nonbreedDist16[[1]], 
               psi = psi16,
               originRelAbund = breedingN16[[1]]/sum(breedingN16[[1]]),
               sampleSize = sum(breedingN16[[1]]))


# Set up sampling regimes (different number than number of scenarios)
nSample16 <- 1000
sampleBreeding16 <- list(round(breedingRelN16[[1]]*nSample16),
                         c(rep(0, 22), round(breedingRelN16[[3]][1]*nSample16),
                           rep(0, 4), round(breedingRelN16[[3]][2]*nSample16),
                           rep(0, 44), round(breedingRelN16[[3]][3]*nSample16),
                           rep(0, 4), round(breedingRelN16[[3]][4]*nSample16),
                           rep(0, 22)),
                         round(breedingRelN16[[1]]*nSample16)[100:1],
                         c(rep(0, 22), round(breedingRelN16[[3]][1]*nSample16),
                           rep(0, 4), round(breedingRelN16[[3]][2]*nSample16),
                           rep(0, 44), round(breedingRelN16[[3]][3]*nSample16),
                           rep(0, 4), round(breedingRelN16[[3]][4]*nSample16),
                           rep(0, 22))[100:1])

sapply(sampleBreeding16, sum)

# Run sampling regimes
scenarioToSampleMap16 <- c(1, 1, 2, 3, 3, 4)
animalLoc16 <- vector("list", nScenarios16)
results16 <- vector("list", nScenarios16)
compare16 <- data.frame(Scenario = c("True",
                                     "Base",
                                     "Breeding4",
                                     "CentroidSampleBreeding4", 
                                     "BiasedSample",
                                     "BiasedSampleBreeding4",
                                     "BiasedCentroidSampleBreeding4"),
                        MC = c(MC16, rep(NA, nScenarios16)),
                        Mantel = c(MC16, rep(NA, nScenarios16)))

compare16.array <- array(NA, c(nSims16, nScenarios16, 2), 
                         dimnames = list(1:nSims16,
                                         c("Base", "Breeding4",
                                           "CentroidSampleBreeding4",
                                           "BiasedSample",
                                           "BiasedSampleBreeding4",
                                           "BiasedCentroidSampleBreeding4"),
                                         c("MC", "Mantel")))

set.seed(80)
for (sim in 1:nSims16) {
  cat("Simulation", sim, "of", nSims16, '\n')
  
  sim16 <- lapply(sampleBreeding16, simMove, breedingDist = breedDist16[[1]],
                  winteringDist=nonbreedDist16[[1]], psi=psi16, nYears=nYears,
                  nMonths=nMonths)
  
for (i in 1:nScenarios16) {
  cat("\tScenario", i, "\n")
  animalLoc16[[i]]<-changeLocations(sim16[[scenarioToSampleMap16[i]]]$animalLoc,
                                      breedingSiteTrans16[[i]], 
                                      1:nWintering16[i])
    
  results16[[i]] <- calcPsiMC(originDist = breedDist16[[i]],
                              targetDist = nonbreedDist16[[i]],
                              locations = animalLoc16[[i]],
                              originRelAbund = breedingRelN16[[i]],
                              verbose = FALSE)
    
compare16.array[sim, i, 'MC'] <- results16[[i]]$MC
    
compare16.array[sim, i, 'Mantel'] <- calcStrengthInd(breedDist16[[1]],
                                                         nonbreedDist16[[1]],
                                   sim16[[scenarioToSampleMap16[i]]]$animalLoc,
                                                         resamp=0)$correlation
  }
}

compare16$MC[1:nScenarios16+1] <- apply(compare16.array[,,'MC'], 2, mean, na.rm = TRUE)

compare16$Mantel[1:nScenarios16+1] <- apply(compare16.array[,,'Mantel'], 2, 
                                            mean, na.rm = TRUE)

compare16 <- transform(compare16, MC.diff=MC - MC[1], 
                       Mantel.diff=Mantel - Mantel[1])

compare16a <- as.matrix(compare16[1 + 1:nScenarios16, c('MC','MC.diff',
                                                        "Mantel",
                                                        "Mantel.diff")])

rownames(compare16a) <- compare16$Scenario[1 + 1:nScenarios16]
```


###EXAMPLE 8
`estMC` Estimate strength of migratory connectivity incorporating uncertainty from limited sample size (no other sampling error).  Here we simulated data using the 13th scenario from example 5 above ("CentroidSampleBreeding4"; make sure you run example 5 code before running this section).  We changed the total sample size from 1000 to 100 animals and the total abundance from 50000 to 2500 animals.  

```{r, eval = FALSE}
# Load in projections
data("projections")

set.seed(75)
capLocs14 <- lapply(breedingPos14, sp::SpatialPoints, 
                    proj4string = sp::CRS(projections$WGS84))
targLocs14 <- lapply(winteringPos14, sp::SpatialPoints, 
                     proj4string = sp::CRS(projections$WGS84))


# Relative abundance by scenario and breeding population
breedingN14base <- rep(25, nBreeding14[1])
breedingN14 <- lapply(breedingSiteTrans14, rowsum, x=breedingN14base)
breedingRelN14 <- lapply(breedingN14, "/", sum(breedingN14base))


MC14 <- 0.25

nSample14.1 <- 100 # Total number sampled per simulation

# How many sampled from each natural population (sampling scenarios separate
# from definition scenarios)
sampleBreeding14.1 <- list(round(breedingRelN14[[1]]*nSample14.1),
                         c(rep(0,22),round(breedingRelN14[[5]][1]*nSample14.1),
                           rep(0,4), round(breedingRelN14[[5]][2]*nSample14.1),
                           rep(0,44),round(breedingRelN14[[5]][3]*nSample14.1),
                           rep(0,4), round(breedingRelN14[[5]][4]*nSample14.1),
                           rep(0, 22)),
                           rep(c(rep(0, 4),
                           rep(round(breedingRelN14[[2]][1]*nSample14.1/2), 2),
                           rep(0, 4)), 10))

lapply(sampleBreeding14.1, matrix, nrow=10, ncol=10)

# Number of simulations to run
nSims14 <- 100
nSimsLarge14 <- 2500
nYears <- 1
nMonths <- 1

# Set up data structures for storing results
animalLoc14 <- vector("list", nScenarios14) #making an empty list to fill
sim14 <- vector("list", nSimsLarge14) #making an empty list to fill

compare14.1.array <- array(NA, c(nSimsLarge14, 2), 
                           dimnames = list(1:nSimsLarge14,
                                           c("MC", "Mantel")))

results14 <- vector("list", nScenarios14)

# Run simulations
set.seed(7)

system.time(for (sim in 1:nSimsLarge14) {
  
  cat("Simulation", sim, "of", nSimsLarge14, '\n')
  
  sim14[[sim]] <- lapply(sampleBreeding14.1,
                         simMove, 
                         breedingDist = breedDist14[[1]],
                         winteringDist=nonbreedDist14[[1]],
                         psi=psi,
                         nYears=nYears,
                         nMonths=nMonths)
  
for (i in 13) {
 animalLoc14[[i]] <- changeLocations(sim14[[sim]][[scenarioToSampleMap14[i]]]$animalLoc,
                                     breedingSiteTrans14[[i]], 
                                     winteringSiteTrans14[[i]])
 
 results14[[i]] <- calcPsiMC(breedDist14[[i]], 
                             nonbreedDist14[[i]],
                             animalLoc14[[i]],
                             originRelAbund = breedingRelN14[[i]],
                             verbose = F)
 
  compare14.1.array[sim,'MC'] <- results14[[i]]$MC
    
  compare14.1.array[sim,'Mantel'] <- calcStrengthInd(breedDist14[[1]],
                                                  nonbreedDist14[[1]],
                            sim14[[sim]][[scenarioToSampleMap14[i]]]$animalLoc,
                                                  resamp=0)$correlation
  }
})

means14 <- apply(compare14.1.array, 2, mean)

vars14 <- apply(compare14.1.array, 2, var)

rmse14 <- apply(compare14.1.array, 2, function(x) sqrt(mean((x - MC14)^2)))

# Set up data structures for storing estimation results
est14.array <- array(NA, c(nSims14, 2), 
                     dimnames = list(1:nSims14,c("MC", "Mantel")))

var14.array <- array(NA, c(nSims14, 2), 
                     dimnames =list(1:nSims14,c("MC", "Mantel")))

ci14.array <- array(NA, c(nSims14, 2, 2), 
                    dimnames = list(1:nSims14,
                                    c("MC", "Mantel"),
                                    c('lower', 'upper')))

#making an empty list to fill

animalLoc14 <- vector("list", nSims14) 

results14 <- vector("list", nSims14)

# Run estimations
set.seed(567)

sim14.sub <- sim14[sample.int(nSimsLarge14, nSims14, T)]

for (sim in 1:nSims14) {
  cat("Estimation", sim, "of", nSims14, '\n')
  
 for (i in 13) {#:nScenarios14) {
  animalLoc14[[sim]] <- 
    changeLocations(sim14.sub[[sim]][[scenarioToSampleMap14[i]]]$animalLoc,
                                        breedingSiteTrans14[[i]], 
                                        winteringSiteTrans14[[i]])
  
  results14[[sim]] <- estMC(breedDist14[[i]], 
                            nonbreedDist14[[i]],
                            originRelAbund = breedingRelN14[[i]],
              originPoints = capLocs14[[i]][animalLoc14[[sim]][, 1, 1, 1], ],
              targetPoints = targLocs14[[i]][animalLoc14[[sim]][, 2, 1, 1], ],
                            originAssignment = animalLoc14[[sim]][, 1, 1, 1],
                            targetAssignment = animalLoc14[[sim]][, 2, 1, 1],
                            nSamples = 1000,
                            verbose = 0,
                            calcCorr = T,
                            geoBias = c(0, 0),
                            geoVCov = matrix(0, 2, 2))
  
    est14.array[sim, 'MC'] <- results14[[sim]]$meanMC
    est14.array[sim, 'Mantel'] <- results14[[sim]]$meanCorr
    var14.array[sim, 'MC'] <- results14[[sim]]$seMC ^ 2
    var14.array[sim, 'Mantel'] <- results14[[sim]]$seCorr ^ 2
    ci14.array[sim, 'MC', ] <- results14[[sim]]$bcCI
    ci14.array[sim, 'Mantel', ] <- results14[[sim]]$bcCICorr
  }
}

# Crude point estimates (bootstrap means are better)
pointEsts14.1 <- t(sapply(results14, function(x) c(x$pointMC, x$pointCorr)))

# Summarize results
summary(var14.array)
vars14
summary(est14.array)
summary(pointEsts14.1)
means14
colMeans(pointEsts14.1) - MC14
sqrt(colMeans((pointEsts14.1 - MC14)^2))
summary(ci14.array[, "MC", 'lower'] <= MC14 & 
          ci14.array[, "MC", 'upper'] >= MC14)
summary(ci14.array[, "Mantel", 'lower'] <= MC14 & 
          ci14.array[, "Mantel", 'upper'] >= MC14)

# Plot histograms of bootstrap estimation results
est.df <- data.frame(Parameter = rep(c("MC", 'rM'), 2, each = nSims14),
                     Quantity = rep(c('Mean', 'Variance'), each = 2 * nSims14),
                     sim = rep(1:nSims14, 4), 
                     Estimate = c(est14.array, var14.array))

trues.df <- data.frame(Parameter = rep(c("MC", 'rM'), 2),
                       Quantity = rep(c('Mean', 'Variance'), each = 2),
                       Value = c(MC14, MC14, vars14))

library(ggplot2)
g.est <- ggplot(est.df, aes(Estimate)) + geom_histogram(bins = 15) +
  facet_grid(Parameter ~ Quantity, scales = 'free_x') +
  geom_vline(aes(xintercept = Value), data = trues.df) +
  theme_bw() + scale_x_continuous(breaks = c(0.002, 0.003, 0.1, 0.2, 0.3))

g.est


# Summary table of bootstrap estimation results
qualities14 <- data.frame(Parameter = rep(c("MC", 'rM'), 5),
                          Quantity = rep(rep(c('Mean', 'Variance'), c(2, 2)), 
                                         3, 10),
                          Measure = rep(c('Bias', 'RMSE', "Coverage"), 
                                        c(4, 4, 2)),
                          Value = c(colMeans(est14.array - MC14),
                                    colMeans(var14.array) - vars14,
                                    sqrt(colMeans((est14.array - MC14)^2)),
                                    sqrt(mean((var14.array[,1]-vars14[1])^2)),
                                    sqrt(mean((var14.array[,2]-vars14[2])^2)),
                                    mean(ci14.array[, "MC", 'lower'] <= MC14 & 
                                         ci14.array[, "MC", 'upper'] >= MC14),
                                    mean(ci14.array[,"Mantel",'lower']<=MC14 &
                                         ci14.array[,"Mantel",'upper']>=MC14)))

format(qualities14, digits = 2, scientific = F)

```
 
###EXAMPLE 9
`estMC` Estimate strength of migratory connectivity incorporating uncertainty from location error associated with light-level geolocators.  Again, we simulated data using the 13th scenario from example 5 above ("CentroidSampleBreeding4"; make sure you run examples 5 and 8 code before running this section).  
```{r, eval = FALSE}
# Simulation using error associated with light-level geolocators
# Assign geolocator bias / variance co-variance matrix

geoBias <- c(-10000, 50000)
geoVCov <- matrix(c(1.2e+8, 0, 0, 1.2e+9), 2, 2)
sqrt(diag(geoVCov))

targLocs14.2 <- lapply(targLocs14, sp::spTransform, 
                       CRSobj = sp::CRS(projections$Lambert))

# convert wintering locations to polygons using the helper function
WinteringPolys <- lapply(winteringPos14,
                         toPoly,
                         projection.in = projections$WGS84, 
                         projection.out = projections$Lambert)

winteringPolys <- lapply(winteringPos14,
                         toPoly,
                         projection.in = projections$WGS84,
                         projection.out = projections$WGS84)

winteringPolys2 <- lapply(winteringPos14,
                          toPoly,
                          projection.in = projections$WGS84,
                          projection.out = projections$EquidistConic)

# Double check that the input center points and output polygons are ordered
# correctly 
cbind(breedingPos14[[1]][,1:2],
      t(sapply(slot(breedingPolys[[1]], "polygons"),
               function(x){ slot(x,"labpt")})))

cbind(winteringPos14[[1]][,1:2],
      t(sapply(slot(winteringPolys[[1]], "polygons"),
               function(x){ slot(x,"labpt")})))
  
# Simulate capture and non-breeding locations of 100 individuals #

nSample14.2 <- 100 # Total number sampled per simulation

# How many sampled from each natural population (sampling scenarios separate
# from definition scenarios)
sampleBreeding14.2 <- list(round(breedingRelN14[[1]]*nSample14.2),
                         c(rep(0,22),round(breedingRelN14[[5]][1]*nSample14.2),
                           rep(0, 4),round(breedingRelN14[[5]][2]*nSample14.2),
                           rep(0,44),round(breedingRelN14[[5]][3]*nSample14.2),
                           rep(0, 4),round(breedingRelN14[[5]][4]*nSample14.2),
                           rep(0, 22)),
                         rep(c(rep(0, 4),
                               rep(round(breedingRelN14[[2]][1]*nSample14.2/2),
                                   2),
                               rep(0, 4)), 10))

lapply(sampleBreeding14.2, matrix, nrow=10, ncol=10)

# Number of simulations to run
nSims14.2 <- 100
nSimsLarge14.2 <- 2500
nYears <- 1
nMonths <- 1

# Set up data structures for storing results

#making an empty list to fill
animalLoc14 <- vector("list", nScenarios14) 
sim14.2 <- vector("list", nSimsLarge14.2) 

compare14.2.array <- array(NA, c(nSimsLarge14.2, 2), 
                           dimnames = list(1:nSimsLarge14.2,
                                           c("MC", "Mantel")))

results14 <- vector("list", nScenarios14)
results14.2 <- vector("list", nSimsLarge14.2)
originDist1 <- targetDist1 <- matrix(NA, nSample14.2, nSample14.2)
targetDist1[lower.tri(targetDist1)] <- 1
distIndices <- which(!is.na(targetDist1), arr.ind = T)

# Run simulations
set.seed(7)

system.time(for (sim in 1:nSimsLarge14.2) {
  cat("Simulation", sim, "of", nSimsLarge14.2, '\n')
  sim14.2[[sim]] <- lapply(sampleBreeding14.2,
                           simMove,
                           breedingDist = breedDist14[[1]],
                           winteringDist=nonbreedDist14[[1]],
                           psi=psi,
                           nYears=nYears,
                           nMonths=nMonths)
  
for (i in 13) { # only run one scenario
  animalLoc14.0 <- sim14.2[[sim]][[scenarioToSampleMap14[i]]]$animalLoc
  animalLoc14[[i]] <- changeLocations(animalLoc14.0,
                                      breedingSiteTrans14[[i]],
                                      winteringSiteTrans14[[i]])
  
    breedingTruePoints14 <- capLocs14[[i]][animalLoc14[[i]][,1,1,1], ]
    
    winteringTruePoints14 <- targLocs14.2[[i]][animalLoc14.0[,2,1,1], ]
    
    results14.2[[sim]] <- simLocationError(winteringTruePoints14, 
                                           WinteringPolys[[i]], 
                                           geoBias,
                                           geoVCov,
                                           projections$Lambert)
    
    animalLoc14.2 <- animalLoc14[[i]]
    
    animalLoc14.2[ , 2, 1, 1] <- results14.2[[sim]]$targetSample
    
    results14[[i]] <- calcPsiMC(breedDist14[[i]], 
                                nonbreedDist14[[i]],
                                animalLoc14.2,
                                originRelAbund = breedingRelN14[[i]],
                                verbose = F)
    
    compare14.2.array[sim, 'MC'] <- results14[[i]]$MC
    
    originDist0 <- geosphere::distVincentyEllipsoid(
                                     breedingTruePoints14[distIndices[,'row']],
                                     breedingTruePoints14[distIndices[,'col']])
    
    originDist1[lower.tri(originDist1)] <- originDist0
    
    target.point.sample <- sp::SpatialPoints(
      results14.2[[sim]]$targetPointSample,
                                             sp::CRS(projections$Lambert))
    
    target.point.sample2 <- sp::spTransform(target.point.sample,
                                            sp::CRS(projections$WGS84))
    
    targetDist0 <- geosphere::distVincentyEllipsoid(
                                     target.point.sample2[distIndices[,'row']],
                                     target.point.sample2[distIndices[,'col']])
    
    targetDist1[lower.tri(targetDist1)] <- targetDist0
    
    compare14.2.array[sim, 'Mantel'] <- ncf::mantel.test(originDist1, 
                                                         targetDist1, 
                                                         resamp=0, 
                                                         quiet = T)$correlation
  }
})

means14.2 <- apply(compare14.2.array, 2, mean)
vars14.2 <- apply(compare14.2.array, 2, var)
rmse14.2 <- apply(compare14.2.array, 2, function(x) sqrt(mean((x - MC14)^2)))

# Set up data structures for storing estimation results
est14.2.array <- array(NA, c(nSims14.2, 2), 
                       dimnames = list(1:nSims14.2,
                                       c("MC", "Mantel")))

var14.2.array <- array(NA, c(nSims14.2, 2), 
                       dimnames = list(1:nSims14.2,
                                       c("MC", "Mantel")))

ci14.2.array <- array(NA, c(nSims14.2, 2, 2), 
                      dimnames = list(1:nSims14.2,
                                      c("MC", "Mantel"),
                                      c('lower', 'upper')))

animalLoc14 <- vector("list", nSims14.2) #making an empty list to fill
results14 <- vector("list", nSims14.2)

# Run estimations

set.seed(567)
sim14.2.sub <- sim14.2[sample.int(nSimsLarge14.2, nSims14.2, T)]

for (sim in 1:nSims14.2) {
  cat("Estimation", sim, "of", nSims14.2, '\n')
 for (i in 13) {
  points0 <- sp::SpatialPoints(results14.2[[sim]]$targetPointSample,
                                sp::CRS(projections$Lambert))
    
  points1 <- sp::spTransform(points0, 
                              sp::CRS(projections$EquidistConic))
    
  animalLoc14[[sim]] <- changeLocations(
    sim14.2.sub[[sim]][[scenarioToSampleMap14[i]]]$animalLoc,
                                        breedingSiteTrans14[[i]],
                                        winteringSiteTrans14[[i]])
  
  results14[[sim]] <- estMC(originDist = breedDist14[[i]],
                            targetDist = nonbreedDist14[[i]],
                            originRelAbund = breedingRelN14[[i]],
                originPoints = capLocs14[[i]][animalLoc14[[sim]][, 1, 1, 1], ],
                            targetPoints = points1,
                            originAssignment = animalLoc14[[sim]][, 1, 1, 1],
                            targetAssignment = results14.2[[sim]]$targetSample,
                            nSamples = 1000,
                            verbose = 0,
                            calcCorr = T,
                            geoBias = geoBias,
                            geoVCov = geoVCov,
                            isGL = T,
                            targetSites = winteringPolys2[[i]])
  
    est14.2.array[sim, 'MC'] <- results14[[sim]]$meanMC
    
    est14.2.array[sim, 'Mantel'] <- results14[[sim]]$meanCorr
    
    var14.2.array[sim, 'MC'] <- results14[[sim]]$seMC ^ 2
    
    var14.2.array[sim, 'Mantel'] <- results14[[sim]]$seCorr ^ 2
    
    ci14.2.array[sim, 'MC', ] <- results14[[sim]]$bcCI
    
    ci14.2.array[sim, 'Mantel', ] <- results14[[sim]]$bcCICorr
    
  }
}

pointEsts14.2 <- t(sapply(results14, function(x) c(x$pointMC, x$pointCorr)))

# Summarize estimation results
summary(var14.2.array)
vars14.2
summary(est14.2.array)
summary(pointEsts14.2)
colMeans(pointEsts14.2) - MC14
sqrt(colMeans((pointEsts14.2 - MC14)^2))
means14.2
mean(ci14.2.array[, "MC", 'lower'] <= MC14 & 
       ci14.2.array[, "MC", 'upper'] >= MC14)
mean(ci14.2.array[, "Mantel", 'lower'] <= MC14 & 
       ci14.2.array[, "Mantel", 'upper'] >= MC14)
sqrt(vars14.2) / MC14
summary(sqrt(var14.2.array)/est14.2.array)

# Plot histograms of bootstrap estimation results
est14.2.df <- data.frame(Parameter = rep(c("MC", 'rM'), 2, each = nSims14.2),
                     Quantity = rep(c('Mean', 'Variance'), 
                                    each = 2 * nSims14.2),
                     sim = rep(1:nSims14.2, 4), 
                     Estimate = c(est14.2.array, var14.2.array))

trues14.2.df <- data.frame(Parameter = rep(c("MC", 'rM'), 2),
                       Quantity = rep(c('Mean', 'Variance'), each = 2),
                       Value = c(MC14, MC14, vars14.2))

g.est <- ggplot(est14.2.df, aes(Estimate)) + geom_histogram(bins = 15) +
  facet_grid(Parameter ~ Quantity, scales = 'free_x') +
  geom_vline(aes(xintercept = Value), data = trues14.2.df) +
  theme_bw() + scale_x_continuous(breaks = c(0.002, 0.003, 0.1, 0.2, 0.3))

g.est


# Summary table of bootstrap estimation results
qualities14.2 <- data.frame(Parameter = rep(c("MC", 'rM'), 5),
                            Quantity = rep(rep(c('Mean', 'Variance'), 
                                               c(2, 2)), 3, 10),
                            Measure = rep(c('Bias', 'RMSE', "Coverage"), 
                                          c(4, 4, 2)),
                            Value = c(colMeans(est14.2.array - MC14),
                                      colMeans(var14.2.array) - vars14.2,
                                      sqrt(colMeans((est14.2.array - MC14)^2)),
                                      sqrt(mean((var14.2.array[,1] - 
                                                   vars14[1])^2)),
                                      sqrt(mean((var14.2.array[,2] - 
                                                   vars14[2])^2)),
                                      mean(ci14.2.array[,"MC",'lower']<=MC14 &
                                           ci14.2.array[,"MC",'upper']>=MC14),
                              mean(ci14.2.array[, "Mantel", 'lower'] <= MC14 & 
                                   ci14.2.array[, "Mantel", 'upper'] >= MC14)))

format(qualities14.2, digits = 2, scientific = F)



# Make summary table and figures of results with (Example 9) and without 
# (Example 8) location error

qualities.all <- rbind(data.frame(DataType = 'GPS', qualities14),
                       data.frame(DataType = 'GL', qualities14.2))


est14.all.df <- rbind(data.frame(DataType = 'GPS', est.df),
                       data.frame(DataType = 'GL', est14.2.df))

trues14.all.df <- data.frame(DataType = rep(c("GPS", "GL"), 2, each = 2),
                             Parameter = rep(c("MC", 'rM'), 4),
                       Quantity = rep(c('Mean', 'Variance'), each = 4),
                       Value = c(rep(MC14, 4), vars14, vars14.2))

g.est <- ggplot(est14.all.df, aes(Estimate)) + geom_histogram(bins = 12) +
  facet_grid(DataType + Parameter ~ Quantity, scales = 'free_x') +
  geom_vline(aes(xintercept = Value), data = trues14.all.df) +
  theme_bw() + scale_x_continuous(breaks = c(0.002, 0.003, 0.1, 0.2, 0.3))

g.est


```
 
###EXAMPLE 10
`estMC` Estimate strength of migratory connectivity incorporating uncertainty in estimates of breeding abundance (see estMC help file)
 
###EXAMPLE 11
`estMC` Estimate strength of migratory connectivity incorporating detection heterogeneity (see estMC help file)

###EXAMPLE 12
`estMC` Estimate strength of migratory connectivity incorporating location uncertainty 

Estimates of MC may also be influenced by error in individual assignment to regions. Data types vary in location accuracy and precision, which are likely to influence the accuracy with which individuals are assigned to regions. We measured MC for bootstrapped data of birds tracked from breeding to non-breeding regions using light-level and GPS geolocation when 1) GPS location uncertainty was applied to all individuals, 2) GPS and light-level location uncertainty were applied to individuals with those devices, and 3) light-level location uncertainty was applied to all individuals.  See Example 2 above and estMC help file.

###EXAMPLE 13 (from process error simulation in Cohen et al. in press)

`simMove` for measuring the influence of dispersal rates on MC

Long-distance dispersal occurs when individuals that originate or breed in one population do not return to the same population to breed the next year. To quantify the sensitivity of MC to dispersal, we used simulations in which dispersal probability between breeding regions varied from low to high to measure the sensitivity of MC to dispersal.

```{r, eval = FALSE}
## Simulation ----
nBreeding <- 100
nWintering <- 100
breedingPos <- matrix(c(rep(seq(-99, -81, 2), each=sqrt(nBreeding)),
                        rep(seq(49, 31, -2), sqrt(nBreeding))), nBreeding, 2)
winteringPos <- matrix(c(rep(seq(-79, -61, 2), each=sqrt(nWintering)),
                         rep(seq(9, -9, -2), sqrt(nWintering))), nWintering, 2)
head(breedingPos)
tail(breedingPos)
head(winteringPos)
tail(winteringPos)

breedDist <- distFromPos(breedingPos, 'ellipsoid')
nonbreedDist <- distFromPos(winteringPos, 'ellipsoid')

# Breeding Abundance
breedingN <- rep(5000, nBreeding)
breedingRelN <- breedingN/sum(breedingN)

# Set up psi matrix
o <- optimize(mlogitMC, MC.in = 0.25, origin.dist = breedDist,
              target.dist = nonbreedDist, origin.abund = breedingRelN,
              sample.size = sum(breedingN),
              interval = c(0, 10), tol = .Machine$double.eps^0.5)

slope <- o$minimum
psi <- mlogitMat(slope, breedDist)

# Baseline strength of migratory connectivity
MC <- calcMC(breedDist, nonbreedDist, breedingRelN, psi, sum(breedingN))
MC

# Other basic simulation parameters

## Dispersal simulations---
set.seed(1516)

nYears <- 15

nMonths <- 4 # Each season

Drates <- c(0.02, 0.04, 0.08, 0.16, 0.32, 0.64)    #rates of dispersal

birdLocDisp <- vector('list', length(Drates))

Disp.df  <- data.frame(Year=rep(1:nYears, length(Drates)),
                       Rate=rep(Drates, each = nYears), MC = NA)

for(i in 1:length(Drates)){
  cat('Dispersal Rate', Drates[i], '\n')
  birdLocDisp[[i]] <- simMove(breedingN, 
                              breedDist, 
                              nonbreedDist, 
                              psi, 
                              nYears, 
                              nMonths,
                              sumDispRate = Drates[i])
  for(j in 1:nYears){
    cat('\tYear', j, '\n')
    temp.results <- calcPsiMC(breedDist,
                              nonbreedDist,
                              breedingRelN,
                              birdLocDisp[[i]]$animalLoc,
                              years=j,
                              verbose = F)
    
    Disp.df$MC[j + (i - 1) * nYears] <- temp.results$MC
  }
} # end i loop

Disp.df$Year <- Disp.df$Year - 1 #just run once!

data.frame(Disp.df, roundMC = round(Disp.df$MC, 2), 
           nearZero = Disp.df$MC < 0.01)


# Convert dispersal rates to probabilities of dispersing at least certain distance
threshold <- 1000
probFarDisp <- matrix(NA, nBreeding, length(Drates), dimnames = list(NULL, Drates))

for (i in 1:length(Drates)) {
  for (k in 1:nBreeding) {
    probFarDisp[k, i] <- 
      sum(birdLocDisp[[i]]$natalDispMat[k, which(breedDist[k, ]>= threshold)])
  }
}

summary(probFarDisp)

#plot results
\dontrun{
require(ggplot2)
require(ggthemes)

line_set=c(0.5, 0.75, 1, 1.25, 1.75, 2.25)
ggplot(Disp.df, aes(x=Year, y=MC, size=as.factor(Rate)))+
 geom_line()+
 scale_size_manual(values=line_set)+
 labs(size="Dispersal Rate")+
 scale_y_continuous("MC", limits=c(-.005, 0.26), 
                    breaks=c(0, 0.05, 0.1, 0.15, 0.2, 0.25))+
 scale_x_continuous(breaks=c(0, 3, 6, 9, 12, 15))+
 theme_bw()+
 theme(axis.title=element_text(size=16, face ="bold"),
       axis.text=element_text(size=14),
       panel.grid.major = element_line(color="grey90"),
       panel.grid.major.x = element_blank(),
       legend.title=element_text(size=14), 
       legend.text=element_text(size=14))
}
```


