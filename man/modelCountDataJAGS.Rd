% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/simConnectivity.R
\name{modelCountDataJAGS}
\alias{modelCountDataJAGS}
\title{Estimates population-level relative abundance from count data}
\usage{
modelCountDataJAGS(count_data, ni = 20000, nt = 5, nb = 5000, nc = 3)
}
\arguments{
\item{count_data}{List containing the following elements:
' \describe{
   \item{\code{C}}{nYears by nRoutes matrix containing the observed number of individuals counted at each route in each year.}
   \item{\code{pop}}{Vector of length nRoutes indicating the population/region in which each route is located.}
   \item{\code{routePerPop}}{Vector of length 1 or nPops containing the number of routes (i.e. counts) per population. If length(routePerPop) == 1, number of routes is identical for each population.}
}}

\item{ni}{Number of MCMC iterations. Default = 20000.}

\item{nt}{Thinning rate. Default = 5.}

\item{nb}{Number of MCMC iterations to discard as burn-in. Default = 5000.}

\item{nc}{Number of chains. Default = 3.}
}
\value{
\code{modelCountDataJAGS} returns an mcmc object containing posterior samples for each monitored parameter.
}
\description{
Uses a Bayesian heirarchical model to estimate relative abundance of regional
populations from count-based data (e.g., Breeding Bird Survey)
}
\examples{
set.seed(150)

### Set parameters for simulation ----

  nPops. <- 4           # Number of populations
  routePerPop. <- 90    # Number of routes w/i each population (assumed to be balanced)
  nYears. <- 10         # Number of years
  alphaPop. <- 1.95     # log(Expected number of birds counted at each route)
  sdRoute. <- 0.6       # standard deviation of normal distribution assumed for route/observer random effects
  sdYear. <- 0.18       # standard deviation of normal distribution assumed for year random effects
  ni. <- 15000            # Number of MCMC iterations
  nt. <- 5              # Number of iterations to thin from posterior
  nb. <- 5000            # Number of iterations to discard as burn-in
  nc. <- 3              # Number of MCMC chains
  
### Create empty matrix to store model output ---
  nsims <- 100
  sim_in <- vector("list", nsims)
  sim_out <- vector("list", nsims)
  
  
# Simulation ---
  system.time(for(s in 1:nsims){
    
    # Simulate data
    sim_data <- simCountData(nPops = nPops., routePerPop = routePerPop., nYears = nYears., alphaPop = alphaPop.,
                             sdRoute = sdRoute., sdYear = sdYear.)
    sim_in[[s]] <- sim_data
    
    
    # Estimate population-level abundance
    out_mcmc <- modelCountDataJAGS(count_data = sim_data, ni = ni., nt = nt., nb = nb., nc = nc.)
    
    # Store model output
    sim_out[[s]] <- out_mcmc
    remove(out_mcmc)
    
  })
  

### Check that relative abundance is, on average, equal for each population
  prop.table(sapply(sim_in, function(x) return(rowsum(colSums(x$C), x$pop))), 2)
  
  nSamples <- (ni. - nb.)/nt. * nc.
  rel_abund0 <- array(NA, c(nsims, nSamples, nPops))
  rel_abund1 <- data.frame(sim=1:nsims, ra1.mean=NA, ra2.mean=NA, ra3.mean=NA, ra4.mean=NA, 
                           ra1.low=NA, ra2.low=NA, ra3.low=NA, ra4.low=NA, 
                           ra1.high=NA, ra2.high=NA, ra3.high=NA, ra4.high=NA, 
                           ra1.cover=0, ra2.cover=0, ra3.cover=0, ra4.cover=0)
  for (s in 1:nsims) {
    rel_abund0[s,,] <- prop.table(as.matrix(sim_out[[s]][,1:nPops]), 1)
    rel_abund1[s, 2:5] <- colMeans(rel_abund0[s,,])
    rel_abund1[s, 6:9] <- apply(rel_abund0[s,,], 2, quantile, probs=0.025)
    rel_abund1[s, 10:13] <- apply(rel_abund0[s,,], 2, quantile, probs=0.975)
  }
  rel_abund1 <- transform(rel_abund1, ra1.cover = (ra1.low<=0.25 & ra1.high>=0.25),
                          ra2.cover = (ra2.low<=0.25 & ra2.high>=0.25),
                          ra3.cover = (ra3.low<=0.25 & ra3.high>=0.25),
                          ra4.cover = (ra4.low<=0.25 & ra4.high>=0.25))
  
  summary(rel_abund1)                        
  
  
  
  
}

