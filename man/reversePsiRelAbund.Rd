% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calcConnectivity.R
\name{reversePsiRelAbund}
\alias{reversePsiRelAbund}
\title{Reverse transition probabilities and origin relative abundance}
\usage{
reversePsiRelAbund(
  psi,
  originRelAbund,
  originSites = NULL,
  targetSites = NULL,
  originNames = NULL,
  targetNames = NULL,
  nSamples = 1000,
  row0 = 0,
  alpha = 0.05
)
}
\arguments{
\item{psi}{Transition probabilities between B origin and W target sites.
Either a matrix with B rows and W columns where rows sum to 1, an array with
dimensions x, B, and W (with x samples of the transition probability matrix
from another model), an 'estPsi' object (result of calling estTransition),
or a MARK object with estimates of transition probabilities}

\item{originRelAbund}{Relative abundance estimates at B origin sites. Either
a numeric vector of length B that sums to 1 or an mcmc object with at least
\code{nSamples} rows and columns including 'relN[1]' through 'relN[B]'}

\item{originSites}{If \code{psi} is a MARK object, this must be a numeric
vector indicating which sites are origin}

\item{targetSites}{If \code{psi} is a MARK object, this must be a numeric
vector indicating which sites are target}

\item{originNames}{Vector of names for the origin sites. If not provided, the
function will try to get them from psi}

\item{targetNames}{Vector of names for the target sites. If not provided, the
function will try to get them from psi}

\item{nSamples}{Number of times to resample \code{psi} and/or
\code{originRelAbund}. The purpose is to estimate sampling uncertainty;
higher values here will do so with more precision}

\item{row0}{If \code{originRelAbund} is an mcmc object or array, this can be
set to 0 (default) or any greater integer to specify where to stop ignoring
samples (additional "burn-in")}

\item{alpha}{Level for confidence/credible intervals provided. Default (0.05)
gives 95 percent CI}
}
\value{
If both psi and originRelAbund are simple point estimates,
\code{reversePsiRelAbund} returns a list with point estimates of gamma and
targetRelAbund. Otherwise, it returns a list with the elements:
\describe{
  \item{\code{gamma}}{List containing estimates of reverse transition
  probabilities:
  \itemize{
   \item{\code{sample}} Array of sampled values for gamma. \code{nSamples} x
     [number of target sites] x [number of origin sites]. Provided to allow
     the user to compute own summary statistics.
   \item{\code{mean}} Main estimate of gamma matrix. [number of target sites]
     x [number of origin sites].
   \item{\code{se}} Standard error of gamma, estimated from SD of
     \code{gamma$sample}.
   \item{\code{simpleCI}} \code{1 - alpha} confidence interval for gamma,
     estimated as \code{alpha/2} and \code{1 - alpha/2} quantiles of
     \code{gamma$sample}.
   \item{\code{bcCI}} Bias-corrected \code{1 - alpha} confidence interval
     for gamma. May be preferable to \code{simpleCI} when \code{mean} is the
     best estimate of gamma. \code{simpleCI} is preferred when
     \code{median} is a better estimator. When the mean and median are equal,
     these should be identical.  Estimated as the
     \code{pnorm(2 * z0 + qnorm(alpha / 2))} and
     \code{pnorm(2 * z0 + qnorm(1 - alpha / 2))} quantiles of \code{sample},
     where z0 is the proportion of \code{sample < mean}.
   \item{\code{median}} Median estimate of gamma matrix.
   \item{\code{point}} Simple point estimate of gamma matrix, not accounting
     for sampling error.
  }
  }
  \item{\code{targetRelAbund}}{List containing estimates of relative
   abundance at target sites. Items within are the same as within gamma,
   except for having one fewer dimensions.}
  \item{\code{input}}{List containing the inputs to \code{reversePsiRelAbund}.}
}
}
\description{
Reverse transition probabilities (psi) and origin relative abundance
(originRelAbund) estimates to calculate or estimate target site to origin
site transition probabilities (gamma) and target site relative abundances
(targetRelAbund). If either psi or originRelAbund is an estimate with
sampling uncertainty expressed, this function will propagate that
uncertainty to provide true estimates of gamma and targetRelAbund; otherwise
(if both are simple point estimates), it will also provide point estimates.
}
\examples{
for (i in 1:length(samplePsis)) {
 for (j in 1:length(sampleOriginRelN)){
  cat("For psi:\n")
  print(samplePsis[[i]])
  cat("and origin relative abundance:", sampleOriginRelN[[j]], "\n")
  print(reversePsiRelAbund(samplePsis[[i]], sampleOriginRelN[[j]]))
 }
}
COTE_banded <- c(10360, 1787, 2495, 336)
COTE_reencountered <- matrix(c(12, 0, 38, 15,
                               111, 7, 6, 2,
                               5, 0, 19, 4,
                               1123, 40, 41, 7),
                             4, 4,
                             dimnames = list(LETTERS[1:4], 1:4))
COTE_psi <- estTransition(originNames = LETTERS[1:4],
                          targetNames = 1:4,
                          banded = COTE_banded,
                          reencountered = COTE_reencountered,
                          verbose = 1,
                          nSamples = 60000, nBurnin = 20000)
COTE_psi
COTE_rev <- reversePsiRelAbund(COTE_psi, sampleOriginRelN[[1]],
                               nSamples = 2000)
COTE_rev

# Number of populations
nOriginSites <- 3; originNames <- LETTERS[1:nOriginSites]
nTargetSites <- 4; targetNames <- 1:nTargetSites
# Number of routes w/i each population (assumed to be balanced)
routePerPop. <- 30 # reduced for example speed
# Number of years
nYears. <- 5 # reduced for example speed
# log(Expected number of birds counted at each route)
alphaPop. <- 1.95
# standard deviation of normal distribution assumed for route/observer random
# effects
sdRoute. <- 0.6
# standard deviation of normal distribution assumed for year random effects
sdYear. <- 0.18


# Number of MCMC iterations
ni. <- 1000 # reduced for example speed
# Number of iterations to thin from posterior
nt. <- 1
# Number of iterations to discard as burn-in
nb. <- 500 # reduced for example speed
# Number of MCMC chains
nc. <- 1 # reduced for example speed

# Simulation ---
# Simulate data
sim_data <- simCountData(nPops = nOriginSites, routePerPop = routePerPop.,
                         nYears = nYears., alphaPop = alphaPop.,
                         sdRoute = sdRoute., sdYear = sdYear.)

originRelAbund <- c(1/3, 1/3, 1/3)

psiTrue <- array(0, c(nOriginSites, nTargetSites),
                 list(originNames, targetNames))
psiTrue[1,] <- c(0.10608 + 0.10856, 0.52536, 0.16, 0.10)
psiTrue[2,] <- c(0.04441 + 0.36664, 0.30895, 0.17, 0.11)
psiTrue[3,] <- c(0.10, 0.15, 0.42463, 0.32537)
rowSums(psiTrue)

rev <- reversePsiRelAbund(psiTrue, originRelAbund)

sim_data2 <- simCountData(nPops = nTargetSites, routePerPop = routePerPop.,
                          nYears = nYears., alphaPop = rev$targetRelAbund * 2,
                          sdRoute = sdRoute., sdYear = sdYear.)
# Estimate population-level abundance
out_mcmc <- modelCountDataJAGS(count_data = sim_data, ni = ni., nt = nt.,
                               nb = nb., nc = nc.)
# Estimate winter abundance
out_mcmc2 <- modelCountDataJAGS(count_data = sim_data2, ni = ni., nt = nt.,
                                nb = nb., nc = nc.)
originDist <- matrix(c(0, 624.3587, 1497.2287,
                       624.3587, 0, 942.2186,
                       1497.2287, 942.2186, 0),
                     nOriginSites, nOriginSites,
                     dimnames = list(originNames, originNames))
targetDist <- matrix(c(0, 1505.0301, 2256.9304, 2299.9251,
                       1505.0301, 0, 1795.6660, 1261.6037,
                       2256.9304, 1795.6660, 0, 860.5803,
                       2299.9251, 1261.6037, 860.5803, 0),
                     nTargetSites, nTargetSites,
                     dimnames = list(targetNames, targetNames))
sampleSize <- list(rep(20, nOriginSites), rep(75, nTargetSites))

MCtrue <- calcMC(originDist, targetDist, originRelAbund, psiTrue)

shapesO <- matrix(c(5.5, 0.25, 0.01,
                    0.25, 5.5, 0.01,
                    0.004, 0.006, 5.75),
                  nOriginSites, nOriginSites, byrow = T,
                  dimnames = list(originNames, originNames))
prop.table(shapesO, 1)

shapesT <- matrix(c(15, 0.24, 0.0045, 0.0045,
                    0.24, 15, 0.0045, 0.0045,
                    0.0045, 0.0068, 18, 0.15,
                    0.0045, 0.0068, 0.15, 18), 4, 4, byrow = T,
                  dimnames = list(targetNames, targetNames))
prop.table(shapesT, 1)

data1 <- simProbData(psi = psiTrue,
                    originRelAbund = originRelAbund,
                    sampleSize = sampleSize[[1]],
                    shapes = shapesT,
                    captured = "origin")
tt <- data1$genProbs
oa <- data1$originAssignment
ot2 <- matrix(0, length(oa), nOriginSites)
for (i in 1:length(oa))
  ot2[i, oa[i]] <- 1
data2 <- simProbData(psi = psiTrue,
                    originRelAbund = originRelAbund,
                    sampleSize = sampleSize[[2]],
                    shapes = shapesO,
                    captured = "target")
ot <- data2$genProbs
ta <- data2$targetAssignment
tt2 <- matrix(0, length(ta), nTargetSites)
for (i in 1:length(ta))
  tt2[i, ta[i]] <- 1
tt <- rbind(tt, tt2)
ot <- rbind(ot2, ot)
captured <- rep("origin", sum(sampleSize[[1]]))
captured <- c(captured, rep("target", sum(sampleSize[[2]])))

est1 <- estTransition(targetAssignment = tt,
                      originAssignment = ot, maxTries = 1000,
                      #originRaster = or, #
                      originNames = originNames,
                      targetNames = targetNames,
                      nSamples = 500, isGL = F,
                      isTelemetry = F,
                      isRaster = F,
                      isProb = T,
                      captured = captured,
                      nSim = 100, verbose = 0,
                      targetRelAbund = out_mcmc2)
rev1 <- reversePsiRelAbund(psi = est1, originRelAbund = out_mcmc)
rev1
rev

}
