% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estConnectivity.R
\name{estTransition}
\alias{estTransition}
\title{Estimate psi (transition probabilities between locations in two phases of
the annual cycle)}
\usage{
estTransition(
  originSites = NULL,
  targetSites = NULL,
  originPoints = NULL,
  targetPoints = NULL,
  originAssignment = NULL,
  targetAssignment = NULL,
  originNames = NULL,
  targetNames = NULL,
  nSamples = 1000,
  isGL = FALSE,
  isTelemetry = FALSE,
  isRaster = FALSE,
  isProb = FALSE,
  captured = "origin",
  geoBias = NULL,
  geoVCov = NULL,
  geoBiasOrigin = NULL,
  geoVCovOrigin = NULL,
  targetRaster = NULL,
  originRaster = NULL,
  banded = NULL,
  reencountered = NULL,
  verbose = 0,
  alpha = 0.05,
  resampleProjection = "ESRI:54027",
  nSim = ifelse(any(isRaster & isGL) || any(isRaster & isProb) || any(isGL & isProb),
    5000, ifelse(any(isGL), 1000, ifelse(any(isRaster), 10, 1))),
  maxTries = 300,
  nBurnin = 5000,
  nChains = 3,
  nThin = 1
)
}
\arguments{
\item{originSites}{the geographic definition of sites in the origin season.
Mike, fill in options here (sf/sp/whatever)}

\item{targetSites}{the geographic definition of sites in the target season.
Mike, fill in options here (sf/sp/whatever)}

\item{originPoints}{A \code{sf} or \code{SpatialPoints} object, with number
of rows or length being the number of animals tracked. Each point indicates
the origin location of an animal (or point estimate of same, for GL animals
released on target sites). Note that to simplify input of multiple
data types both between and for the same animal, if origin points are
provided for any animal, they must be provided for all (can be dummy values)}

\item{targetPoints}{For GL or telemetry data, a \code{sf} or
\code{SpatialPoints} object, with length or number of rows number of animals
tracked. Each point indicates the point estimate location of an animal in
the target season. Note that to simplify input of multiple
data types both between and for the same animal, if target points are
provided for any animal, they must be provided for all (can be dummy values)}

\item{originAssignment}{Assignment of animals to origin season sites. Either
an integer vector with length number of animals tracked or a matrix of
probabilities with number of animals tracked rows and number of origin sites
columns (and rows summing to 1). The latter only applies to animals released
in the target sites where there is uncertainty about their origin site, for
example from genetic population estimates from the rubias package.
Optional, but some combination of these inputs should be defined. Note that
if \code{originAssignment} is a probability table, animals with known origin
sites can have 1 in that column and 0s in all others}

\item{targetAssignment}{Assignment of animals to target season sites. Either
an integer vector with length number of animals tracked or a matrix of
probabilities with number of animals tracked rows and number of target sites
columns (and rows summing to 1). The latter only applies to animals released
in the origin sites where there is uncertainty about their target site, for
example from genetic population estimates from the rubias package.
Optional, but some combination of these inputs needs to be defined. Note
that if \code{targetAssignment} is a probability table, animals with known
target sites can have 1 in that column and 0s in all others}

\item{originNames}{Optional, but recommended to keep track. Vector of names
for the origin sites. If not provided, the function will either try to get
these from another input or provide default names (capital letters)}

\item{targetNames}{Optional, but recommended to keep track. Vector of names
for the target sites. If not provided, the function will either try to get
these from another input or provide default names (numbers)}

\item{nSamples}{Number of post-burn-in MCMC samples to store (band
data) OR number of bootstrap runs for GL, telemetry, probability assignment,
and/or raster data. In the latter case, animals are sampled with replacement
for each. For all, the purpose is to estimate sampling uncertainty}

\item{isGL}{Indicates whether or which animals were tracked with geolocators.
Should be either single TRUE or FALSE value, or vector with length of
number of animals tracked, with TRUE or FALSE for each animal in data. For
TRUE animals, the model applies \code{geoBias} and \code{geoVCov} to
\code{targetPoints} where \code{captured} == "origin" or "neither" and
\code{geoBiasOrigin} and \code{geoVCovOrigin} to
\code{originPoints} where \code{captured} == "target" or "neither"}

\item{isTelemetry}{Indicates whether or which animals were tracked with
telemetry/GPS (no location uncertainty on either end).
Should be either single TRUE or FALSE value, or vector with length of
number of animals tracked, with TRUE or FALSE for each animal in data}

\item{isRaster}{Indicates whether or which animals were tracked with
intrinsic markers (e.g., genetics or isotopes), with location uncertainty
expressed as a raster of probabilities by grid cells, either in
\code{targetRaster} or \code{originRaster}. Should be either single TRUE or
FALSE value, or vector with length of number of animals tracked, with TRUE
or FALSE for each animal in data}

\item{isProb}{Indicates whether or which animals were tracked with
intrinsic markers (e.g., genetics or isotopes), with location uncertainty
expressed as a probability table, either in \code{targetAssignment} or
\code{originAssignment}. Should be either single TRUE or FALSE value, or vector
with length of number of animals tracked, with TRUE or FALSE for each animal
in data}

\item{captured}{Indicates whether or which animals were captured in the
origin sites, the target sites, or neither (another phase of the annual
cycle). Location uncertainty will only be applied where the animal was not
captured. So this doesn't matter for telemetry data, and is assumed to be
"origin" for band return data. Should be either single "origin" (default),
"target", or "neither" value, or a character vector with length of number of
animals tracked, with "origin", "target", or "neither" for each animal}

\item{geoBias}{For GL data, vector of length 2 indicating expected bias
in longitude and latitude of \code{targetPoints}, in
\code{resampleProjection} units (default meters)}

\item{geoVCov}{For GL data, 2x2 matrix with expected variance/covariance
in longitude and latitude of \code{targetPoints}, in
\code{resampleProjection} units (default meters)}

\item{geoBiasOrigin}{For GL data where \code{captured}!="origin", vector of
length 2 indicating expected bias in longitude and latitude of
\code{originPoints}, in
\code{resampleProjection} units (default meters)}

\item{geoVCovOrigin}{For GL data where \code{captured}!="origin", 2x2 matrix
with expected variance/covariance in longitude and latitude of
\code{targetPoints}, in \code{resampleProjection} units (default meters)}

\item{targetRaster}{For intrinsic tracking data, the results of
\code{isoAssign} or a similar function of class \code{intrinsicAssign} or
class \code{RasterBrick}/\code{RasterStack}, for example from the package
\code{assignR}. In any case, it expresses location uncertainty on target
range, through a raster of probabilities by grid cells}

\item{originRaster}{For intrinsic tracking data, the results of
\code{isoAssign} or a similar function of class \code{intrinsicAssign} or
class \code{RasterBrick}/\code{RasterStack}, for example from the package
\code{assignR}. In any case, it expresses location uncertainty on origin
range, through a raster of probabilities by grid cells}

\item{banded}{For band return data, a vector or matrix of the number of
released animals from each origin site (including those never reencountered
in a target site). If a matrix, the second dimension is taken as the number
of age classes of released animals; the model estimates reencounter
probability by age class but assumes transition probabilities are the same}

\item{reencountered}{For band return data, either a matrix with B rows and W
columns or a B x [number of ages] x W array. Number of animals reencountered
on each target site (by age class banded as) by origin site they came from}

\item{verbose}{0 (default) to 3. 0 prints no output during run (except on
convergence for banding data). 1 prints an update every 100 samples or
bootstraps (or a status bar for banding data).  2 prints an update
every sample or bootstrap. 3 also prints the number of
draws (for tuning nSim for GL/intrinsic data only)}

\item{alpha}{Level for confidence/credible intervals provided. Default (0.05)
gives 95 percent CI}

\item{resampleProjection}{Projection when sampling from location uncertainty.
Default is Equidistant Conic. The default setting preserves distances
around latitude = 0 and longitude = 0. Other projections may work well,
depending on the location of sites. Ignored unless data are geolocator,
telemetry, or intrinsic}

\item{nSim}{Tuning parameter for GL or intrinsic data. Affects only the
speed; 1000 seems to work well with our GL data and 10 for our intrinsic
data, but your results may vary. For data combinations, we put the default
higher (5000) to allow for more data conflicts. Should be integer > 0}

\item{maxTries}{Maximum number of times to run a single GL/intrinsic
bootstrap before exiting with an error. Default is 300; you may want to make
a little higher if your nSim is low and nSamples is high. Set to NULL to
never stop. This parameter was added to prevent setups where some
sample points never land on target sites from running indefinitely}

\item{nBurnin}{For band return data, \code{estTransition} runs a \code{JAGS}
multinomial non-Markovian model, for which it needs the number of burn-in
samples before beginning to store results. Default 5000}

\item{nChains}{For band return data, \code{estTransition} runs a \code{JAGS}
multinomial non-Markovian model, for which it needs the number of MCMC
chains (to test for convergence). Default 3}

\item{nThin}{For band return data, \code{estTransition} runs a \code{JAGS}
multinomial non-Markovian model, for which it needs the thinning rate.
Default 1}
}
\value{
\code{estTransition} returns a list with the elements:
\describe{
  \item{\code{psi}}{List containing estimates of transition probabilities:
  \itemize{
   \item{\code{sample}} Array of sampled values for psi. \code{nSamples} x
     [number of origin sites] x [number of target sites]. Provided to allow
     the user to compute own summary statistics.
   \item{\code{mean}} Main estimate of psi matrix. [number of origin sites]
     x [number of target sites].
   \item{\code{se}} Standard error of psi, estimated from SD of
     \code{psi$sample}.
   \item{\code{simpleCI}} \code{1 - alpha} confidence interval for psi,
     estimated as \code{alpha/2} and \code{1 - alpha/2} quantiles of
     \code{psi$sample}.
   \item{\code{bcCI}} Bias-corrected \code{1 - alpha} confidence interval
     for psi. May be preferable to \code{simpleCI} when \code{mean} is the
     best estimate of psi. \code{simpleCI} is preferred when
     \code{median} is a better estimator. When \code{meanMC==medianMC},
     these should be identical.  Estimated as the
     \code{pnorm(2 * z0 + qnorm(alpha / 2))} and
     \code{pnorm(2 * z0 + qnorm(1 - alpha / 2))} quantiles of \code{sample},
     where z0 is the proportion of \code{sample < mean}.
   \item{\code{median}} Median estimate of psi matrix.
   \item{\code{point}} Simple point estimate of psi matrix, not accounting
     for sampling error.
  }
  }
  \item{\code{r}}{List containing estimates of reencounter probabilities at
   each target site. NULL except when using direct band/ring reencounter
   data.}
  \item{\code{input}}{List containing the inputs to \code{estTransition}.}
  \item{\code{BUGSoutput}}{List containing \code{R2jags} output. Only present
   when using direct band/ring reencounter data.}
}
}
\description{
Estimation and resampling of uncertainty for psi (transition probabilities
between origin sites in one phase of the annual cycle and target sites in
another for migratory animals). Data can be from geolocators (GL) and/or
telemetry/GPS and/or intrinsic markers such as isotopes and genetics OR
band/ring reencounter data.
}
\examples{
\dontrun{
###############################################################################
# Examples 1 (banding data: first example is based on common tern banding data;
#   the second is made up data to demonstrate data with two ages)
###############################################################################
COTE_banded <- c(10360, 1787, 2495, 336)
COTE_reencountered <- matrix(c(12, 0, 38, 15,
                               111, 7, 6, 2,
                               5, 0, 19, 4,
                               1123, 40, 41, 7),
                             4, 4,
                             dimnames = list(LETTERS[1:4], 1:4))
COTE_psi <- estTransition(originNames = LETTERS[1:4],
                          targetNames = 1:4,
                          banded = COTE_banded,
                          reencountered = COTE_reencountered,
                          verbose = 1,
                          nSamples = 60000, nBurnin = 20000)
COTE_psi

COTE_banded2 <- matrix(rep(COTE_banded, 2), 4, 2)
COTE_reencountered2 <- array(c(12, 0, 38, 15, 6, 0, 17, 7,
                               111, 7, 6, 2, 55, 3, 3, 1,
                               5, 0, 19, 4, 2, 0, 10, 2,
                               1123, 40, 41, 7, 660, 20, 20, 3),
                             c(4, 2, 4),
                             dimnames = list(LETTERS[1:4], c("J", "A"), 1:4))
COTE_psi2 <- estTransition(originNames = LETTERS[1:4],
                          targetNames = 1:4,
                          banded = COTE_banded2,
                          reencountered = COTE_reencountered2,
                          verbose = 0,
                          nSamples = 60000, nBurnin = 20000)
COTE_psi2

###############################################################################
# Example 2 (geolocator and telemetry ovenbirds captured on origin sites)
###############################################################################
data(OVENdata) # Ovenbird

nSamplesGLGPS <- 100 # Number of bootstrap iterations
#\dontrun{
#  nSamplesGLGPS <- 10000 # Number of bootstrap iterations
#  install.packages(c('raster', 'maptools', 'rgdal', 'rgeos', 'Rcpp'))
#}

# Estimate MC only, treat all data as geolocator
GL_psi <- estTransition(isGL=TRUE,
                        geoBias = OVENdata$geo.bias,
                        geoVCov = OVENdata$geo.vcov,
                        targetSites = OVENdata$targetSites,
                        originSites = OVENdata$originSites,
                        originPoints = OVENdata$originPoints,
                        targetPoints = OVENdata$targetPoints,
                        verbose = 2,
                        nSamples = nSamplesGLGPS,
                        resampleProjection = sf::st_crs(OVENdata$targetPoints))

# Estimate MC and rM, treat all data as is
Combined.psi <- estTransition(isGL=OVENdata$isGL,
                        isTelemetry = !OVENdata$isGL,
                geoBias = OVENdata$geo.bias, # Light-level GL location bias
                geoVCov = OVENdata$geo.vcov, # Location covariance matrix
                targetSites = OVENdata$targetSites, # Non-breeding target sites
                originSites = OVENdata$originSites, # Breeding origin sites
                originPoints = OVENdata$originPoints, # Capture Locations
                targetPoints = OVENdata$targetPoints, # Device target locations
                verbose = 2,   # output options
                nSamples = nSamplesGLGPS, # This is set low for example
                resampleProjection = sf::st_crs(OVENdata$targetPoints))

print(Combined.psi)

# For treating all data as GPS,
# Move the latitude of birds with locations that fall offshore
int <- sf::st_intersects(OVENdata$targetPoints, OVENdata$targetSites)
any(lengths(int)<1)
plot(OVENdata$targetPoints)
plot(OVENdata$targetSites,add=TRUE)
tp<-sf::st_coordinates(OVENdata$targetPoints)
text(tp[,1], tp[,2], label=c(1:39))

tp[5,2]<- -1899469
tp[10,2]<- -1927848
tp[1,2]<- -1927930
tp[11,2]<- -2026511
tp[15,2]<- -2021268
tp[16,2]<- -1976063

oven_targetPoints<-sf::st_as_sf(as.data.frame(tp),
                                coords = c("X","Y"),
                                crs = sf::st_crs(OVENdata$targetPoints))
inter <- sf::st_intersects(oven_targetPoints, OVENdata$targetSites)
any(lengths(inter)<1)
plot(oven_targetPoints,add=TRUE, col = "green")

# Estimate MC only, treat all data as GPS
GPS_psi <- estTransition(isTelemetry = TRUE,
              targetSites = OVENdata$targetSites, # Non-breeding target sites
              originSites = OVENdata$originSites, # Breeding origin sites
              originPoints = OVENdata$originPoints, # Capture Locations
              targetPoints = oven_targetPoints, # Device target locations
              verbose = 2,   # output options
              nSamples = nSamplesGLGPS) # This is set low for example



###############################################################################
# Example 3 (all released origin; some telemetry, some GL, some probability
# tables, some both GL and probability tables; data modified from ovenbird
# example)
###############################################################################
#\dontrun{
#  install.packages(c('VGAM'))
#}
library(VGAM)
nAnimals <- 40
isGL <- c(OVENdata$isGL, FALSE)
isTelemetry <- c(!OVENdata$isGL, FALSE)
isRaster <- rep(FALSE, nAnimals)
isProb <- rep(FALSE, nAnimals)
targetPoints <- rbind(OVENdata$targetPoints, OVENdata$targetPoints[1,])
targetSites <- OVENdata$targetSites
originSites <- OVENdata$originSites
resampleProjection <- sf::st_crs(OVENdata$targetPoints)
targetNames <- OVENdata$targetNames
originNames <- OVENdata$originNames
targetAssignment <- array(0, dim = c(nAnimals, 3), dimnames = list(NULL, targetNames))
assignment0 <- unclass(sf::st_intersects(x = targetPoints, y = targetSites,
                                         sparse = TRUE))
assignment0[sapply(assignment0, function(x) length(x)==0)] <- 0
assignment0 <- array(unlist(assignment0), nAnimals)
for (ani in 1:nAnimals) {
  if (assignment0[ani]>0)
    targetAssignment[ani, assignment0[ani]] <- 1
  else{
    targetAssignment[ani, ] <- rdiric(1, c(15, 1, 1))
    isProb[ani] <- TRUE
  }
}
targetAssignment
isProb
nSamplesTry <- 100 # Number of bootstrap iterations
originPoints <- rbind(OVENdata$originPoints,
                      OVENdata$originPoints[39,])
system.time(psi3 <-
              estTransition(isGL = isGL, isRaster = isRaster,
                            isProb = isProb,
                            isTelemetry = isTelemetry,
                            geoBias = OVENdata$geo.bias,
                            geoVCov = OVENdata$geo.vcov,
                            targetPoints = targetPoints,
                            targetAssignment = targetAssignment,
                            targetSites = targetSites,
                            resampleProjection = resampleProjection,
                            nSim = 5000, maxTries = 300,
                            originSites = originSites,
                            originPoints = originPoints,
                            captured = "origin",
                            originNames = OVENdata$originNames,
                            targetNames = OVENdata$targetNames,
                            verbose = 3,
                            nSamples = nSamplesTry))
psi3

nNonBreeding <- nrow(OVENdata$targetSites)

plot(psi3, legend = "top",
     main = paste("OVENlike w/", sum(isGL & !isProb), "GL,",
                  sum(!isGL & isProb), "probs,",
                  sum(isGL & isProb), "both, and", sum(isTelemetry), "GPS"),
     col = RColorBrewer::brewer.pal(nNonBreeding, "Dark2"))

################################################################
# Example 4 (add prob animals released on other end)
################################################################
nAnimals <- 45
captured <- rep(c("origin", "target"), c(40, 5))
isGL <- c(OVENdata$isGL, rep(FALSE, 6))
isTelemetry <- c(!OVENdata$isGL, rep(FALSE, 6))
isRaster <- rep(FALSE, nAnimals)
isProb <- rep(FALSE, nAnimals)
targetPoints <- rbind(OVENdata$targetPoints, OVENdata$targetPoints[c(1:4,6:7),])
targetAssignment <- array(0, dim = c(nAnimals, 3), dimnames = list(NULL, targetNames))
assignment0 <- unclass(sf::st_intersects(x = targetPoints, y = targetSites,
                                         sparse = TRUE))
assignment0[sapply(assignment0, function(x) length(x)==0)] <- 0
assignment0 <- array(unlist(assignment0), nAnimals)
assignment0[nAnimals] <- 3
for (ani in 1:nAnimals) {
  if (assignment0[ani]>0)
    targetAssignment[ani, assignment0[ani]] <- 1
  else{
    targetAssignment[ani, ] <- rdiric(1, c(15, 1, 1))
    isProb[ani] <- TRUE
  }
}
targetAssignment
isProb
originPoints <- rbind(OVENdata$originPoints,
                      OVENdata$originPoints[34:39,])

originPoints <- sf::st_transform(originPoints, crs = resampleProjection)
originSites <- sf::st_transform(OVENdata$originSites, crs = resampleProjection)

assignment1 <- unclass(sf::st_intersects(x = originPoints, y = originSites,
                                         sparse = TRUE))
assignment1[sapply(assignment1, function(x) length(x)==0)] <- 0
assignment1 <- array(unlist(assignment1), nAnimals)

nOriginSites <- nrow(originSites)

originAssignment <- array(0, dim = c(nAnimals, nOriginSites),
                          dimnames = list(NULL, originNames))
for (ani in 1:40) {
  originAssignment[ani, assignment1[ani]] <- 1
}
for (ani in 41:nAnimals) {
  originAssignment[ani, ] <- rdiric(1, c(1, 1))
  isProb[ani] <- TRUE
}
originAssignment
isProb
system.time(psi4 <-
              estTransition(isGL = isGL, isRaster = isRaster,
                            isProb = isProb,
                            isTelemetry = isTelemetry,
                            geoBias = OVENdata$geo.bias,
                            geoVCov = OVENdata$geo.vcov,
                            targetPoints = targetPoints,
                            targetAssignment = targetAssignment,
                            targetSites = targetSites,
                            resampleProjection = resampleProjection,
                            nSim = 5000, maxTries = 300,
                            originSites = originSites,
                            originAssignment = originAssignment,
                            captured = captured,
                            originNames = OVENdata$originNames,
                            targetNames = OVENdata$targetNames,
                            verbose = 3,
                            nSamples = nSamplesTry))
psi4

plot(psi4, legend = "top",
     main = paste(sum(isGL & !isProb), "GL,",
                  sum(!isGL & isProb & captured == "origin"), "prob,",
                  sum(isGL & isProb), "both,",
                  sum(isTelemetry), "GPS (all\ncaptured origin), and",
                  sum(isProb & captured == "target"), "probs (captured target)"),
     col = RColorBrewer::brewer.pal(nNonBreeding, "Dark2"))
MC4 <- estStrength(OVENdata$originDist, OVENdata$targetDist,
                                     OVENdata$originRelAbund, psi4,
                                     sampleSize = nAnimals)
MC4

###############################################################################
# Example 5 (all raster, from our OVEN example)
###############################################################################
getCSV <- function(filename) {
  tmp <- tempdir()
  url1 <- paste0('https://github.com/SMBC-NZP/MigConnectivity/blob/isodev/data-raw/',
                 filename, '?raw=true')
  temp <- paste(tmp, filename, sep = '/')
  utils::download.file(url1, temp, mode = 'wb')
  csv <- read.csv(temp)
  unlink(temp)
  return(csv)

}
getRDS <- function(speciesDist) {
  tmp <- tempdir()
  extension <- '.rds'
  filename <- paste0(speciesDist, extension)
  url1 <- paste0('https://github.com/SMBC-NZP/MigConnectivity/blob/isodev/data-raw/Spatial_Layers/',
                 filename, '?raw=true')
  temp <- paste(tmp, filename, sep = '/')
  utils::download.file(url1, temp, mode = 'wb')
  shp <- readRDS(temp)
  unlink(temp)
  return(shp)
}
OVENdist <- getRDS("OVENdist")

raster::crs(OVENdist) <- MigConnectivity::projections$WGS84

OVENdist <- sf::st_as_sf(OVENdist)

OVENvals <- getCSV("deltaDvalues.csv")

OVENvals <- OVENvals[grep(x=OVENvals$Sample,"NH", invert = TRUE),]

originSites <- getRDS("originSites")
originSites <- sf::st_as_sf(originSites)

EVER <- length(grep(x=OVENvals$Sample,"EVER"))
JAM <- length(grep(x=OVENvals$Sample,"JAM"))

originRelAbund <- matrix(c(EVER,JAM),nrow = 1,byrow = TRUE)
originRelAbund <- prop.table(originRelAbund,1)

op <- sf::st_centroid(originSites)

originPoints <- array(NA,c(EVER+JAM,2), list(NULL, c("x","y")))
originPoints[grep(x = OVENvals$Sample,"JAM"),1] <- sf::st_coordinates(op)[1,1]
originPoints[grep(x = OVENvals$Sample,"JAM"),2] <- sf::st_coordinates(op)[1,2]
originPoints[grep(x = OVENvals$Sample,"EVER"),1] <- sf::st_coordinates(op)[2,1]
originPoints[grep(x = OVENvals$Sample,"EVER"),2] <- sf::st_coordinates(op)[2,2]

originPoints <- sf::st_as_sf(data.frame(originPoints),
                             coords = c("x", "y"),
                             crs = sf::st_crs(originSites))

iso <- isoAssign(isovalues = OVENvals[,2],
                 isoSTD = 12,       # this value is for demonstration only
                 intercept = -10,   # this value is for demonstration only
                 slope = 0.8,       # this value is for demonstration only
                 odds = NULL,
                 restrict2Likely = FALSE,
                 nSamples = 1000,
                 sppShapefile = OVENdist,
                 assignExtent = c(-179,-60,15,89),
                 element = "Hydrogen",
                 surface = FALSE,
                 period = "Annual",
                 seed = 12345,
                 verbose=1)

nAnimals <- dim(iso$probassign)[3]
isGL <-rep(F, nAnimals); isRaster <- rep(T, nAnimals)
isProb <- rep(F, nAnimals); isTelemetry <- rep(F, nAnimals)
targetSites <- rgeos::gUnaryUnion(iso$targetSites, id = iso$targetSites$targetSite)
targetSites <- sf::st_as_sf(targetSites)


system.time(psi5 <-
              estTransition(isGL = isGL,
                            isRaster = isRaster,
                            isProb = isProb,
                            isTelemetry = isTelemetry,
                            targetSites = targetSites,
                            resampleProjection = resampleProjection,
                            targetRaster = iso,
                            originSites = originSites,
                            originPoints = originPoints,
                            captured = rep("origin", nAnimals),
                            verbose = 3,
                            nSamples = nSamplesTry))
psi5
}
}
\seealso{
\code{\link{estStrength}}, \code{\link{plot.estMigConnectivity}},
  \code{\link{estMC}}, \code{\link{estMantel}}
}
