% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estConnectivity.R
\name{estTransition}
\alias{estTransition}
\title{Estimate psi (transition probabilities between locations in two phases of
the annual cycle)}
\usage{
estTransition(
  originSites = NULL,
  targetSites = NULL,
  originPoints = NULL,
  targetPoints = NULL,
  originAssignment = NULL,
  targetAssignment = NULL,
  originNames = NULL,
  targetNames = NULL,
  nSamples = 1000,
  isGL = FALSE,
  isTelemetry = FALSE,
  isRaster = FALSE,
  isProb = FALSE,
  captured = "origin",
  geoBias = NULL,
  geoVCov = NULL,
  geoBiasOrigin = NULL,
  geoVCovOrigin = NULL,
  targetRaster = NULL,
  originRaster = NULL,
  banded = NULL,
  reencountered = NULL,
  verbose = 0,
  alpha = 0.05,
  resampleProjection = "ESRI:54027",
  nSim = ifelse(any(isRaster & isGL) || any(isRaster & isProb) || any(isGL & isProb),
    5000, ifelse(any(isGL), 1000, ifelse(any(isRaster), 10, 1))),
  maxTries = 300,
  nBurnin = 5000,
  nChains = 3,
  nThin = 1
)
}
\arguments{
\item{originSites}{the geographic definition of sites in the origin season.
Mike, fill in options here (sf/sp/whatever)}

\item{targetSites}{the geographic definition of sites in the target season.
Mike, fill in options here (sf/sp/whatever)}

\item{originPoints}{A \code{sf} or \code{SpatialPoints} object, with number
of rows or length being the number of animals tracked. Each point indicates
the origin location of an animal (or point estimate of same, for GL animals
released on target sites). Note that to simplify input of multiple
data types both between and for the same animal, if origin points are
provided for any animal, they must be provided for all (can be dummy values)}

\item{targetPoints}{For GL or telemetry data, a \code{sf} or
\code{SpatialPoints} object, with length or number of rows number of animals
tracked. Each point indicates the point estimate location of an animal in
the target season. Note that to simplify input of multiple
data types both between and for the same animal, if target points are
provided for any animal, they must be provided for all (can be dummy values)}

\item{originAssignment}{Assignment of animals to origin season sites. Either
an integer vector with length number of animals tracked or a matrix of
probabilities with number of animals tracked rows and number of origin sites
columns (and rows summing to 1). The latter only applies to animals released
in the target sites where there is uncertainty about their origin site, for
example from genetic population estimates from the rubias package.
Optional, but some combination of these inputs should be defined. Note that
if \code{originAssignment} is a probability table, animals with known origin
sites can have 1 in that column and 0s in all others}

\item{targetAssignment}{Assignment of animals to target season sites. Either
an integer vector with length number of animals tracked or a matrix of
probabilities with number of animals tracked rows and number of target sites
columns (and rows summing to 1). The latter only applies to animals released
in the origin sites where there is uncertainty about their target site, for
example from genetic population estimates from the rubias package.
Optional, but some combination of these inputs needs to be defined. Note
that if \code{targetAssignment} is a probability table, animals with known
target sites can have 1 in that column and 0s in all others}

\item{originNames}{Optional, but recommended to keep track. Vector of names
for the origin sites. If not provided, the function will either try to get
these from another input or provide default names (capital letters)}

\item{targetNames}{Optional, but recommended to keep track. Vector of names
for the target sites. If not provided, the function will either try to get
these from another input or provide default names (numbers)}

\item{nSamples}{Number of post-burn-in MCMC samples to store (band
data) OR number of bootstrap runs for GL, telemetry, probability assignment,
and/or raster data. In the latter case, animals are sampled with replacement
for each. For all, the purpose is to estimate sampling uncertainty}

\item{isGL}{Indicates whether or which animals were tracked with geolocators.
Should be either single TRUE or FALSE value, or vector with length of
number of animals tracked, with TRUE or FALSE for each animal in data. For
TRUE animals, the model applies \code{geoBias} and \code{geoVCov} to
\code{targetPoints} where \code{captured} == "origin" or "neither" and
\code{geoBiasOrigin} and \code{geoVCovOrigin} to
\code{originPoints} where \code{captured} == "target" or "neither"}

\item{isTelemetry}{Indicates whether or which animals were tracked with
telemetry/GPS (no location uncertainty on either end).
Should be either single TRUE or FALSE value, or vector with length of
number of animals tracked, with TRUE or FALSE for each animal in data}

\item{isRaster}{Indicates whether or which animals were tracked with
intrinsic markers (e.g., genetics or isotopes), with location uncertainty
expressed as a raster of probabilities by grid cells, either in
\code{targetRaster} or \code{originRaster}. Should be either single TRUE or
FALSE value, or vector with length of number of animals tracked, with TRUE
or FALSE for each animal in data}

\item{isProb}{Indicates whether or which animals were tracked with
intrinsic markers (e.g., genetics or isotopes), with location uncertainty
expressed as a probability table, either in \code{targetAssignment} or
\code{originAssignment}. Should be either single TRUE or FALSE value, or vector
with length of number of animals tracked, with TRUE or FALSE for each animal
in data}

\item{captured}{Indicates whether or which animals were captured in the
origin sites, the target sites, or neither (another phase of the annual
cycle). Location uncertainty will only be applied where the animal was not
captured. So this doesn't matter for telemetry data, and is assumed to be
"origin" for band return data. Should be either single "origin" (default),
"target", or "neither" value, or a character vector with length of number of
animals tracked, with "origin", "target", or "neither" for each animal}

\item{geoBias}{For GL data, vector of length 2 indicating expected bias
in longitude and latitude of \code{targetPoints}, in
\code{resampleProjection} units (default meters)}

\item{geoVCov}{For GL data, 2x2 matrix with expected variance/covariance
in longitude and latitude of \code{targetPoints}, in
\code{resampleProjection} units (default meters)}

\item{geoBiasOrigin}{For GL data where \code{captured}!="origin", vector of
length 2 indicating expected bias in longitude and latitude of
\code{originPoints}, in
\code{resampleProjection} units (default meters)}

\item{geoVCovOrigin}{For GL data where \code{captured}!="origin", 2x2 matrix
with expected variance/covariance in longitude and latitude of
\code{targetPoints}, in \code{resampleProjection} units (default meters)}

\item{targetRaster}{For intrinsic tracking data, the results of
\code{isoAssign} or a similar function of class \code{intrinsicAssign} or
class \code{RasterBrick}/\code{RasterStack}, for example from the package
\code{assignR}. In any case, it expresses location uncertainty on target
range, through a raster of probabilities by grid cells}

\item{originRaster}{For intrinsic tracking data, the results of
\code{isoAssign} or a similar function of class \code{intrinsicAssign} or
class \code{RasterBrick}/\code{RasterStack}, for example from the package
\code{assignR}. In any case, it expresses location uncertainty on origin
range, through a raster of probabilities by grid cells}

\item{banded}{For band return data, a vector or matrix of the number of
released animals from each origin site (including those never reencountered
in a target site). If a matrix, the second dimension is taken as the number
of age classes of released animals; the model estimates reencounter
probability by age class but assumes transition probabilities are the same}

\item{reencountered}{For band return data, either a matrix with B rows and W
columns or a B x [number of ages] x W array. Number of animals reencountered
on each target site (by age class banded as) by origin site they came from}

\item{verbose}{0 (default) to 3. 0 prints no output during run (except on
convergence for banding data). 1 prints an update every 100 samples or
bootstraps (or a status bar for banding data).  2 prints an update
every sample or bootstrap. 3 also prints the number of
draws (for tuning nSim for GL/intrinsic data only)}

\item{alpha}{Level for confidence/credible intervals provided. Default (0.05)
gives 95 percent CI}

\item{resampleProjection}{Projection when sampling from location uncertainty.
Default is Equidistant Conic. The default setting preserves distances
around latitude = 0 and longitude = 0. Other projections may work well,
depending on the location of sites. Ignored unless data are geolocator,
telemetry, or intrinsic}

\item{nSim}{Tuning parameter for GL or intrinsic data. Affects only the
speed; 1000 seems to work well with our GL data and 10 for our intrinsic
data, but your results may vary. For data combinations, we put the default
higher (5000) to allow for more data conflicts. Should be integer > 0}

\item{maxTries}{Maximum number of times to run a single GL/intrinsic
bootstrap before exiting with an error. Default is 300; you may want to make
a little higher if your nSim is low and nSamples is high. Set to NULL to
never stop. This parameter was added to prevent setups where some
sample points never land on target sites from running indefinitely}

\item{nBurnin}{For band return data, \code{estTransition} runs a \code{JAGS}
multinomial non-Markovian model, for which it needs the number of burn-in
samples before beginning to store results. Default 5000}

\item{nChains}{For band return data, \code{estTransition} runs a \code{JAGS}
multinomial non-Markovian model, for which it needs the number of MCMC
chains (to test for convergence). Default 3}

\item{nThin}{For band return data, \code{estTransition} runs a \code{JAGS}
multinomial non-Markovian model, for which it needs the thinning rate.
Default 1}
}
\value{
\code{estMC} returns a list with the elements:
\describe{
  \item{\code{psi}}{List containing estimates of transition probabilities:
  \itemize{
   \item{\code{sample}} Array of sampled values for psi. \code{nSamples} x
     [number of origin sites] x [number of target sites]. Provided to allow
     the user to compute own summary statistics.
   \item{\code{mean}} Main estimate of psi matrix. [number of origin sites]
     x [number of target sites].
   \item{\code{se}} Standard error of psi, estimated from SD of
     \code{psi$sample}.
   \item{\code{simpleCI}} \code{1 - alpha} confidence interval for psi,
     estimated as \code{alpha/2} and \code{1 - alpha/2} quantiles of
     \code{psi$sample}.
   \item{\code{bcCI}} Bias-corrected \code{1 - alpha} confidence interval
     for psi. May be preferable to \code{simpleCI} when \code{mean} is the
     best estimate of psi. \code{simpleCI} is preferred when
     \code{median} is a better estimator. When \code{meanMC==medianMC},
     these should be identical.  Estimated as the
     \code{pnorm(2 * z0 + qnorm(alpha / 2))} and
     \code{pnorm(2 * z0 + qnorm(1 - alpha / 2))} quantiles of \code{sample},
     where z0 is the proportion of \code{sample < mean}.
   \item{\code{median}} Median estimate of psi matrix.
   \item{\code{point}} Simple point estimate of psi matrix, not accounting
     for sampling error.
  }
  }
  \item{\code{r}}{List containing estimates of reencounter probabilities at
   each target site. NULL except when using direct band/ring reencounter
   data.}
  \item{\code{input}}{List containing the inputs to \code{estTransition}.}
  \item{\code{BUGSoutput}}{List containing \code{R2jags} output. Only present
   when using direct band/ring reencounter data.}
}
}
\description{
Estimation and resampling of uncertainty for psi (transition probabilities
between origin sites in one phase of the annual cycle and target sites in
another for migratory animals). Data can be from geolocators (GL) and/or
telemetry/GPS and/or intrinsic markers such as isotopes and genetics OR
band/ring reencounter data.
}
\examples{
# Test new code for sampling different types of data
###############################################################################
# Example 1 (all released origin; some telemetry, some GL, some prob
# some both GL and prob)
###############################################################################
library(VGAM)
library(MigConnectivity)
nAnimals <- 40
isGL <- c(OVENdata$isGL, FALSE)
#isGL[5] <- FALSE
isTelemetry <- c(!OVENdata$isGL, FALSE)
isRaster <- rep(FALSE, nAnimals)
isProb <- rep(FALSE, nAnimals)
targetPoints <- rbind(OVENdata$targetPoints, OVENdata$targetPoints[1,])
targetSites <- OVENdata$targetSites
originSites <- OVENdata$originSites
resampleProjection <- sf::st_crs(OVENdata$targetPoints)
targetPoints <- sf::st_transform(targetPoints, crs = resampleProjection)
targetSites <- sf::st_transform(targetSites, crs = resampleProjection)
targetNames <- OVENdata$targetNames
originNames <- OVENdata$originNames
targetAssignment <- array(0, dim = c(nAnimals, 3), dimnames = list(NULL, targetNames))
assignment0 <- unclass(sf::st_intersects(x = targetPoints, y = targetSites,
                                         sparse = TRUE))
assignment0[sapply(assignment0, function(x) length(x)==0)] <- 0
assignment0 <- array(unlist(assignment0), nAnimals)
for (ani in 1:nAnimals) {
  if (assignment0[ani]>0)
    targetAssignment[ani, assignment0[ani]] <- 1
  else{
    targetAssignment[ani, ] <- rdiric(1, c(15, 1, 1))
    isProb[ani] <- TRUE
  }
}
targetAssignment
isProb
system.time(test <- MigConnectivity:::locSample(isGL, isRaster, isProb, isTelemetry,
                  geoBias = OVENdata$geo.bias, #[, 2:1, drop = FALSE]
                  geoVCov = OVENdata$geo.vcov,#*1.5,#[2:1,2:1]
                  points = targetPoints, assignment = targetAssignment,
                  sites = targetSites, resampleProjection = resampleProjection,
                  nSim = 20000, maxTries = 300))
test
originPoints <- rbind(OVENdata$originPoints,
                      OVENdata$originPoints[39,])
originPoints <- sf::st_transform(originPoints, crs = resampleProjection)
originSites <- sf::st_transform(OVENdata$originSites, crs = resampleProjection)
system.time(test2 <-
              estTransition(isGL = isGL, isRaster = isRaster,
                                              isProb = isProb,
                                              isTelemetry = isTelemetry,
                                              geoBias = OVENdata$geo.bias, #[, 2:1, drop = FALSE]
                                              geoVCov = OVENdata$geo.vcov,#*1.5,#[2:1,2:1]
                                              targetPoints = targetPoints,
                                              targetAssignment = targetAssignment,
                                              targetSites = targetSites,
                                              resampleProjection = resampleProjection,
                                              nSim = 5000, maxTries = 300,
                                              originSites = originSites,
                                              originPoints = originPoints,
                                              captured = "origin",
                                              originNames = OVENdata$originNames,
                                              targetNames = OVENdata$targetNames,
                                              verbose = 3,
                                              nSamples = 1000))
test2
plot(test2, legend = "top",
     main = paste("OVENlike w/", sum(isGL & !isProb), "GL,",
                  sum(!isGL & isProb), "probs,",
                  sum(isGL & isProb), "both, and", sum(isTelemetry), "GPS"),
     col = RColorBrewer::brewer.pal(nNonBreeding, "Dark2"))
plot(targetPoints)
plot(targetSites, add = T)
plot(targetSites)
plot(targetPoints[isProb & isGL, ], add = T, col = 1:sum(isProb & isGL))

################################################################
# Example 2 (add prob animals released on other end)
################################################################
nAnimals <- 45
captured <- rep(c("origin", "target"), c(40, 5))
isGL <- c(OVENdata$isGL, rep(FALSE, 6))
#isGL[5] <- FALSE
isTelemetry <- c(!OVENdata$isGL, rep(FALSE, 6))
isRaster <- rep(FALSE, nAnimals)
isProb <- rep(FALSE, nAnimals)
targetPoints <- rbind(OVENdata$targetPoints, OVENdata$targetPoints[c(1:4,6:7),])
targetSites <- OVENdata$targetSites
originSites <- OVENdata$originSites
resampleProjection <- sf::st_crs(OVENdata$targetPoints)
targetPoints <- sf::st_transform(targetPoints, crs = resampleProjection)
targetSites <- sf::st_transform(targetSites, crs = resampleProjection)
targetNames <- OVENdata$targetNames
originNames <- OVENdata$originNames
targetAssignment <- array(0, dim = c(nAnimals, 3), dimnames = list(NULL, targetNames))
assignment0 <- unclass(sf::st_intersects(x = targetPoints, y = targetSites,
                                         sparse = TRUE))
assignment0[sapply(assignment0, function(x) length(x)==0)] <- 0
assignment0 <- array(unlist(assignment0), nAnimals)
assignment0[nAnimals] <- 3
for (ani in 1:nAnimals) {
  if (assignment0[ani]>0)
    targetAssignment[ani, assignment0[ani]] <- 1
  else{
    targetAssignment[ani, ] <- rdiric(1, c(15, 1, 1))
    isProb[ani] <- TRUE
  }
}
targetAssignment
isProb
originPoints <- rbind(OVENdata$originPoints,
                      OVENdata$originPoints[34:39,])

originPoints <- sf::st_transform(originPoints, crs = resampleProjection)
originSites <- sf::st_transform(OVENdata$originSites, crs = resampleProjection)

assignment1 <- unclass(sf::st_intersects(x = originPoints, y = originSites,
                                         sparse = TRUE))
assignment1[sapply(assignment1, function(x) length(x)==0)] <- 0
assignment1 <- array(unlist(assignment1), nAnimals)

nOriginSites <- nrow(originSites)

originAssignment <- array(0, dim = c(nAnimals, nOriginSites),
                          dimnames = list(NULL, originNames))
for (ani in 1:40) {
  originAssignment[ani, assignment1[ani]] <- 1
}
for (ani in 41:nAnimals) {
  originAssignment[ani, ] <- rdiric(1, c(1, 1))
  isProb[ani] <- TRUE
}
originAssignment
isProb
system.time(test3 <-
              estTransition(isGL = isGL, isRaster = isRaster,
                                              isProb = isProb,
                                              isTelemetry = isTelemetry,
                                              geoBias = OVENdata$geo.bias, #[, 2:1, drop = FALSE]
                                              geoVCov = OVENdata$geo.vcov,#*1.5,#[2:1,2:1]
                                              targetPoints = targetPoints,
                                              targetAssignment = targetAssignment,
                                              targetSites = targetSites,
                                              resampleProjection = resampleProjection,
                                              nSim = 5000, maxTries = 300,
                                              originSites = originSites,
                                              #originPoints = originPoints,
                                              originAssignment = originAssignment,
                                              captured = captured,
                                              originNames = OVENdata$originNames,
                                              targetNames = OVENdata$targetNames,
                                              verbose = 3,
                                              nSamples = 100))
test3

nNonBreeding <- nrow(OVENdata$targetSites)

plot(test3, legend = "top",
     main = paste(sum(isGL & !isProb), "GL,",
                  sum(!isGL & isProb & captured == "origin"), "prob,",
                  sum(isGL & isProb), "both,",
                  sum(isTelemetry), "GPS (all\ncaptured origin), and",
                  sum(isProb & captured == "target"), "probs (captured target)"),
     col = RColorBrewer::brewer.pal(nNonBreeding, "Dark2"))
MC3 <- MigConnectivity:::estStrength(OVENdata$originDist, OVENdata$targetDist,
                                     OVENdata$originRelAbund, test3,
                                     sampleSize = nAnimals)
MC3

###############################################################################
# Example 3 (all raster, from our OVEN example)
###############################################################################
getCSV <- function(filename) {
  tmp <- tempdir()
  url1 <- paste0('https://github.com/SMBC-NZP/MigConnectivity/blob/isodev/data-raw/',
                 filename, '?raw=true')
  temp <- paste(tmp, filename, sep = '/')
  utils::download.file(url1, temp, mode = 'wb')
  csv <- read.csv(temp)
  unlink(temp)
  return(csv)

}
getRDS <- function(speciesDist) {
  tmp <- tempdir()
  extension <- '.rds'
  filename <- paste0(speciesDist, extension)
  url1 <- paste0('https://github.com/SMBC-NZP/MigConnectivity/blob/isodev/data-raw/Spatial_Layers/',
                 filename, '?raw=true')
  temp <- paste(tmp, filename, sep = '/')
  utils::download.file(url1, temp, mode = 'wb')
  shp <- readRDS(temp)
  unlink(temp)
  return(shp)
}
OVENdist <- getRDS("OVENdist")

raster::crs(OVENdist) <- MigConnectivity::projections$WGS84

OVENdist <- sf::st_as_sf(OVENdist)

OVENvals <- getCSV("deltaDvalues.csv")

OVENvals <- OVENvals[grep(x=OVENvals$Sample,"NH", invert = TRUE),]

originSites <- getRDS("originSites")
originDist <- distFromPos(rgeos::gCentroid(originSites,byid = TRUE)@coords)
originSites <- sf::st_as_sf(originSites)

EVER <- length(grep(x=OVENvals$Sample,"EVER"))
JAM <- length(grep(x=OVENvals$Sample,"JAM"))

originRelAbund <- matrix(c(EVER,JAM),nrow = 1,byrow = TRUE)
originRelAbund <- prop.table(originRelAbund,1)

op <- sf::st_centroid(originSites)

originPoints <- array(NA,c(EVER+JAM,2), list(NULL, c("x","y")))
originPoints[grep(x = OVENvals$Sample,"JAM"),1] <- sf::st_coordinates(op)[1,1]
originPoints[grep(x = OVENvals$Sample,"JAM"),2] <- sf::st_coordinates(op)[1,2]
originPoints[grep(x = OVENvals$Sample,"EVER"),1] <- sf::st_coordinates(op)[2,1]
originPoints[grep(x = OVENvals$Sample,"EVER"),2] <- sf::st_coordinates(op)[2,2]

originPoints <- sf::st_as_sf(data.frame(originPoints),
                             coords = c("x", "y"),
                             crs = 4326)

iso <- isoAssign(isovalues = OVENvals[,2],
                 isoSTD = 12,       # this value is for demonstration only
                 intercept = -10,   # this value is for demonstration only
                 slope = 0.8,       # this value is for demonstration only
                 odds = NULL,
                 restrict2Likely = FALSE,
                 nSamples = 1000,
                 sppShapefile = OVENdist,
                 assignExtent = c(-179,-60,15,89),
                 element = "Hydrogen",
                 surface = FALSE,
                 period = "Annual",
                 seed = 12345,
                 verbose=1)

nAnimals <- dim(iso$probassign)[3]
isGL <-rep(F, nAnimals); isRaster <- rep(T, nAnimals)
isProb <- rep(F, nAnimals); isTelemetry <- rep(F, nAnimals)
targetSites <- rgeos::gUnaryUnion(iso$targetSites, id = iso$targetSites$targetSite)
targetSites <- sf::st_as_sf(targetSites)


system.time(test4 <-
              estTransition(isGL = isGL,
                                              isRaster = isRaster,
                                              isProb = isProb,
                                              isTelemetry = isTelemetry,
                                              #geoBias = OVENdata$geo.bias, #[, 2:1, drop = FALSE]
                                              #geoVCov = OVENdata$geo.vcov,#*1.5,#[2:1,2:1]
                                              #targetPoints = targetPoints,
                                              #targetAssignment = targetAssignment,
                                              targetSites = targetSites,
                                              resampleProjection = resampleProjection,
                                              targetRaster = iso,
                                              #nSim = 5000, maxTries = 300,
                                              originSites = originSites,
                                              originPoints = originPoints,
                                              #originAssignment = originAssignment,
                                              captured = rep("origin", nAnimals),
                                              #originNames = OVENdata$originNames,
                                              #targetNames = OVENdata$targetNames,
                                              verbose = 3,
                                              nSamples = 1000))
test4

ovenMC <- estMC(originRelAbund = originRelAbund,
                targetIntrinsic = iso,
                originPoints = originPoints,
                originSites = originSites,
                targetSites = targetSites,
                originDist = originDist,
                nSamples = 200,
                verbose = 1,
                calcCorr = TRUE,
                alpha = 0.05,
                approxSigTest = FALSE,
                isIntrinsic = TRUE)
ovenMC

test4$psi$mean - ovenMC$psi$mean
test4$psi$se - ovenMC$psi$se

iso2 <- iso
iso2$SingleCell <- NULL
something <- MigConnectivity:::locSample(isGL = isGL,
                                             isRaster = isRaster,
                                             isProb = isProb,
                                             isTelemetry = isTelemetry,
                                             #geoBias = OVENdata$geo.bias, #[, 2:1, drop = FALSE]
                                             #geoVCov = OVENdata$geo.vcov,#*1.5,#[2:1,2:1]
                                             #targetPoints = targetPoints,
                                             #targetAssignment = targetAssignment,
                                             sites = targetSites,
                                             resampleProjection = resampleProjection,
                                             matvals = raster::rasterToPoints(iso2$probassign),
                                            nSim = 10, maxTries = 300,
                                         assignment = targetAssignment)

system.time(test5 <-
              estTransition(isGL = isGL,
                                              isRaster = isRaster,
                                              isProb = isProb,
                                              isTelemetry = isTelemetry,
                                              #geoBias = OVENdata$geo.bias, #[, 2:1, drop = FALSE]
                                              #geoVCov = OVENdata$geo.vcov,#*1.5,#[2:1,2:1]
                                              #targetPoints = targetPoints,
                                              #targetAssignment = targetAssignment,
                                              targetSites = targetSites,
                                              resampleProjection = resampleProjection,
                                              targetRaster = iso2,
                                              #nSim = 5000, maxTries = 300,
                                              originSites = originSites,
                                              originPoints = originPoints,
                                              #originAssignment = originAssignment,
                                              captured = rep("origin", nAnimals),
                                              #originNames = OVENdata$originNames,
                                              #targetNames = OVENdata$targetNames,
                                              verbose = 3,
                                              nSamples = 200))
test5$psi$mean
test4$psi$mean - test5$psi$mean
test4$psi$se - test5$psi$se

ovenMC5 <- suppressMessages(estMC(originRelAbund = originRelAbund,
                targetIntrinsic = iso2,
                originPoints = originPoints,
                originSites = originSites,
                targetSites = targetSites,
                originDist = originDist,
                nSamples = 200,
                verbose = 1,
                calcCorr = F,
                alpha = 0.05,
                approxSigTest = FALSE,
                isIntrinsic = TRUE))
ovenMC5
test4$psi$mean - ovenMC5$psi$mean
test5$psi$mean - ovenMC5$psi$mean
ovenMC$psi$mean - ovenMC5$psi$mean
test4$psi$se - ovenMC5$psi$se



# Don't run, only works if you've run a bunch of stuff from within functions
ts <- sf::st_transform(targetSites, resampleProjection)
ps2 <- lapply(point.sample2, sf::st_transform, crs = resampleProjection)
tar <- sf::st_transform(targetAssignRast, resampleProjection)

plot(ts)
for(i in 2) {
  plot(ps2[[i]], col = RColorBrewer::brewer.pal(7, "Dark2")[i], add = T)
}
plot(tar[1:7, ], col = RColorBrewer::brewer.pal(7, "Dark2"), add = T, pch = 19)
sc1 <- sf::st_as_sf(as.data.frame(iso$SingleCell[,,1]), coords = c("Longitude", "Latitude"),
                    crs = MigConnectivity::projections$WGS84)
sc1 <- sf::st_transform(sc1, resampleProjection)
plot(sc1, col = RColorBrewer::brewer.pal(7, "Dark2")[1], add = T, pch = 5)
sc2 <- sf::st_as_sf(as.data.frame(iso$SingleCell[,,2]), coords = c("Longitude", "Latitude"),
                    crs = MigConnectivity::projections$WGS84)
sc2 <- sf::st_transform(sc2, resampleProjection)
plot(sc2, col = RColorBrewer::brewer.pal(7, "Dark2")[2], add = T, pch = 5, alpha = 0.5)

###############################################################################
# Example 4 (raster plus prob tables) (haven't gotten far setting this one up)
###############################################################################
isProb <- rep(c(F, T), c(20, nAnimals - 20))
nTargetSites <- nrow(targetSites)
targetAssignment <- rdiric(nAnimals, rep(1, nTargetSites))
targetAssignment
isProb
system.time(test6 <-
              estTransition(isGL = isGL,
                            isRaster = isRaster,
                            isProb = isProb,
                            isTelemetry = isTelemetry,
                            #geoBias = OVENdata$geo.bias, #[, 2:1, drop = FALSE]
                            #geoVCov = OVENdata$geo.vcov,#*1.5,#[2:1,2:1]
                            #targetPoints = targetPoints,
                            targetAssignment = targetAssignment,
                            targetSites = targetSites,
                            resampleProjection = resampleProjection,
                            targetRaster = iso,
                            nSim = 1000, maxTries = 300,
                            originSites = originSites,
                            originPoints = originPoints,
                            #originAssignment = originAssignment,
                            captured = rep("origin", nAnimals),
                            #originNames = OVENdata$originNames,
                            #targetNames = OVENdata$targetNames,
                            verbose = 3,
                            nSamples = 200))
# something <- MigConnectivity:::locSample(isGL = isGL,
#                                          isRaster = isRaster,
#                                          isProb = isProb,
#                                          isTelemetry = isTelemetry,
#                                          sites = targetSites,
#                                          resampleProjection = resampleProjection,
#                                          matvals = raster::rasterToPoints(iso$probassign),
#                                          singleCell = iso$SingleCell,
#                                          nSim = 10, maxTries = 300,
#                                          assignment = targetAssignment)
test6
test6$psi$mean - test4$psi$mean
system.time(test7 <-
              estTransition(isGL = isGL,
                            isRaster = isRaster,
                            isProb = isProb,
                            isTelemetry = isTelemetry,
                            #geoBias = OVENdata$geo.bias, #[, 2:1, drop = FALSE]
                            #geoVCov = OVENdata$geo.vcov,#*1.5,#[2:1,2:1]
                            #targetPoints = targetPoints,
                            targetAssignment = targetAssignment,
                            targetSites = targetSites,
                            resampleProjection = resampleProjection,
                            targetRaster = iso2,
                            nSim = 200, maxTries = 300,
                            originSites = originSites,
                            originPoints = originPoints,
                            #originAssignment = originAssignment,
                            captured = rep("origin", nAnimals),
                            #originNames = OVENdata$originNames,
                            #targetNames = OVENdata$targetNames,
                            verbose = 3,
                            nSamples = 10))
test7
test7$psi$mean - test5$psi$mean
}
