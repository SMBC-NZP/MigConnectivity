% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/estConnectivity.R
\name{estMC}
\alias{estMC}
\title{Estimate MC from abundance and/or transition probability estimates OR
geolocator and/or GPS data.}
\usage{
estMC(originDist, targetDist, originRelAbund, psi = NULL,
  originSites = NULL, targetSites = NULL, originPoints = NULL,
  targetPoints = NULL, originAssignment = NULL, targetAssignment = NULL,
  originNames = NULL, targetNames = NULL, nSamples = 1000, nSim = 1000,
  isGL = FALSE, geoBias = NULL, geoVCov = NULL, row0 = 0, verbose = 0,
  calcCorr = FALSE, alpha = 0.05)
}
\arguments{
\item{originDist}{Distances between the B origin sites.  Symmetric B by B
matrix.}

\item{targetDist}{Distances between the W target sites.  Symmetric W by W
matrix.}

\item{originRelAbund}{Relative abundance estimates at B origin sites. Either
a numeric vector of length B that sums to 1 or an mcmc object with
\code{nSamples} rows  and columns including 'relN[1]' through 'relN[B]'.
Currently, an mcmc object doesn't work with geolocator or GPS data.}

\item{psi}{Transition probabilities between B origin and W target sites.
Either a matrix with B rows and W columns where rows sum to 1 or a MARK
object with estimates of transition probabilities.  If you are estimating
MC from GPS or geolocator data, leave this as NULL.}

\item{originSites}{If \code{psi} is a MARK object, this must be a numeric
vector indicating which sites are origin.  If using GL or GPS data,
this can be the geographic definition of sites in the release season.}

\item{targetSites}{If \code{psi} is a MARK object, this must be a numeric
vector indicating which sites are target.  If using GL or GPS data,
this must be the geographic definition of sites in the non-release season.}

\item{originPoints}{A \code{SpatialPoints} object, with length number of
animals tracked.  Each point indicates the release location of an animal.}

\item{targetPoints}{A \code{SpatialPoints} object, with length number of
animals tracked.  Each point indicates the point estimate location in
the non-release season.}

\item{originAssignment}{Assignment of \code{originPoints} to release season
sites. Integer vector with length number of animals tracked. Optional,
but if using GL or GPS data, either \code{originAssignment} or
\code{originSites} and \code{originPoints} should be defined.}

\item{targetAssignment}{Optional. Point estimate assignment of
\code{targetPoints} to non-release season sites. Integer vector with
length number of animals tracked.}

\item{originNames}{Optional. Vector of names for the release season sites.}

\item{targetNames}{Optional. Vector of names for the non-release season
sites.}

\item{nSamples}{Number of times to resample \code{psi} and/or
\code{originRelAbund} OR number of bootstrap runs for GL or GPS data. In
the latter case, animals are sampled with replacement for each. For all,
the purpose is to estimate sampling uncertainty.}

\item{nSim}{Tuning parameter for GL data. Affects only the speed; 1000 seems
to work well with our data.  Should be integer > 0.}

\item{isGL}{Indicates whether or which animals were tracked with geolocators.
Should be either single TRUE or FALSE value, or vector with length of
number of animals tracked, with TRUE for animals in
\code{targetPoints} with geolocators and FALSE for animals with GPS.}

\item{geoBias}{For GL data, vector of length 2 indicating expected bias
in longitude and latitude of \code{targetPoints}, in meters.}

\item{geoVCov}{For GL data, 2x2 matrix with expected variance/covariance
in longitude and latitude of \code{targetPoints}, in meters.}

\item{row0}{If \code{originRelAbund} is an mcmc object, this can be set
to 0 (default) or any greater integer to specify where to stop ignoring
samples ("burn-in").}

\item{verbose}{0 (default) to 3. 0 prints no output during run. 1 prints
a line every 100 samples or bootstraps.  2 prints a line every sample or
bootstrap. 3 also prints a line every animal (GL or GPS data only).}

\item{calcCorr}{In addition to MC, should function also estimate continuous
correlation between release and non-release locations (GPS or GL data
only)?  Default is FALSE.}

\item{alpha}{Level for confidence/credible intervals provided.}
}
\value{
\code{estMC} returns a list with elements:
\describe{
  \item{\code{sampleMC}}{\code{nSamples} or \code{nBoot} sampled values for
     MC. Provided to allow the user to compute own summary statistics.}
  \item{\code{samplePsi}}{Array of sampled values for psi. \code{nBoot}
     OR \code{nSamples} x [number of origin sites] x [number of target
     sites]. Provided to allow the user to compute own summary statistics.}
  \item{\code{pointPsi}}{Simple point estimate of psi matrix.}
  \item{\code{pointMC}}{Simple point estimate of MC, using the point
     estimates of \code{psi} and \code{originRelAbund}.}
  \item{\code{meanMC, medianMC}}{Mean and median of \code{sampleMC}.
     Estimates of MC incorporating parametric uncertainty.}
  \item{\code{seMC}}{Standard error of MC, estimated from SD of
     \code{sampleMC}.}
  \item{\code{simpleCI}}{\code{1 - alpha} confidence interval for MC,
     estimated as \code{alpha/2} and \code{1 - alpha/2} quantiles of
     \code{sampleMC}.}
  \item{\code{bcCI}}{Bias-corrected \code{1 - alpha} confidence interval
     for MC.  Preferable to \code{simpleCI} when \code{pointMC} is the
     best estimate of MC. \code{simpleCI} is preferred when
     \code{medianMC} is a better estimator. When \code{pointMC==medianMC},
     these should be equivalent.}
  \item{\code{hpdCI}}{\code{1 - alpha} credible interval for MC,
     estimated using the highest posterior density (HPD) method.}
  \item{\code{sampleCorr}}{\code{nBoot} sampled values for continuous
     correlation. Provided to allow the user to compute own summary
     statistics.  NULL when \code{calcCorr==FALSE} or \code{!is.null(psi)}.}
  \item{\code{pointCorr}}{Simple point estimate of continuous correlation,
     using \code{originPoints} and \code{targetPoints}.  NULL when
     \code{calcCorr==FALSE} or \code{!is.null(psi)}.}
  \item{\code{meanCorr, medianCorr, seCorr, simpleCICorr, bcCICorr}}{Summary
     statistics for continuous correlation bootstraps.  NULL when
     \code{calcCorr==FALSE} or \code{!is.null(psi)}.}
}
}
\description{
Resampling of uncertainty for MC from RMark psi matrix estimates and/or JAGS
relative abundance MCMC samples.
}
\examples{
set.seed(101)
# Uncertainty in detection with equal abundances
nSamplesCMR <- 100 #10000 # Number of resampling iterations for generating confidence intervals
nSimulationsCMR <- 10 #length(cmrExamples)
\dontrun{
  nSamplesCMR <- 10000 # Number of resampling iterations for generating confidence intervals
  nSimulationsCMR <- length(cmrExamples)
}
originPos13 <- matrix(c(rep(seq(-99, -81, 2), each = 10),
                        rep(seq(49, 31, -2), 10)), 100, 2)
targetPos13 <- matrix(c(rep(seq(-79, -61, 2), each = 10),
                        rep(seq(9, -9, -2), 10)), 100, 2)
originPosCMR <- rowsum(originPos13, c(rep(1:2, 5, each = 5),
                                      rep(3:4, 5, each = 5))) / 25
originPosCMR
targetPosCMR <- rowsum(targetPos13, c(rep(1:2, 5, each = 5),
                                      rep(3:4, 5, each = 5))) / 25
targetPosCMR

originDist <- distFromPos(originPosCMR, 'ellipsoid')
targetDist <- distFromPos(targetPosCMR, 'ellipsoid')
originRelAbundTrue <- rep(0.25, 4)
# the second intermediate psi scenario, the "low" level
psiTrue <- samplePsis[["Low"]]
trueMC <- calcMC(originDist, targetDist, psiTrue, originRelAbundTrue)
trueMC

# Storage matrix for samples
cmrMCSample <- matrix(NA, nSamplesCMR, nSimulationsCMR)
summaryCMR <- data.frame(Simulation = 1:nSimulationsCMR, True=trueMC, estimate=NA,
                        mean=NA, median=NA, se=NA, lcl.simple=NA, ucl.simple=NA,
                        lcl.BC=NA, ucl.BC=NA)
for (r in 1:nSimulationsCMR) {
  cat("Simulation",r,"of",nSimulationsCMR,"\\n")
  fm <- cmrExamples[[r]]
  results <- estMC(originRelAbund = originRelAbundTrue, psi = fm,
                   originDist = originDist, targetDist = targetDist,
                   originSites = 5:8, targetSites = c(3,2,1,4),
                   nSamples = nSamplesCMR, verbose = 0)
  cmrMCSample[ , r] <- results$sampleMC
  summaryCMR$estimate[r] <- results$pointMC
  summaryCMR$mean[r] <- results$meanMC
  summaryCMR$median[r] <- results$medianMC
  summaryCMR$se[r] <- results$seMC
  # Calculate confidence intervals using quantiles of sampled MC
  summaryCMR[r, c('lcl.simple', 'ucl.simple')] <- results$simpleCI
  summaryCMR[r, c('lcl.BC', 'ucl.BC')] <- results$bcCI
}

summaryCMR <- transform(summaryCMR, coverage.simple = (True>=lcl.simple &
                                                         True<=ucl.simple),
                        coverage.BC=(True>=lcl.BC & True<=ucl.BC))
summaryCMR
summary(summaryCMR)
biasCMR <- mean(summaryCMR$estimate) - trueMC
biasCMR
mseCMR <- mean((summaryCMR$estimate - trueMC)^2)
mseCMR
rmseCMR <- sqrt(mseCMR)
rmseCMR

# Simulation of BBS data to quantify uncertainty in relative abundance
nSamplesAbund <- 700 #1700 are stored
nSimulationsAbund <- 10 #length(abundExamples) is 100
\dontrun{
  nSamplesAbund <- 1700
  nSimulationsAbund <- length(abundExamples)
}
# Storage matrix for samples
abundMCSample <- matrix(NA, nSamplesAbund, nSimulationsAbund)
summaryAbund <- data.frame(Simulation = 1:nSimulationsAbund, True = trueMC,
                           estimate = NA, mean = NA, median = NA, se = NA,
                           lcl.simple = NA, ucl.simple = NA,
                           lcl.BC = NA, ucl.BC = NA, lclHPD = NA, uclHPD = NA)
for (r in 1:nSimulationsAbund) {
  cat("Simulation",r,"of",nSimulationsAbund,"\\n")
  row0 <- nrow(abundExamples[[r]]) - nSamplesAbund
  results <- estMC(originRelAbund = abundExamples[[r]], psi = psiTrue,
                   originDist = originDist, targetDist = targetDist,
                   row0 = row0, nSamples = nSamplesAbund, verbose = 1)
  abundMCSample[ , r] <- results$sampleMC
  summaryAbund$estimate[r] <- results$pointMC
  summaryAbund$mean[r] <- results$meanMC
  summaryAbund$median[r] <- results$medianMC
  summaryAbund$se[r] <- results$seMC
  # Calculate confidence intervals using quantiles of sampled MC
  summaryAbund[r, c('lcl.simple', 'ucl.simple')] <- results$simpleCI
  summaryAbund[r, c('lcl.BC', 'ucl.BC')] <- results$bcCI
  summaryAbund[r, c('lclHPD', 'uclHPD')] <- results$hpdCI
}

summaryAbund <- transform(summaryAbund, coverage.simple = (True >= lcl.simple &
                                                             True <= ucl.simple),
                          coverage.BC=(True>=lcl.BC & True<=ucl.BC),
                          coverage.HPD=(True>=lclHPD & True<=uclHPD))
summaryAbund
summary(summaryAbund)
biasAbund <- mean(summaryAbund$estimate) - trueMC
biasAbund
mseAbund <- mean((summaryAbund$estimate - trueMC)^2)
mseAbund
rmseAbund <- sqrt(mseAbund)
rmseAbund

# Ovenbird example with GL and GPS data
nSamplesGLGPS <- 1000 # Number of bootstrap iterations
\dontrun{
  nSamplesGLGPS <- 10000 # Number of bootstrap iterations
}

# Estimate MC only, treat all data as is
glGPSMC <- estMC(isGL = OVENdata$isGL,
                 geoBias = OVENdata$geo.bias,
                 geoVCov = OVENdata$geo.vcov,
                 targetSites = OVENdata$targetSites,
                 targetPoints = OVENdata$targetPoints,
                 targetDist = OVENdata$targetDist,
                 originPoints = OVENdata$originPoints,
                 originSites = OVENdata$originSites,
                 originDist = OVENdata$originDist,
                 originRelAbund = OVENdata$originRelAbund,
                 nSamples = nSamplesGLGPS,
                 verbose=1,
                 calcCorr=FALSE)

# Estimate MC and correlation, treat all data as is
glGPSMCCorr <- estMC(isGL = OVENdata$isGL,
                     geoBias = OVENdata$geo.bias,
                     geoVCov = OVENdata$geo.vcov,
                     targetSites = OVENdata$targetSites,
                     targetPoints = OVENdata$targetPoints,
                     targetDist = OVENdata$targetDist,
                     originPoints = OVENdata$originPoints,
                     originSites = OVENdata$originSites,
                     originDist = OVENdata$originDist,
                     originRelAbund = OVENdata$originRelAbund,
                     nSamples = nSamplesGLGPS,
                     verbose=1,
                     calcCorr=TRUE)

# Estimate MC and correlation, treat GPS data as GL
glMCCorr <- estMC(isGL = TRUE,
                  geoBias = OVENdata$geo.bias,
                  geoVCov = OVENdata$geo.vcov,
                  targetSites = OVENdata$targetSites,
                  targetPoints = OVENdata$targetPoints,
                  targetDist = OVENdata$targetDist,
                  originPoints = OVENdata$originPoints,
                  originSites = OVENdata$originSites,
                  originDist = OVENdata$originDist,
                  originRelAbund = OVENdata$originRelAbund,
                  nSamples = nSamplesGLGPS,
                  verbose=1,
                  calcCorr=TRUE)
str(glGPSMC)
str(glGPSMCCorr)
str(glMCCorr)
# Estimate MC and correlation, treat GPS data as GL
gpsMCCorr <- estMC(isGL = FALSE,
                  geoBias = OVENdata$geo.bias,
                  geoVCov = OVENdata$geo.vcov,
                  targetSites = OVENdata$targetSites,
                  targetPoints = OVENdata$targetPoints,
                  targetDist = OVENdata$targetDist,
                  originPoints = OVENdata$originPoints,
                  originSites = OVENdata$originSites,
                  originDist = OVENdata$originDist,
                  originRelAbund = OVENdata$originRelAbund,
                  nSamples = nSamplesGLGPS,
                  verbose=1,
                  calcCorr=TRUE)

glGPSMCCorr0 <- estMC(isGL = OVENdata$isGL,
                     geoBias = rep(0, 2),
                     geoVCov = OVENdata$geo.vcov,
                     targetSites = OVENdata$targetSites,
                     targetPoints = OVENdata$targetPoints,
                     targetDist = OVENdata$targetDist,
                     originPoints = OVENdata$originPoints,
                     originSites = OVENdata$originSites,
                     originDist = OVENdata$originDist,
                     originRelAbund = OVENdata$originRelAbund,
                     nSamples = nSamplesGLGPS,
                     verbose=1,
                     calcCorr=TRUE)

# Estimate MC and correlation, treat GPS data as GL
glMCCorr0 <- estMC(isGL = TRUE,
                  geoBias = rep(0, 2),
                  geoVCov = OVENdata$geo.vcov,
                  targetSites = OVENdata$targetSites,
                  targetPoints = OVENdata$targetPoints,
                  targetDist = OVENdata$targetDist,
                  originPoints = OVENdata$originPoints,
                  originSites = OVENdata$originSites,
                  originDist = OVENdata$originDist,
                  originRelAbund = OVENdata$originRelAbund,
                  nSamples = nSamplesGLGPS,
                  verbose=1,
                  calcCorr=TRUE)
str(glGPSMCCorr0)
str(glMCCorr0)
# Estimate MC and correlation, treat GPS data as GL
gpsMCCorr0 <- estMC(isGL = FALSE,
                   geoBias = rep(0, 2),
                   geoVCov = OVENdata$geo.vcov,
                   targetSites = OVENdata$targetSites,
                   targetPoints = OVENdata$targetPoints,
                   targetDist = OVENdata$targetDist,
                   originPoints = OVENdata$originPoints,
                   originSites = OVENdata$originSites,
                   originDist = OVENdata$originDist,
                   originRelAbund = OVENdata$originRelAbund,
                   nSamples = nSamplesGLGPS,
                   verbose=1,
                   calcCorr=TRUE)
str(gpsMCCorr)
}

