% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estConnectivity.R
\name{estMC}
\alias{estMC}
\title{Estimate MC from abundance and/or transition probability estimates OR
geolocator and/or GPS data.}
\usage{
estMC(originDist, targetDist, originRelAbund, psi = NULL, sampleSize = NULL,
  originSites = NULL, targetSites = NULL, originPoints = NULL,
  targetPoints = NULL, originAssignment = NULL, targetAssignment = NULL,
  originNames = NULL, targetNames = NULL, nSamples = 1000, nSim = 1000,
  isGL = FALSE, geoBias = NULL, geoVCov = NULL, row0 = 0, verbose = 0,
  calcCorr = FALSE, alpha = 0.05, approxSigTest = FALSE, sigConst = 0,
  resampleProjection = "+proj=eqc +lat_ts=0 +lat_0=0 +lon_0=0 +x_0=0 +y_0=0 +a=6371007 +b=6371007 +units=m +no_defs")
}
\arguments{
\item{originDist}{Distances between the B origin sites.  Symmetric B by B
matrix.}

\item{targetDist}{Distances between the W target sites.  Symmetric W by W
matrix.}

\item{originRelAbund}{Relative abundance estimates at B origin sites. Either
a numeric vector of length B that sums to 1 or an mcmc object with
\code{nSamples} rows  and columns including 'relN[1]' through 'relN[B]'.
Currently, an mcmc object doesn't work with geolocator or GPS data.}

\item{psi}{Transition probabilities between B origin and W target sites.
Either a matrix with B rows and W columns where rows sum to 1 or a MARK
object with estimates of transition probabilities.  If you are estimating
MC from GPS or geolocator data, leave this as NULL.}

\item{sampleSize}{Total sample size of animals that psi will be estimated from.
Should be the number of animals released in one of the origin sites and
observed in one of the target sites.  Optional, but recommended, unless
you are estimating MC from GPS or geolocator data (in which case the
function can calculate it for you).}

\item{originSites}{If \code{psi} is a MARK object, this must be a numeric
vector indicating which sites are origin.  If using GL or GPS data,
this can be the geographic definition of sites in the release season.}

\item{targetSites}{If \code{psi} is a MARK object, this must be a numeric
vector indicating which sites are target.  If using GL or GPS data,
this must be the geographic definition of sites in the non-release season.}

\item{originPoints}{A \code{SpatialPoints} object, with length number of
animals tracked.  Each point indicates the release location of an animal.}

\item{targetPoints}{A \code{SpatialPoints} object, with length number of
animals tracked.  Each point indicates the point estimate location in
the non-release season.}

\item{originAssignment}{Assignment of \code{originPoints} to release season
sites. Integer vector with length number of animals tracked. Optional,
but if using GL or GPS data, either \code{originAssignment} or
\code{originSites} and \code{originPoints} should be defined.}

\item{targetAssignment}{Optional. Point estimate assignment of
\code{targetPoints} to non-release season sites. Integer vector with
length number of animals tracked.}

\item{originNames}{Optional. Vector of names for the release season sites.}

\item{targetNames}{Optional. Vector of names for the non-release season
sites.}

\item{nSamples}{Number of times to resample \code{psi} and/or
\code{originRelAbund} OR number of bootstrap runs for GL or GPS data. In
the latter case, animals are sampled with replacement for each. For all,
the purpose is to estimate sampling uncertainty.}

\item{nSim}{Tuning parameter for GL data. Affects only the speed; 1000 seems
to work well with our data.  Should be integer > 0.}

\item{isGL}{Indicates whether or which animals were tracked with geolocators.
Should be either single TRUE or FALSE value, or vector with length of
number of animals tracked, with TRUE for animals in
\code{targetPoints} with geolocators and FALSE for animals with GPS.}

\item{geoBias}{For GL data, vector of length 2 indicating expected bias
in longitude and latitude of \code{targetPoints}, in
\code{resampleProjection} units (default meters).}

\item{geoVCov}{For GL data, 2x2 matrix with expected variance/covariance
in longitude and latitude of \code{targetPoints}, in
\code{resampleProjection} units (default meters).}

\item{row0}{If \code{originRelAbund} is an mcmc object, this can be set
to 0 (default) or any greater integer to specify where to stop ignoring
samples ("burn-in").}

\item{verbose}{0 (default) to 3. 0 prints no output during run. 1 prints
a line every 100 samples or bootstraps.  2 prints a line every sample or
bootstrap. 3 also prints the number of draws (for tuning nSim for GL data only).}

\item{calcCorr}{In addition to MC, should function also estimate Mantel
correlation between release and non-release locations (GPS or GL data
only)?  Default is FALSE.}

\item{alpha}{Level for confidence/credible intervals provided.}

\item{approxSigTest}{Should function compute approximate one-sided
significance tests (p-values) for MC from the bootstrap?  Default is
FALSE.}

\item{sigConst}{Value to compare MC to in significance test.
Default is 0.}

\item{resampleProjection}{Projection when sampling from geolocator bias/error. This projection needs units = m.
   Default is Equidistant Conic = "+proj=eqc +lat_ts=0 +lat_0=0 +lon_0=0 +x_0=0 +y_0=0 +a=6371007 +b=6371007 +units=m +no_defs".
   The default setting preserves distances around latitude = 0 and longitude = 0. Below is a list of potentially useful projections
   based on the location of \code{targetSites}.

   NorthAmerica <- "+proj=eqdc +lat_0=0 +lon_0=0 +lat_1=20 +lat_2=60 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"

   SouthAmerica <- "+proj=eqdc +lat_0=0 +lon_0=0 +lat_1=-5 +lat_2=-42 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"

   Europe <- "+proj=eqdc +lat_0=0 +lon_0=0 +lat_1=43 +lat_2=62 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"

   AsiaNorth <- "+proj=eqdc +lat_0=0 +lon_0=0 +lat_1=15 +lat_2=65 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"

   AsiaSouth <- "+proj=eqdc +lat_0=0 +lon_0=0 +lat_1=7 +lat_2=-32 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"

   Africa <- "+proj=eqdc +lat_0=0 +lon_0=0 +lat_1=20 +lat_2=-23 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"

   Arctic <- "+proj=aeqd +lat_0=90 +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"

   Antarctic <- "+proj=aeqd +lat_0=-90 +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"}
}
\value{
\code{estMC} returns a list with elements:
\describe{
  \item{\code{sampleMC}}{\code{nSamples} sampled values for
     MC. Provided to allow the user to compute own summary statistics.}
  \item{\code{samplePsi}}{Array of sampled values for psi. \code{nSamples} x
     [number of origin sites] x [number of target sites]. Provided to allow
     the user to compute own summary statistics.}
  \item{\code{pointPsi}}{Simple point estimate of psi matrix.}
  \item{\code{pointMC}}{Simple point estimate of MC, using the point
     estimates of \code{psi} and \code{originRelAbund}.}
  \item{\code{meanMC, medianMC}}{Mean and median of \code{sampleMC}.
     Estimates of MC incorporating parametric uncertainty.}
  \item{\code{seMC}}{Standard error of MC, estimated from SD of
     \code{sampleMC}.}
  \item{\code{simpleCI}}{\code{1 - alpha} confidence interval for MC,
     estimated as \code{alpha/2} and \code{1 - alpha/2} quantiles of
     \code{sampleMC}.}
  \item{\code{bcCI}}{Bias-corrected \code{1 - alpha} confidence interval
     for MC.  Preferable to \code{simpleCI} when \code{meanMC} is the
     best estimate of MC. \code{simpleCI} is preferred when
     \code{medianMC} is a better estimator. When \code{meanMC==medianMC},
     these should be identical.  Estimated as the
     \code{pnorm(2 * z0 + qnorm(alpha / 2))} and
     \code{pnorm(2 * z0 + qnorm(1 - alpha / 2))} quantiles of \code{sampleMC},
     where z0 is the proportion of \code{sampleMC < meanMC}.}
  \item{\code{hpdCI}}{\code{1 - alpha} credible interval for MC,
     estimated using the highest posterior density (HPD) method.}
  \item{\code{simpleP}}{Approximate p-value for MC, estimated as the
     proportion of bootstrap iterations where MC < \code{sigConst} (or MC >
     \code{sigConst} if \code{pointMC < sigConst}).  Note that if the
     proportion is 0, a default value of 0.5 / \code{nSamples} is provided,
     but this is best interpreted as p < 1 / \code{nSamples}.  NULL when
     \code{approxSigTest==FALSE}.}
  \item{\code{bcP}}{Approximate bias-corrected p-value for MC, estimated as
     \code{pnorm(qnorm(simpleP) - 2 * z0)}, where z0 is the proportion of
     \code{sampleMC < meanMC}.  May be a better approximation of the p-value
     than \code{simpleP}, but many of the same limitations apply.  NULL when
     \code{approxSigTest==FALSE}.}
  \item{\code{sampleCorr}}{\code{nBoot} sampled values for continuous
     correlation. Provided to allow the user to compute own summary
     statistics.  NULL when \code{calcCorr==FALSE} or \code{!is.null(psi)}.}
  \item{\code{pointCorr}}{Simple point estimate of continuous correlation,
     using \code{originPoints} and \code{targetPoints}.  NULL when
     \code{calcCorr==FALSE} or \code{!is.null(psi)}.}
  \item{\code{meanCorr, medianCorr, seCorr, simpleCICorr, bcCICorr}}{Summary
     statistics for continuous correlation bootstraps.  NULL when
     \code{calcCorr==FALSE} or \code{!is.null(psi)}.}
  \item{\code{inputSampleSize}}{If \code{sampleSize} was provided, this is
     that.  If not, it is either the calculated sample size (if that can be
     done), or left at NULL.  Useful to determining whether calcMC used the
     main MC formula or that for MC(R).}
}
}
\description{
Resampling of uncertainty for MC from RMark psi matrix estimates and/or JAGS
relative abundance MCMC samples OR SpatialPoints geolocators and/or GPS
data.
}
\examples{
set.seed(101)
# Uncertainty in detection with equal abundances
# Number of resampling iterations for generating confidence intervals
nSamplesCMR <- 100 #10000
nSimulationsCMR <- 10 #100
\dontrun{
  nSamplesCMR <- 10000
  nSimulationsCMR <- 100
}
originPos13 <- matrix(c(rep(seq(-99, -81, 2), each = 10),
                        rep(seq(49, 31, -2), 10)), 100, 2)
targetPos13 <- matrix(c(rep(seq(-79, -61, 2), each = 10),
                        rep(seq(9, -9, -2), 10)), 100, 2)
originPosCMR <- rowsum(originPos13, c(rep(1:2, 5, each = 5),
                                      rep(3:4, 5, each = 5))) / 25
originPosCMR
targetPosCMR <- rowsum(targetPos13, c(rep(1:2, 5, each = 5),
                                      rep(3:4, 5, each = 5))) / 25
targetPosCMR

originDist <- distFromPos(originPosCMR, 'ellipsoid')
targetDist <- distFromPos(targetPosCMR, 'ellipsoid')
originRelAbundTrue <- rep(0.25, 4)
# the second intermediate psi scenario, the "low" level
psiTrue <- samplePsis[["Low"]]
trueMC <- calcMC(originDist, targetDist, originRelAbundTrue, psiTrue)
trueMC

# Storage matrix for samples
cmrMCSample <- matrix(NA, nSamplesCMR, nSimulationsCMR)
summaryCMR <- data.frame(Simulation = 1:nSimulationsCMR, True=trueMC, estimate=NA,
                        mean=NA, median=NA, se=NA, lcl.simple=NA, ucl.simple=NA,
                        lcl.BC=NA, ucl.BC=NA)
for (r in 1:nSimulationsCMR) {
  cat("Simulation",r,"of",nSimulationsCMR,"\\n")
  # Note: getCMRexample requires a valid internet connection and that GitHub is accessible
  fm <- getCMRexample(r)
  results <- estMC(originRelAbund = originRelAbundTrue, psi = fm,
                   originDist = originDist, targetDist = targetDist,
                   originSites = 5:8, targetSites = c(3,2,1,4),
                   nSamples = nSamplesCMR, verbose = 0,
                   sampleSize = length(grep('[2-5]', fm$data$data$ch))) #Not really needed (big sample sizes)
  cmrMCSample[ , r] <- results$sampleMC
  summaryCMR$estimate[r] <- results$pointMC
  summaryCMR$mean[r] <- results$meanMC
  summaryCMR$median[r] <- results$medianMC
  summaryCMR$se[r] <- results$seMC
  # Calculate confidence intervals using quantiles of sampled MC
  summaryCMR[r, c('lcl.simple', 'ucl.simple')] <- results$simpleCI
  summaryCMR[r, c('lcl.BC', 'ucl.BC')] <- results$bcCI
}

summaryCMR <- transform(summaryCMR, coverage.simple = (True>=lcl.simple &
                                                         True<=ucl.simple),
                        coverage.BC=(True>=lcl.BC & True<=ucl.BC))
summaryCMR
summary(summaryCMR)
biasCMR <- mean(summaryCMR$estimate) - trueMC
biasCMR
mseCMR <- mean((summaryCMR$estimate - trueMC)^2)
mseCMR
rmseCMR <- sqrt(mseCMR)
rmseCMR

# Simulation of BBS data to quantify uncertainty in relative abundance
nSamplesAbund <- 700 #1700 are stored
nSimulationsAbund <- 10 #length(abundExamples) is 100
\dontrun{
  nSamplesAbund <- 1700
  nSimulationsAbund <- length(abundExamples)
}
# Storage matrix for samples
abundMCSample <- matrix(NA, nSamplesAbund, nSimulationsAbund)
summaryAbund <- data.frame(Simulation = 1:nSimulationsAbund, True = trueMC,
                           estimate = NA, mean = NA, median = NA, se = NA,
                           lcl.simple = NA, ucl.simple = NA,
                           lcl.BC = NA, ucl.BC = NA, lclHPD = NA, uclHPD = NA)
for (r in 1:nSimulationsAbund) {
  cat("Simulation",r,"of",nSimulationsAbund,"\\n")
  row0 <- nrow(abundExamples[[r]]) - nSamplesAbund
  results <- estMC(originRelAbund = abundExamples[[r]], psi = psiTrue,
                   originDist = originDist, targetDist = targetDist,
                   row0 = row0, nSamples = nSamplesAbund, verbose = 1)
  abundMCSample[ , r] <- results$sampleMC
  summaryAbund$estimate[r] <- results$pointMC
  summaryAbund$mean[r] <- results$meanMC
  summaryAbund$median[r] <- results$medianMC
  summaryAbund$se[r] <- results$seMC
  # Calculate confidence intervals using quantiles of sampled MC
  summaryAbund[r, c('lcl.simple', 'ucl.simple')] <- results$simpleCI
  summaryAbund[r, c('lcl.BC', 'ucl.BC')] <- results$bcCI
  summaryAbund[r, c('lclHPD', 'uclHPD')] <- results$hpdCI
}

summaryAbund <- transform(summaryAbund, coverage.simple = (True >= lcl.simple &
                                                             True <= ucl.simple),
                          coverage.BC=(True>=lcl.BC & True<=ucl.BC),
                          coverage.HPD=(True>=lclHPD & True<=uclHPD))
summaryAbund
summary(summaryAbund)
biasAbund <- mean(summaryAbund$estimate) - trueMC
biasAbund
mseAbund <- mean((summaryAbund$estimate - trueMC)^2)
mseAbund
rmseAbund <- sqrt(mseAbund)
rmseAbund

# Ovenbird example with GL and GPS data
nSamplesGLGPS <- 200 # Number of bootstrap iterations
\dontrun{
  nSamplesGLGPS <- 10000 # Number of bootstrap iterations
  install.packages(c('raster', 'maptools', 'rgdal', 'rgeos', 'Rcpp'))
}

# Estimate MC only, treat all data as geolocator
GL_mc<-estMC(isGL=TRUE, # Logical vector indicating light-level geolocator (TRUE) or GPS (F)
             geoBias = OVENdata$geo.bias, # Light-level geolocator location bias
             geoVCov = OVENdata$geo.vcov, # Light-level geolocator co-variance matrix
             targetDist = OVENdata$targetDist, # Non-breeding target distribution distance matrix
             originDist = OVENdata$originDist, # Breeding / origin distribution distance matrix
             targetSites = OVENdata$targetSites, # Non-breeding target sites
             originSites = OVENdata$originSites, # Breeding origin sites
             originPoints = OVENdata$originPoints, # Capture Locations
             targetPoints = OVENdata$targetPoints, # Non-breeding Locations derived from devices
             originRelAbund = OVENdata$originRelAbund, # Relative abundance within OriginSites
             verbose = 1,   # output options
             nSamples = nSamplesGLGPS,# This is set low for example
             projection.dist.calc = raster::projection(OVENdata$targetSites))

str(GL_mc)

# Estimate MC and rM, treat all data as is
Combined<-estMC(isGL=OVENdata$isGL, # Logical vector for light-level geolocator (TRUE) or GPS (F)
                geoBias = OVENdata$geo.bias, # Light-level geolocator location bias
                geoVCov = OVENdata$geo.vcov, # Light-level geolocator co-variance matrix
                targetDist = OVENdata$targetDist, # Non-breeding target distribution distance matrix
                originDist = OVENdata$originDist, # Breeding / origin distribution distance matrix
                targetSites = OVENdata$targetSites, # Non-breeding target sites
                originSites = OVENdata$originSites, # Breeding origin sites
                originPoints = OVENdata$originPoints, # Capture Locations
                targetPoints = OVENdata$targetPoints, # Non-breeding Locations derived from devices
                originRelAbund = OVENdata$originRelAbund, # Relative abundance within OriginSites
                verbose = 1,   # output options
                calcCorr = TRUE, # estimate rM as well
                nSamples = nSamplesGLGPS, # This is set low for example
                approxSigTest = T,
                projection.dist.calc = raster::projection(OVENdata$targetSites))

# For treating all data as GPS,
# Move the latitude of birds with locations that fall off shore - only change Latitude Estimate #
tp<-OVENdata$targetPoints@coords
sp::plot(OVENdata$targetPoints)
sp::plot(OVENdata$targetSites,add=TRUE)
text(OVENdata$targetPoints@coords[,1],OVENdata$targetPoints@coords[,2],label=c(1:39))

tp[5,2]<- -1899469
tp[10,2]<- -2007848
tp[1,2]<- -2017930
tp[11,2]<- -2136511
tp[15,2]<- -2121268
tp[16,2]<- -2096063

oven_targetPoints<-sp::SpatialPoints(cbind(tp[,1],tp[,2]))
raster::crs(oven_targetPoints)<-raster::crs(OVENdata$targetPoints)

# Estimate MC only, treat all data as GPS
GPS_mc<-estMC(isGL=FALSE, # Logical vector indicating light-level geolocator (TRUE) or GPS (F)
              targetDist = OVENdata$targetDist, # Non-breeding target distribution distance matrix
              originDist = OVENdata$originDist, # Breeding / origin distribution distance matrix
              targetSites = OVENdata$targetSites, # Non-breeding target sites
              originSites = OVENdata$originSites, # Breeding origin sites
              originPoints = OVENdata$originPoints, # Capture Locations
              targetPoints = oven_targetPoints, # Non-breeding Locations derived from devices
              originRelAbund = OVENdata$originRelAbund, # Relative abundance within OriginSites
              verbose = 1,   # output options
              nSamples = nSamplesGLGPS) # This is set low for example

str(GPS_mc)
str(Combined)
str(GL_mc)
}

